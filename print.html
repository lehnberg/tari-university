<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tari Labs University</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A collection of learning resources for cryptocurrency">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
            tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
            processEscapes: true
            }
          });
        </script>
        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <img src="theme/images/tlu.png" class="tlu">

            <ol class="chapter"><li class="affix"><a href="preface/introduction.html">Introduction</a></li><li><a href="cryptography/cryptography.html"><strong aria-hidden="true">1.</strong> Cryptography</a></li><li><ol class="section"><li><a href="cryptography/crypto-1/sources/PITCHME.link.html"><strong aria-hidden="true">1.1.</strong> Elliptic curves 101</a></li><li><a href="cryptography/digital_signatures/introduction.html"><strong aria-hidden="true">1.2.</strong> Introduction to Schnorr signatures</a></li><li><ol class="section"><li><a href="cryptography/digital_signatures/basics.html"><strong aria-hidden="true">1.2.1.</strong> Basics of Schnorr signatures</a></li><li><a href="cryptography/digital_signatures/schnorr_signatures.html"><strong aria-hidden="true">1.2.2.</strong> Signature Aggregation</a></li></ol></li><li><a href="cryptography/scriptless-scripts/introduction-to-scriptless-scripts.html"><strong aria-hidden="true">1.3.</strong> Introduction to Scriptless Scripts</a></li><li><a href="cryptography/fraud-proofs-1/MainReport.html"><strong aria-hidden="true">1.4.</strong> Fraud proofs</a></li></ol></li><li><a href="consensus-mechanisms/consensus-mechanisms.html"><strong aria-hidden="true">2.</strong> Consensus Mechanisms</a></li><li><ol class="section"><li><a href="consensus-mechanisms/BFT-consensusmechanisms/sources/PITCHME.link.html"><strong aria-hidden="true">2.1.</strong> BFT Consensus Mechanisms</a></li><li><a href="consensus-mechanisms/BFT-consensus-mechanisms-applications/Introduction.html"><strong aria-hidden="true">2.2.</strong> Introduction to Applications of Byzantine Consensus Mechanisms</a></li><li><ol class="section"><li><a href="consensus-mechanisms/BFT-consensus-mechanisms-applications/Permissioned-Byzantine-Fault-Tolerant-Protocols.html"><strong aria-hidden="true">2.2.1.</strong> Permissioned Byzantine Fault Tolerant Protocols</a></li><li><a href="consensus-mechanisms/BFT-consensus-mechanisms-applications/Permissionless-Byzantine-Fault-Tolerant-Protocols(Part1).html"><strong aria-hidden="true">2.2.2.</strong> Permissionless Byzantine Fault Tolerant Protocols (Part 1)</a></li><li><a href="consensus-mechanisms/BFT-consensus-mechanisms-applications/Permissionless-Byzantine-Fault-Tolerant-Protocols(Part2).html"><strong aria-hidden="true">2.2.3.</strong> Permissionless Byzantine Fault Tolerant Protocols (Part 2)</a></li><li><a href="consensus-mechanisms/BFT-consensus-mechanisms-applications/Summary-of-Findings.html"><strong aria-hidden="true">2.2.4.</strong> Summary of Findings</a></li><li><a href="consensus-mechanisms/BFT-consensus-mechanisms-applications/References.html"><strong aria-hidden="true">2.2.5.</strong> References</a></li><li><a href="consensus-mechanisms/BFT-consensus-mechanisms-applications/Appendix.html"><strong aria-hidden="true">2.2.6.</strong> Appendix</a></li></ol></li></ol></li><li><a href="layer2scaling/layer2scaling.html"><strong aria-hidden="true">3.</strong> Layer 2 Scaling</a></li><li><ol class="section"><li><a href="layer2scaling/layer2scaling-landscape/layer2scaling-survey.html"><strong aria-hidden="true">3.1.</strong> Layer 2 Scaling Survey (part 1)</a></li><li><a href="layer2scaling/more-landscape/landscape-update.html"><strong aria-hidden="true">3.2.</strong> Layer 2 Scaling Survey (part 2)</a></li><li><a href="layer2scaling/executive-summary/sources/PITCHME.link.html"><strong aria-hidden="true">3.3.</strong> Executive Summary</a></li></ol></li><li><a href="merged-mining/merged-mining.html"><strong aria-hidden="true">4.</strong> Merged Mining</a></li><li><ol class="section"><li><a href="merged-mining/merged-mining-scene/MergedMiningIntroduction.html"><strong aria-hidden="true">4.1.</strong> Merged Mining Introduction</a></li></ol></li><li><a href="non-fungible-tokens/non-fungible-tokens.html"><strong aria-hidden="true">5.</strong> Non-fungible Tokens</a></li><li><ol class="section"><li><a href="non-fungible-tokens/nft-landscape-1/sources/PITCHME.link.html"><strong aria-hidden="true">5.1.</strong> NFT Landscape</a></li></ol></li><li><a href="protocols/protocols.html"><strong aria-hidden="true">6.</strong> Protocols</a></li><li><ol class="section"><li><a href="protocols/mimblewimble-1/sources/PITCHME.link.html"><strong aria-hidden="true">6.1.</strong> Mimblewimble</a></li><li><a href="protocols/grin-protocol-overview/MainReport.html"><strong aria-hidden="true">6.2.</strong> Mimblewimble-Grin Block Chain Protocol Overview</a></li><li><a href="protocols/grin-beam-comparison/MainReport.html"><strong aria-hidden="true">6.3.</strong> Grin vs. BEAM; a Comparison</a></li><li><a href="protocols/grin-design-choice-criticisms/MainReport.html"><strong aria-hidden="true">6.4.</strong> Grin Design Choice Criticisms - Truth or Fiction</a></li><li><a href="protocols/atomic-swaps/AtomicSwaps.html"><strong aria-hidden="true">6.5.</strong> Atomic Swaps</a></li><li><a href="protocols/lightning-network-for-dummies/sources/PITCHME.link.html"><strong aria-hidden="true">6.6.</strong> Lightning Network for Dummies</a></li><li><a href="protocols/merkle-trees-and-spv-1/sources/PITCHME.link.html"><strong aria-hidden="true">6.7.</strong> Introduction to SPV, Merkle Trees and Bloom Filters</a></li><li><a href="protocols/rgb-introduction/sources/PITCHME.link.html"><strong aria-hidden="true">6.8.</strong> The RGB Protocol - An Introduction</a></li></ol></li><li><a href="labs/introduction.html"><strong aria-hidden="true">7.</strong> Labs</a></li><li><ol class="section"><li><a href="labs/mermaid-demo.html"><strong aria-hidden="true">7.1.</strong> Mermaid demonstration</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">
<svg width="23px" height="23px" viewBox="0 0 23 23 version="1.1" class="gem" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <path d="M0,6.12859037 L0,12.5315952 L9.50941704,23 L23,12.5722492 L23,6.12859037 L9.56098655,0 L0,6.12859037 Z M8.37488789,18.3349536 L2.3103139,11.6575342 L2.3103139,8.02916483 L8.37488789,9.56385329 L8.37488789,18.3349536 Z M10.6748879,19.2090146 L10.6748879,10.1533363 L19.4932735,12.3893062 L10.6748879,19.2090146 Z M20.7,7.57180734 L20.7,10.3464428 L4.17713004,6.15908087 L9.74663677,2.58152894 L20.7,7.57180734 Z" id="Shape" fill="#000000" fill-rule="nonzero"></path>
    </g>
</svg></h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#introduction" id="introduction"><h1>Introduction</h1></a>
<p>Welcome to Tari Labs University</p>
<p>Our mission: To be the premier destination for balanced and accessible learning material for blockchain, digital currency and digital assets learning material.</p>
<p>We hope to make this a learning experience for us at Tari Labs: as a means to grow our knowledge base and internal expertise or as a refresher, but we think this will also be an excellent resource for anyone interested in the myriad of disciplines required to understand blockchain technology.</p>
<p>We would like this platform to be a place of learning- accessible to anyone, irrespective of their degree of expertise. Our aim is to cover a wide range of topics that are relevant to the Tari space, starting at a beginner level, extending down a path of deeper complexity.</p>
<a class="header" href="#errors-comments-and-contributions" id="errors-comments-and-contributions"><h2>Errors, Comments and Contributions</h2></a>
<p>We want this collection of educational presentations and videos to be collaborative affair.</p>
<p>This extends to our presentations; we are learning along with you: our content may not be perfect first time around- so we invite you to alert us to errors and issues, or better yet, if you know how to make a pull request to contribute a fix, write the correction and use a pull request.</p>
<p>As much as this learning platform is called Tari Labs University and will see input from many internal contributors and external experts, we would like you to contribute to new material, be it in the form of a suggestion of topics, varying the skill levels of presentations, or posting presentations that you may feel will benefit us as a growing community. In the words of Yoda, “Always pass on what you have learned”.</p>
<p>If you are considering contributing content to Tari Labs University, please be aware of our guiding principles.</p>
<a class="header" href="#guiding-principles" id="guiding-principles"><h3>Guiding Principles</h3></a>
<ol>
<li>The topic researched should be potentially relevant to the Tari protocol; Chat to us on #tari-research on IRC if you're not sure.</li>
<li>The topic should be thoroughly researched.</li>
<li>An critical approach should be taken taken (in the academic sense), with critiques and commentaries sought out and presented alongside the main topic. Remember that every white paper promises the world, so go and look for counterclaims.</li>
<li>A recommendation/conclusion section should be included, providing a critical analysis on whether or not the technology/proposal would be useful to the Tari protocol.</li>
<li>The work presented should be easy to read and understand, distilling complex topics into a form that is accessible to a technical but non-expert audience. Use your own voice.</li>
</ol>
<a class="header" href="#the-submission-process" id="the-submission-process"><h3>The Submission Process</h3></a>
<p>This is the basic process we follow within Tari Labs. As an external contributor, we'd appreciate it if you followed the same process.</p>
<ol>
<li>Get some agreement from the community that the topic is of interest.</li>
<li>Write up your report.</li>
<li>Push a first draft of your report as a Pull Request.</li>
<li>The community will peer-review the report; much the same as we would with a code Pull Request.</li>
<li>The report gets merged into master.</li>
<li>Receive the Fame and acclaim that is due.</li>
</ol>
<a class="header" href="#learning-paths" id="learning-paths"><h3>Learning Paths</h3></a>
<p>We have put the presentations and reports into categories of difficulty, interest and format.</p>
<a class="header" href="#presentations" id="presentations"><h4>Presentations</h4></a>
<ul>
<li><a href="https://gitpitch.com/tari-labs/tari-university/master?p=/src/non-fungible-tokens/nft-landscape-1#/">Non-Fungible Tokens</a> - An introduction to non-fungible tokens (NFTs), including the implementation of NFTs, Ethereum standards, and players in the Blockchain-based ticketing industry</li>
<li><a href="https://gitpitch.com/tari-labs/tari-university/master?p=/src/cryptography/crypto-1#/">Crypto101</a> - An into to elliptic curve math and digital signatures</li>
<li><a href="https://gitpitch.com/tari-labs/tari-university/master?p=/src/protocols/mimblewimble-1#/">Mimblewimble</a> - An introduction to Mimblewimble - a protocol that focuses on scalability and privacy through the implementation of confidential transactions</li>
<li><a href="https://gitpitch.com/tari-labs/tari-university/master?p=/src/protocols/lightning-network-for-dummies#/">Lightning Network for Dummies</a> - An introduction to the Lightning Network, including examples of its workings, procs and cons</li>
<li><a href="https://gitpitch.com/tari-labs/tari-university/master?p=/src/layer2scaling/more-landscape#/">Layer 2 Scaling Survey (Part 1)</a> - Presents an overview of different layer 2 scaling solutions being worked at today, as well as a basic SWOT analysis of each</li>
<li><a href="https://gitpitch.com/tari-labs/tari-university/master?p=/src/layer2scaling/more-landscape#/">Layer 2 Scaling Survey (Part 2)</a> - Presents an overview of different layer 2 scaling solutions being worked at today, as  well as a basic SWOT analysis of each</li>
<li><a href="https://gitpitch.com/tari-labs/tari-university/master?p=/src/layer2scaling/executive-summary#/">Layer 2 Scaling Executive summary</a> - Presents the scaling landscape, how it will be applicable to Tari, what the scaling context is for Tari and which viable scaling alternatives exists for Tari</li>
<li><a href="https://gitpitch.com/tari-labs/tari-university/master?p=/src/protocols/rgb-introduction#/">RGB Protocol</a> - An Introduction to the RGB protocol.</li>
<li><a href="https://gitpitch.com/tari-labs/tari-university/master?p=/src/protocols/merkle-trees-and-spv-1#/">SPV, Merkle Trees and Bloom Filters</a> - An Introduction to Simple Payment Verification and how it is achieved with Merkle trees and Bloom Filters</li>
<li><a href="https://gitpitch.com/tari-labs/tari-university/master?p=/src/protocols/atomic-swaps#/">Atomic Swaps</a> - Basics of Atomic Swaps</li>
<li><a href="https://gitpitch.com/tari-labs/tari-university/master?p=/src/consensus-mechanisms/BFT-consensusmechanisms#/">Byzantine Fault Tolerance and Consensus Mechanisms</a> - Understanding Byzantine Generals Problem and how consensus is achieved in cryptocurrencies</li>
<li><a href="https://gitpitch.com/tari-labs/tari-university/master?p=/src/cryptography/scriptless-scripts#/">Basics of Scriptless Scripts</a> - Basics of Scriptless Scripts</li>
</ul>
<a class="header" href="#reports" id="reports"><h4>Reports</h4></a>
<ul>
<li><a href="../merged-mining/merged-mining-scene/MergedMiningIntroduction.html">Merged Mining</a> - Presents a fundamental understanding to the concept of merged mining, including definitions, relevant case studies and vector attacks</li>
<li><a href="../layer2scaling/layer2scaling-landscape/layer2scaling-survey.html">Layer 2 Scaling Survey (Part 1)</a> - Presents an overview of different layer 2 scaling solutions being worked at today, as well as a basic SWOT analysis of each</li>
<li><a href="../layer2scaling/more-landscape/landscape-update.html">Layer 2 Scaling Survey (Part 2)</a> - Presents an overview of different layer 2 scaling solutions being worked at today, as   well as a basic SWOT analysis of each</li>
<li><a href="../protocols/atomic-swaps/AtomicSwaps.html">Atomic Swaps</a> - Basics of Atomic Swaps</li>
<li><a href="../cryptography/scriptless-scripts/introduction-to-scriptless-scripts.html">Basics of Scriptless Scripts</a> - Basics of Scriptless Scripts</li>
<li><a href="../cryptography/digital_signatures/introduction.html">Introduction to Schnorr Signatures</a> - Basics of Schnorr Signatures and Signature Aggregation
<ul>
<li><a href="../cryptography/digital_signatures/basics.html">Basics of Schnorr Signatures</a></li>
<li><a href="../cryptography/digital_signatures/schnorr_signatures.html">Signature Aggregation</a></li>
</ul>
</li>
</ul>
<a class="header" href="#beginners" id="beginners"><h4>Beginners</h4></a>
<p>Here we have a set of introductory level presentations.</p>
<ul>
<li><a href="https://gitpitch.com/tari-labs/tari-university/master?p=/src/cryptography/crypto-1#/">Crypto101</a> - An into to elliptic curve math and digital signatures</li>
<li><a href="https://gitpitch.com/tari-labs/tari-university/master?p=/src/protocols/mimblewimble-1#/">Mimblewimble</a> - An introduction to Mimblewimble - a protocol that focuses on scalability and privacy through the implementation of confidential transactions</li>
<li><a href="https://gitpitch.com/tari-labs/tari-university/master?p=/src/protocols/lightning-network-for-dummies#/">Lightning Network for Dummies</a> - An introduction to the Lightning Network, including examples of its workings, procs and cons</li>
<li><a href="https://gitpitch.com/tari-labs/tari-university/master?p=/src/non-fungible-tokens/nft-landscape-1#/">Non-Fungible Tokens</a> - An introduction to non-fungible tokens(NFTs), including the implementation of NFTs, Ethereum standards, and players in the Blockchain-based ticketing industry</li>
<li><a href="https://gitpitch.com/tari-labs/tari-university/master?p=/src/consensus-mechanisms/BFT-consensusmechanisms#/">Byzantine Fault Tolerance and Consensus Mechanisms</a> - Understanding Byzantine Generals Problem and how consensus is achieved in cryptocurrencies</li>
</ul>
<a class="header" href="#step-up-from-beginners" id="step-up-from-beginners"><h4>Step-up from Beginners</h4></a>
<p>A small jump...</p>
<ul>
<li><a href="https://gitpitch.com/tari-labs/tari-university/master?p=/src/cryptography/scriptless-scripts#/">Basics of Scriptless Scripts</a> - Basics of Scriptless Scripts</li>
<li><a href="../cryptography/digital_signatures/introduction.html">Introduction to Schnorr Signatures</a> - Basics of Schnorr Signatures and Signature Aggregation
<ul>
<li><a href="../cryptography/digital_signatures/basics.html">Basics of Schnorr Signatures</a></li>
<li><a href="../cryptography/digital_signatures/schnorr_signatures.html">Signature Aggregation</a></li>
</ul>
</li>
</ul>
<a class="header" href="#lay-of-the-land" id="lay-of-the-land"><h4>Lay of the Land</h4></a>
<ul>
<li><a href="https://gitpitch.com/tari-labs/tari-university/master?p=/src/layer2scaling/more-landscape#/">Layer 2 Scaling Survey (Part 1)</a> - Presents an overview of different layer 2 scaling solutions being worked at today, as well as a basic SWOT analysis of each</li>
<li><a href="https://gitpitch.com/tari-labs/tari-university/master?p=/src/layer2scaling/more-landscape#/">Layer 2 Scaling Survey (Part 2)</a> - Presents an overview of different layer 2 scaling solutions being worked at today, as   well as a basic SWOT analysis of each</li>
<li><a href="https://gitpitch.com/tari-labs/tari-university/master?p=/src/layer2scaling/executive-summary#/">Layer 2 Scaling Executive summary</a> - Presents the scaling landscape, how it will be applicable to Tari, what the scaling context is for Tari and which viable scaling alternatives exists for Tari</li>
</ul>
<a class="header" href="#cryptography" id="cryptography"><h1>Cryptography</h1></a>
<p>From <u><a href="https://en.wikipedia.org/wiki/Cryptography"><strong>Wikipedia</strong></a></u></p>
<p>Cryptography or cryptology (from Ancient Greek: κρυπτός, kryptós &quot;hidden, secret&quot;; and γράφειν graphein, &quot;to write&quot;, or -λογία -logia, &quot;study&quot;, respectively) is the practice and study of techniques for secure communication in the presence of third parties called adversaries. More generally, cryptography is about constructing and analyzing protocols that prevent third parties or the public from reading private messages; various aspects in information security such as data confidentiality, data integrity, authentication, and non-repudiation are central to modern cryptography.</p>
<p>From <u><a href="https://searchsecurity.techtarget.com/definition/cryptography"><strong>SearchSecurity</strong></a></u></p>
<p>Cryptography is a method of protecting information and communications through the use of codes so that only those for whom the information is intended can read and process it. The pre-fix &quot;crypt&quot; means &quot;hidden&quot; or &quot;vault&quot; and the suffix &quot;graphy&quot; stands for &quot;writing.&quot;</p>
<a class="header" href="#elliptic-curves-101" id="elliptic-curves-101"><h1>Elliptic curves 101</h1></a>
<iframe width=750 height=600 src="https://gitpitch.com/tari-labs/tari-university/master?p=/src/cryptography/crypto-1#/"></iframe>
<a class="header" href="#having-trouble-viewing-this-presentation" id="having-trouble-viewing-this-presentation"><h3>Having trouble viewing this presentation?</h3></a>
<p>View it in a <a href="https://gitpitch.com/tari-labs/tari-university/master?p=/src/cryptography/crypto-1#/">separate window</a>.</p>
<a class="header" href="#introduction-1" id="introduction-1"><h1>Introduction</h1></a>
<p>Private-public key pairs are the cornerstone of much of the
cryptographic security underlying everything from secure web browsing to banking to cryptocurrencies. Private-public key pairs
are <em>asymmetric</em>. This means that given one of the numbers (the private key), it's possible to derive the other one
(the public key). However, doing the reverse is not feasible.
It's this asymmetry that allows one to share the public key, uh, publicly and be confident that no-one can
figure out our private key (which we keep very secret and secure).</p>
<p>Asymmetric key pairs are employed in two main applications: In <em>authentication</em>, where you prove that you have knowledge of the private
key; and <em>encryption</em> where messages can be encoded and only the person possessing the private key can decrypt and read the message.</p>
<p>In this introduction on digital signatures, we'll be talking about a particular class of keys: those derived from
elliptic curves. There are other asymmetric schemes, not least of which those based on products of prime numbers,
including RSA keys [<a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)" title="Wikipedia RSA cryptography">1</a>].</p>
<p>We're going to assume you know the basics of elliptic curve cryptography (ECC). If not, don't stress, there's a
<a href="../crypto-1/sources/PITCHME.link.html">gentle introduction</a> in a previous chapter.</p>
<a class="header" href="#lets-get-started" id="lets-get-started"><h1>Let's get started</h1></a>
<p>This is an interactive introduction to digital signatures. It uses Rust code to demonstrate some of
the idea presented here, so you can see them at work. The code for this introduction makes use
of the <a href="https://github.com/tari-labs/libsecp256k1">libsecp256k-rs</a> library.</p>
<p>That's a mouthful, but secp256k1 is the name of the elliptic curve that secures a <em>lot</em> of things in many
cryptocurrencies' transactions, including Bitcoin.</p>
<p>This particular library has some nice features. We've overridden the <code>+</code> (addition) and <code>*</code> (multiplication)
operators so that the Rust code looks a lot more like mathematical formulae. This makes it much easier
to play with the ideas we'll be exploring.</p>
<p><strong>WARNING!</strong> <em>Don't use this library in production code</em>. It hasn't been battle-hardened, so <a href="https://github.com/rust-bitcoin/rust-secp256k1">use this one in
production instead</a></p>
<a class="header" href="#references" id="references"><h1>References</h1></a>
<p>[<a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)" title="Wikipedia RSA cryptography">1</a>]: RSA (cryptosystem). https://en.wikipedia.org/wiki/RSA_(cryptosystem). Accessed 11 Oct 2018.</p>
<a class="header" href="#public-and-private-keys" id="public-and-private-keys"><h2>Public and Private keys</h2></a>
<p>The first thing we'll do is create a public and private key from an elliptic curve.</p>
<p>On secp256k1, a private key is simply a scalar integer value between 0 and ~2<sup>256</sup>. That's roughly how many
atoms there are in the universe, so we have a big sandbox to play in.</p>
<p>We have a special point on the secp256k1 curve called <em>G</em>, that acts as the 'origin'. A public key is calculated by
adding <em>G</em> on the curve to itself, \( k_a \) times. This is the definition of multiplication by a scalar and is
written as such:</p>
<p>$$
P_a = k_a G
$$</p>
<p>Let's take an example from <a href="https://chuckbatson.wordpress.com/2014/11/26/secp256k1-test-vectors/">this post</a>, where
it is known that the public key for <code>1</code>, when written in uncompressed format is <code>0479BE667...C47D08FFB10D4B8</code>.
The following code snippet demonstrates this:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate libsecp256k1_rs;

use libsecp256k1_rs::{ SecretKey, PublicKey };

#[allow(non_snake_case)]
fn main() {
    // Create the secret key &quot;1&quot;
    let k = SecretKey::from_hex(&quot;0000000000000000000000000000000000000000000000000000000000000001&quot;).unwrap();
    // Generate the public key, P = k.G
    let pub_from_k = PublicKey::from_secret_key(&amp;k);
    let known_pub = PublicKey::from_hex(&quot;0479BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8&quot;).unwrap();
    // Compare it to the known value
    assert_eq!(pub_from_k, known_pub);
    println!(&quot;Ok&quot;)
}

</code></pre></pre>
<a class="header" href="#creating-a-signature" id="creating-a-signature"><h1>Creating a signature</h1></a>
<p>Reversing ECC math multiplication (i.e. division) is pretty much infeasible when using properly chosen random values for your scalars [<a href="https://stackoverflow.com/questions/2449594/how-does-a-cryptographically-secure-random-number-generator-work" title="StackOverflow: How does a cryptographically secure random number generator work?">4</a>, <a href="https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator" title="Cryptographically secure pseudorandom number generator">5</a>].
This property is called the <em>Discrete Log Problem</em> and is used as the principle behind a lot of cryptography and digital signatures.
A valid digital signature is evidence that the person providing the signature knows the private key corresponding to the public key the message
is associated with, or that they have solved the Discrete Log Problem.</p>
<p>The approach to creating signatures always follows this recipe:</p>
<ol>
<li>Generate a secret once-off number (called a <em>nonce</em>), <em>r</em></li>
<li>Create a public key, <em>R</em> from <em>r</em> (where <em>R = r.G</em>)</li>
<li>Send the following to Bob, your recipient: your message (<em>m</em>), <em>R</em>, and your public key (<em>P = k.G</em>)</li>
</ol>
<p>The actual signature is created by hashing the combination of all the public information above to create a <em>challenge</em>, e:</p>
<p>$$
e = H(R || P || m)
$$</p>
<p>The hashing function is chosen so that <em>e</em> has the same range as your private keys. In our case, we want something that
returns a 256 bit number, so SHA256 is a good choice.</p>
<p>Now the signature is constructed using your private information:</p>
<p>$$
s = r + ke
$$</p>
<p>Now Bob can also calculate <em>e</em>, since he already knows <em>m, R, P</em>. But he doesn't know your private key, or nonce.</p>
<p><strong>Note:</strong> When you construct the signature like this, it's known as a <em>Schnorr signature</em>, which we'll discuss in more
detail in the next section. There are other ways of constructing <em>s</em>, such as ECDSA [<a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm" title="Wikipedia: ECDSA">1</a>], which is used in Bitcoin.</p>
<p>But see this:</p>
<p>$$ sG = (r + ke)G $$</p>
<p>Multiply out the RHS:</p>
<p>$$ sG = rG + (kG)e $$</p>
<p>Substitute \(R = rG \) and \(P = kG \) and we have:
$$ sG = R + Pe $$</p>
<p>So Bob must just calculate the public key corresponding to the signature (<em>s.G</em>) and check that it equals the RHS of the last
equation above (<em>R + P.e</em>), all of which Bob already knows.</p>
<a class="header" href="#why-do-we-need-the-nonce" id="why-do-we-need-the-nonce"><h2>Why do we need the nonce?</h2></a>
<p>Why do we need a nonce in the standard signature?</p>
<p>Let's say we naïvely sign a message m with</p>
<p>$$
e = H(R || m)
$$</p>
<p>and then the signature would be \(s = ek \).</p>
<p>Now as before, we can check that the signature is valid:</p>
<p>$$
\begin{align}
sG &amp;= ekG \\
&amp;= e(kG) = eP
\end{align}
$$</p>
<p>So far so good. But anyone can read your private key now because <em>s</em> is a scalar, so \(k = \frac{s}{e} \)
is not hard to do.
With the nonce you have to solve \( k = (s - r)/e \), but r is unknown, so this is not a feasible calculation as long
as <em>r</em> has been chosen randomly.</p>
<p>We can show that leaving off the nonce is indeed highly insecure:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate libsecp256k1_rs as secp256k1;

use secp256k1::{SecretKey, PublicKey, thread_rng, Message};
use secp256k1::schnorr::{ Challenge};

#[allow(non_snake_case)]
fn main() {
    // Create a random private key
    let mut rng = thread_rng();
    let k = SecretKey::random(&amp;mut rng);
    println!(&quot;My private key: {}&quot;, k);
    let P = PublicKey::from_secret_key(&amp;k);
    let m = Message::hash(b&quot;Meet me at 12&quot;).unwrap();
    // Challenge, e = H(P || m)
    let e = Challenge::new(&amp;[&amp;P, &amp;m]).as_scalar().unwrap();

    // Signature
    let s = e * k;

    // Verify the signature
    assert_eq!(PublicKey::from_secret_key(&amp;s), e*P);
    println!(&quot;Signature is valid!&quot;);
    // But let's try calculate the private key from known information
    let hacked = s * e.inv();
    assert_eq!(k, hacked);
    println!(&quot;Hacked key:     {}&quot;, k)
}

</code></pre></pre>
<a class="header" href="#ecdh" id="ecdh"><h1>ECDH</h1></a>
<p>How do parties that want to communicate securely generate a shared secret for encrypting messages? One way is called
the Elliptic Curve Diffie-Hellmam exchange (ECDH) which is a simple method for doing just this.</p>
<p>ECDH is used in many places, including the Lightning Network during channel negotiation [<a href="https://github.com/lightningnetwork/lightning-rfc/blob/master/08-transport.md" title="BOLT #8: Encrypted and Authenticated Transport">2</a>].</p>
<p>Here's how it works. Alice and Bob want to communicate securely. A simple way to do this is to use each other's public keys and
calculate</p>
<p>$$
\begin{align}
S_a &amp;= k_a P_b \tag{Alice} \\
S_b &amp;= k_b P_a \tag{Bob} \\
\implies S_a = k_a k_b G &amp;\equiv S_b = k_b k_a G
\end{align}
$$</p>
<pre><pre class="playpen"><code class="language-rust">extern crate libsecp256k1_rs as secp256k1;

use secp256k1::{ SecretKey, PublicKey, thread_rng, Message };

#[allow(non_snake_case)]
fn main() {
    let mut rng = thread_rng();
    // Alice creates a public-private keypair
    let k_a = SecretKey::random(&amp;mut rng);
    let P_a = PublicKey::from_secret_key(&amp;k_a);
    // Bob creates a public-private keypair
    let k_b = SecretKey::random(&amp;mut rng);
    let P_b = PublicKey::from_secret_key(&amp;k_b);
    // They each calculate the shared secret based only on the other party's public information
    // Alice's version:
    let S_a = k_a * P_b;
    // Bob's version:
    let S_b = k_b * P_a;

    assert_eq!(S_a, S_b, &quot;The shared secret is not the same!&quot;);
    println!(&quot;The shared secret is identical&quot;)
}

</code></pre></pre>
<p>For security reasons, the private keys are usually chosen at random for each session (you'll see the term
<em>ephemeral</em> keys being used), but then we have the problem of not being sure the other party is who they say they
are (perhaps due to a man-in-the-middle attack [<a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack" title="Wikipedia: Man in the Middle Attack">3</a>]).</p>
<p>Various additional authentication steps can be employed to resolve this problem, which we won't get into here.</p>
<a class="header" href="#references-1" id="references-1"><h1>References</h1></a>
<ul>
<li>[<a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm" title="Wikipedia: ECDSA">1</a>] Elliptic Curve Digital Signature Algorithm, Wikipedia, https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm. Accessed 11/10/18.</li>
<li>[<a href="https://github.com/lightningnetwork/lightning-rfc/blob/master/08-transport.md" title="BOLT #8: Encrypted and Authenticated Transport">2</a>] BOLT #8: Encrypted and Authenticated Transport, Lightning RFC, Github. https://github.com/lightningnetwork/lightning-rfc/blob/master/08-transport.md. Accessed 11/10/18.</li>
<li>[<a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack" title="Wikipedia: Man in the Middle Attack">3</a>] Man in the Middle Attack, Wikipedia, https://en.wikipedia.org/wiki/Man-in-the-middle_attack. Accessed 11/10/18.</li>
<li>[<a href="https://stackoverflow.com/questions/2449594/how-does-a-cryptographically-secure-random-number-generator-work" title="StackOverflow: How does a cryptographically secure random number generator work?">4</a>] How does a cryptographically secure random number generator work?, StackOverflow, https://stackoverflow.com/questions/2449594/how-does-a-cryptographically-secure-random-number-generator-work. Accessed 11/10/18.</li>
<li>[<a href="https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator" title="Cryptographically secure pseudorandom number generator">5</a>] Cryptographically secure pseudorandom number generator, Wikipedia, https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator. Accessed 11/10/18.</li>
</ul>
<a class="header" href="#schnorr-signatures" id="schnorr-signatures"><h1>Schnorr signatures</h1></a>
<p>If you follow the crypto news, you'll know that that new hotness in Bitcoin is Schnorr Signatures.</p>
<p><img src="./img/schnorr-meme.jpg" alt="schnorr" /></p>
<p>But in actual fact, they're old news! The Schnorr signature is considered the simplest digital signature scheme
to be provably secure in a random oracle model. It is efficient and generates short signatures.
It was covered by U.S. Patent 4,995,082 which expired in February 2008 [<a href="https://en.wikipedia.org/wiki/Schnorr_signature" title="Wikipedia:Schnorr signature">1</a>].</p>
<a class="header" href="#so-why-all-the-fuss" id="so-why-all-the-fuss"><h2>So why all the fuss?</h2></a>
<p>What makes Schnorr signatures so interesting, and <a href="#key-cancellation-attack">potentially dangerous</a>, is their simplicity.
Schnorr signatures are <em>linear</em>, so you have some nice properties.</p>
<p>Elliptic curves have the multiplicative property. So if you have two scalars <em>x, y</em> with corresponding points, <em>X, Y</em>,
the following holds:</p>
<p>$$
(x + y)G = xG + yG = X + Y
$$</p>
<p>Schnorr signatures are of the form \( s = r + e.k \). This construction is linear too, so it fits nicely with
the linearity of elliptic curve math.</p>
<p>You saw this property in the previous section, when we were verifying the signature. Schnorr signatures' linearity
makes it very attractive for things like</p>
<ul>
<li>signature aggregation</li>
<li><a href="../../protocols/atomic-swaps/AtomicSwaps.html">atomic swaps</a></li>
<li><a href="../scriptless-scripts/introduction-to-scriptless-scripts.html">'scriptless' scripts</a></li>
</ul>
<a class="header" href="#naïve-signature-aggregation" id="naïve-signature-aggregation"><h2>(Naïve) Signature aggregation</h2></a>
<p>Let's see how the linearity property of Schnorr signatures can be used to construct a 2-of-2 multi-signature.</p>
<p>Alice and Bob want to co-sign something (a Tari transaction, say) without having to trust each other;
i.e. they need to be able to prove ownership of their respective keys, and the aggregate signature is
only valid if <em>both</em> Alice and Bob provide their part of the signature.</p>
<p>Assuming private keys are denoted \( k_i \) and public keys \( P_i \). If we ask Alice and Bob to each
supply a nonce, we can try:</p>
<p>$$
\begin{align}
P_{agg} &amp;= P_a + P_b \\
e &amp;= H(R_a || R_b || P_a || P_b || m) \\
s_{agg} &amp;= r_a + r_b + (k_a + k_b)e \\
&amp;= (r_a + k_ae) + (r_b + k_ae) \\
&amp;= s_a + s_b
\end{align}
$$</p>
<p>So it looks like Alice and Bob can supply their own <em>R</em>, and anyone can construct the 2-of-2 signature
from the sum of the <em>Rs</em> and public keys. This does work:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate libsecp256k1_rs as secp256k1;

use secp256k1::{SecretKey, PublicKey, thread_rng, Message};
use secp256k1::schnorr::{Schnorr, Challenge};

#[allow(non_snake_case)]
fn main() {
    // Alice generates some keys
    let (ka, Pa, ra, Ra) = get_keyset();
    // Bob generates some keys
    let (kb, Pb, rb, Rb) = get_keyset();
    let m = Message::hash(b&quot;a multisig transaction&quot;).unwrap();
    // The challenge uses both nonce public keys and private keys
    // e = H(Ra || Rb || Pa || Pb || H(m))
    let e = Challenge::new(&amp;[&amp;Ra, &amp;Rb, &amp;Pa, &amp;Pb, &amp;m]).as_scalar().unwrap();
    // Alice calculates her signature
    let sa = ra + ka * e;
    // Bob calculates his signature
    let sb = rb + kb * e;
    // Calculate the aggregate signature
    let s_agg = sa + sb;
    // S = s_agg.G
    let S = PublicKey::from_secret_key(&amp;s_agg);
    // This should equal Ra + Rb + e(Pa + Pb)
    assert_eq!(S, Ra + Rb + e*(Pa + Pb));
    println!(&quot;The aggregate signature is valid!&quot;)
}

#[allow(non_snake_case)]
fn get_keyset() -&gt; (SecretKey, PublicKey, SecretKey, PublicKey) {
    let mut rng = thread_rng();
    let k = SecretKey::random(&amp;mut rng);
    let P = PublicKey::from_secret_key(&amp;k);
    let r = SecretKey::random(&amp;mut rng);
    let R = PublicKey::from_secret_key(&amp;r);
    (k, P, r, R)
}

</code></pre></pre>
<p>But this scheme is not secure!</p>
<a class="header" href="#key-cancellation-attack" id="key-cancellation-attack"><h2>Key cancellation attack</h2></a>
<p>Let's take the previous scenario again, but this time, Bob knows Alice's public key and nonce ahead of time, by
waiting until she reveals them.</p>
<p>Now Bob lies, and says that his public key is \( P_b' = P_b - P_a \) and public nonce is \( R_b' = R_b - R_a \).</p>
<p>Note that Bob doesn't know the private keys for these faked values, but that doesn't matter.</p>
<p>Everyone assumes that \(s_{agg} = R_a + R_b' + e(P_a + P_b') \) as per the aggregation scheme.</p>
<p>But Bob can create this signature himself:</p>
<p>$$
\begin{align}
s_{agg}G &amp;= R_a + R_b' + e(P_a + P_b') \\
&amp;= R_a + (R_b - R_a) + e(P_a + P_b - P_a) \\
&amp;= R_b + eP_b \\
&amp;= r_bG + ek_bG \\
\therefore s_{agg} &amp;= r_b + ek_b = s_b
\end{align}
$$</p>
<pre><pre class="playpen"><code class="language-rust">extern crate libsecp256k1_rs as secp256k1;

use secp256k1::{SecretKey, PublicKey, thread_rng, Message};
use secp256k1::schnorr::{Schnorr, Challenge};

#[allow(non_snake_case)]
fn main() {
    // Alice generates some keys
    let (ka, Pa, ra, Ra) = get_keyset();
    // Bob generates some keys as before
    let (kb, Pb, rb, Rb) = get_keyset();
    // ..and then publishes his forged keys
    let Pf = Pb - Pa;
    let Rf = Rb - Ra;

    let m = Message::hash(b&quot;a multisig transaction&quot;).unwrap();
    // The challenge uses both nonce public keys and private keys
    // e = H(Ra || Rb' || Pa || Pb' || H(m))
    let e = Challenge::new(&amp;[&amp;Ra, &amp;Rf, &amp;Pa, &amp;Pf, &amp;m]).as_scalar().unwrap();

    // Bob creates a forged signature
    let s_f = rb + e * kb;
    // Check if it's valid
    let sG = Ra + Rf + e*(Pa + Pf);
    assert_eq!(sG, PublicKey::from_secret_key(&amp;s_f));
    println!(&quot;Bob successfully forged the aggregate signature!&quot;)
}

#[allow(non_snake_case)]
fn get_keyset() -&gt; (SecretKey, PublicKey, SecretKey, PublicKey) {
    let mut rng = thread_rng();
    let k = SecretKey::random(&amp;mut rng);
    let P = PublicKey::from_secret_key(&amp;k);
    let r = SecretKey::random(&amp;mut rng);
    let R = PublicKey::from_secret_key(&amp;r);
    (k, P, r, R)
}

</code></pre></pre>
<a class="header" href="#better-approaches-to-aggregation" id="better-approaches-to-aggregation"><h2>Better approaches to aggregation</h2></a>
<p>In the key attack above, Bob didn't know the private keys for his published <em>R</em> and <em>P</em> values. We could defeat Bob
by asking him to sign a message proving that he <em>does</em> know the private keys.</p>
<p>This works, but it requires another round of messaging between parties, which is not conducive to a great user experience.</p>
<p>A better approach would be one that incorporates one or more of the following features:</p>
<ul>
<li>Must be provably secure in the plain public-key model, without having to prove knowledge of secret keys, as we might have asked Bob to do in the naïve approach above;</li>
<li>should satisfy the normal Schnorr equation, i.e. the resulting signature can be verified with an expression of the form \( R + e X \).</li>
<li>allows for Interactive Aggregate Signatures (IAS) where the signers are required to cooperate;</li>
<li>allows for Non-interactive Aggregate Signatures (NAS) where the aggregation can be done by anyone;</li>
<li>allow each signer to sign the same message, <em>m</em>;</li>
<li>allow each signer to sign their own message, \( m_i \).</li>
</ul>
<a class="header" href="#musig" id="musig"><h1>MuSig</h1></a>
<p>MuSig is a recently proposed [<a href="https://blockstream.com/2018/01/23/musig-key-aggregation-schnorr-signatures.html" title="Blockstream: Key Aggregation for Schnorr Signatures">2</a>],[<a href="https://eprint.iacr.org/2018/068.pdf" title="Maxwell et. al., Simple Schnorr Multi-Signatures with Applications to Bitcoin">3</a>] simple signature aggregation scheme that satisfies all of the properties above.</p>
<p>We'll demonstrate the interactive MuSig scheme here, where each signatory signs the same message.
The scheme works as follows:</p>
<ol>
<li>Each signer has a public-private key pair as before.</li>
<li>Each signer publishes the public key of their nonce, \( R_i \),</li>
<li>Everyone calculates the same &quot;shared public key&quot;, <em>X</em> as follows:
$$
\begin{align}
\ell &amp;= H(X_1 || \dots || X_n) \\
a_i &amp;= H(\ell || X_i) \\
X &amp;= \sum a_i X_i \\
\end{align}
$$
Note that in the ordering of public keys above, some deterministic convention should be used, such as the lexicographical
order of the serialised keys.</li>
<li>Everyone also calculates the shared nonce, \( R = \sum R_i \).</li>
<li>The challenge, <em>e</em> is \( H(R || X || m) \)</li>
<li>Each signer provides their contribution to the signature as
$$
s_i = r_i + k_i a_i e
$$
Notice that the only departure here from a standard Schnorr signature is the inclusion of the factor \( a_i \).</li>
<li>The aggregate signature is the usual summation, \( s = \sum s_i \).</li>
</ol>
<p>Verification is done by confirming that</p>
<p>$$
sG \equiv R + e X \
$$</p>
<p>as usual. Proof:</p>
<p>$$
\begin{align}
sG &amp;= \sum s_i G \\
&amp;= \sum (r_i + k_i a_i e)G \\
&amp;= \sum r_iG + k_iG a_i e \\
&amp;= \sum R_i + X_i a_i e \\
&amp;= \sum R_i + e \sum a_i X_i \\
&amp;= R + e X \\
\blacksquare
\end{align}
$$</p>
<p>Let's demonstrate this using a three-of-three multisig:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate libsecp256k1_rs as secp256k1;

use secp256k1::{ SecretKey, PublicKey, thread_rng, Message };
use secp256k1::schnorr::{ Challenge };

#[allow(non_snake_case)]
fn main() {
    let (k1, X1, r1, R1) = get_keys();
    let (k2, X2, r2, R2) = get_keys();
    let (k3, X3, r3, R3) = get_keys();

    // I'm setting the order here. In general, they'll be sorted
    let l = Challenge::new(&amp;[&amp;X1, &amp;X2, &amp;X3]);
    // ai = H(l || p)
    let a1 = Challenge::new(&amp;[ &amp;l, &amp;X1 ]).as_scalar().unwrap();
    let a2 = Challenge::new(&amp;[ &amp;l, &amp;X2 ]).as_scalar().unwrap();
    let a3 = Challenge::new(&amp;[ &amp;l, &amp;X3 ]).as_scalar().unwrap();
    // X = sum( a_i X_i)
    let X = a1 * X1 + a2 * X2 + a3 * X3;

    let m = Message::hash(b&quot;SomeSharedMultiSigTx&quot;).unwrap();

    // Calc shared nonce
    let R = R1 + R2 + R3;

    // e = H(R || X || m)
    let e = Challenge::new(&amp;[&amp;R, &amp;X, &amp;m]).as_scalar().unwrap();


    // Signatures
    let s1 = r1 + k1 * a1 * e;
    let s2 = r2 + k2 * a2 * e;
    let s3 = r3 + k3 * a3 * e;
    let s = s1 + s2 + s3;

    //Verify
    let sg = PublicKey::from_secret_key(&amp;s);
    let check = R + e * X;
    assert_eq!(sg, check, &quot;The signature is INVALID&quot;);
    println!(&quot;The signature is correct!&quot;)
}

#[allow(non_snake_case)]
fn get_keys() -&gt; (SecretKey, PublicKey, SecretKey, PublicKey) {
    let mut rng = thread_rng();
    let k = SecretKey::random(&amp;mut rng);
    let P = PublicKey::from_secret_key(&amp;k);
    let r = SecretKey::random(&amp;mut rng);
    let R = PublicKey::from_secret_key(&amp;r);
    (k, P, r, R)
}
</code></pre></pre>
<a class="header" href="#security-demonstration" id="security-demonstration"><h2>Security demonstration</h2></a>
<p>As a final demonstration, let's show how MuSig defeats the cancellation attack from the naïve signature scheme described
above. Using the same idea as in <a href="#key-cancellation-attack">the previous section</a>, Bob has provided fake values for his
nonce and public keys:</p>
<p>$$
\begin{align}
R_f &amp;= R_b - R_a \\
X_f &amp;= X_b - X_a \\
\end{align}
$$</p>
<p>This leads to both Alice and Bob calculating the following &quot;shared&quot; values:</p>
<p>$$
\begin{align}
\ell &amp;= H(X_a || X_f) \\
a_a &amp;= H(\ell || X_a) \\
a_f &amp;= H(\ell || X_f) \\
X &amp;= a_a X_a + a_f X_f \\
R &amp;= R_a + R_f (= R_b) \\
e &amp;= H(R || X || m)
\end{align}
$$</p>
<p>He then tries to construct a unilateral signature following MuSig:</p>
<p>$$
s_b = r_b + k_s e
$$</p>
<p>Let's assume for now that \( k_s \) doesn't need to be Bob's private key, but that he can derive it using information
he knows. For this to be a valid signature, it must verify to \( R + eX \). So therefore</p>
<p>$$
\begin{align}
s_b G          &amp;= R + eX \\
(r_b + k_s e)G &amp;= R_b + e(a_a X_a + a_f X_f) &amp; \text{The first term looks good so far}\\
&amp;= R_b + e(a_a X_a + a_f X_b - a_f X_a) \\
&amp;= (r_b + e a_a k_a + e a_f k_b - e a_f k_a)G &amp; \text{The r terms cancel as before} \\
k_s e &amp;=  e a_a k_a + e a_f k_b - e a_f k_a &amp; \text{But nothing else is going away}\\
k_s &amp;= a_a k_a + a_f k_b - a_f k_a \\<br />
\end{align}
$$</p>
<p>In the previous attack, Bob had all the information he needed on the right-hand side of the analogous calculation. In MuSig,
Bob must somehow know Alice's private key and the faked private key (the terms don't cancel anymore) in order to create a unilateral signature
and so his cancellation attack is defeated.</p>
<a class="header" href="#references-2" id="references-2"><h1>References</h1></a>
<ul>
<li>[<a href="https://en.wikipedia.org/wiki/Schnorr_signature" title="Wikipedia:Schnorr signature">1</a>]: Schnorr signature, Wikipedia, <em>https://en.wikipedia.org/wiki/Schnorr_signature</em>, Date accessed: 19 September 2018</li>
<li>[<a href="https://blockstream.com/2018/01/23/musig-key-aggregation-schnorr-signatures.html" title="Blockstream: Key Aggregation for Schnorr Signatures">2</a>]: Key Aggregation for Schnorr Signatures, Blockstream, <em>https://blockstream.com/2018/01/23/musig-key-aggregation-schnorr-signatures.html</em>, Date accessed: 19 September 2018</li>
<li>[<a href="https://eprint.iacr.org/2018/068.pdf" title="Maxwell et. al., Simple Schnorr Multi-Signatures with Applications to Bitcoin">3</a>]: Simple Schnorr Multi-Signatures with Applications to Bitcoin, Maxwell <em>et. al.</em>, <em>https://eprint.iacr.org/2018/068.pdf</em></li>
</ul>
<a class="header" href="#contributors" id="contributors"><h1>Contributors</h1></a>
<ul>
<li><a href="https://github.com/CjS77">CjS77</a></li>
<li><a href="https://github.com/SWvHeerden">SWvHeerden</a></li>
<li><a href="https://github.com/hansieodendaal">hansieodendaal</a></li>
<li><a href="https://github.com/neonknight64">neonknight64</a></li>
</ul>
<a class="header" href="#introduction-to-scriptless-scripts" id="introduction-to-scriptless-scripts"><h1>Introduction to Scriptless Scripts</h1></a>
<ul>
<li>Definition of Scriptless Scripts</li>
<li>The Benefit of Scriptless Scripts</li>
<li>List of Scriptless Scripts</li>
<li>The Role of Schnorr Signatures</li>
<li>Schnorr multi-signatures=Scriptless Scripts</li>
<li>Adaptor Signatures</li>
<li>Simultaneous Scriptless Scripts</li>
<li>Atomic (Cross-chain Swaps) Example with Adaptor Signatures</li>
<li>Zero Knowledge Contingent Payments</li>
<li>Mimblewimble's Core Scriptless Script</li>
</ul>
<hr />
<a class="header" href="#definition-of-scriptless-scripts" id="definition-of-scriptless-scripts"><h2>Definition of Scriptless Scripts</h2></a>
<p>Scriptless Scripts are a means to execute smart contracts off-chain, through the use of Schnorr signatures. <a href="https://medium.com/blockchain-capital/crypto-innovation-spotlight-2-scriptless-scripts-306c4eb6b3a8">[1]</a></p>
<p>The concept of Scriptless Scripts was borne from Mimblewimble, which is a block chain design that with the exception of kernels and their signatures does not store permanent data. \( \eta=\gamma \) Fundamental properties of Mimblewimble include both privacy and scaling both of which require the implementation of Scriptless Scripts. <a href="https://www.youtube.com/watch?v=ovCBT1gyk9c&amp;t=0s">[2]</a></p>
<p>A brief introduction is also given in <a href="../../layer2scaling/more-landscape/landscape-update.html#a5-scriptless-scripts">#5 Scriptless scripts, Layer 2 Scaling Survey (part 2)</a></p>
<hr />
<a class="header" href="#the-benefit-of-scriptless-scripts" id="the-benefit-of-scriptless-scripts"><h2>The Benefit of Scriptless Scripts</h2></a>
<p>The benefit of Scriptless Scripts are functionality, privacy and efficiency.</p>
<p>With regards to functionality, Scriptless Scripts are said to increase the range and complexity of smart contracts. Currently, as within Bitcoin Script limitations stem from the number of <code>OP_CODES</code> that have been enabled by the network. Scriptless scripts move the specification and execution of smart contractions from the network to a discussion that only involves the participants of the smart contract.</p>
<p>With regards to privacy, moving the specification and execution of smart contracts from on-chain to off-chain increases privacy. When on-chain, many details of the smart contract are shared to the entire network including the number and addresses of participants and the amounts transferred. By moving smart contracts off-chain, the network only knows that the participants agree that the terms of their contract have been satisfied and that the transaction in question is valid.</p>
<p>With regards to efficiency, Scriptless Scripts minimize the amount of data that requires verification and storage on-chain. By moving smart contracts off-chain, there are less overheads for full nodes and lower transaction fees for users. <a href="https://medium.com/blockchain-capital/crypto-innovation-spotlight-2-scriptless-scripts-306c4eb6b3a8">[1]</a></p>
<hr />
<a class="header" href="#a-list-of-scriptless-scripts" id="a-list-of-scriptless-scripts"><h2>A list of Scriptless Scripts</h2></a>
<p>In this report various forms of Scripts will be covered. These include: <a href="https://www.youtube.com/watch?v=jzoS0tPUAiQ&amp;t=3h36m">[3]</a></p>
<ul>
<li>Simultaneous Scriptless Scripts</li>
<li>Adaptor Signatures</li>
<li>Zero Knowledge Contingent Payments</li>
</ul>
<hr />
<a class="header" href="#the-role-of-schnorr-signatures" id="the-role-of-schnorr-signatures"><h2>The Role of Schnorr Signatures</h2></a>
<p>To begin with, the fundamentals of Schnorr signatures must be defined . The signer has a private key <em>x</em>, random nonce <em>r</em>, and <em>G</em> is the generator of a discreet log hard group. <em>P</em> is the public key. <a href="https://www.youtube.com/watch?v=0mVOq1jaR1U&amp;feature=youtu.be&amp;t=39m20">[4]</a></p>
<p>s, the signature, can then be computed as a simple linear transaction</p>
<p>$$
s=r+ex
$$</p>
<p>Where:</p>
<p>$$
e=H(P||r||message)
$$</p>
<p>$$
P=xG
$$</p>
<p>The position on the line chosen is taken as the hash of all the data that one needs to commit to, the digital signature. The verification equation involves the multiplication of each of the terms in the equation by G and takes in account the cryptographic assumption (discrete log) where G can be multiplied in but not divided out, thus preventing deciphering.</p>
<p>$$
sG=rG+exG
$$</p>
<p>ECDSA signatures (used in Bitcoin) are not linear in <em>x</em> and <em>r</em>, and thus less useful <a href="https://www.youtube.com/watch?v=ovCBT1gyk9c&amp;t=0s">[2]</a></p>
<hr />
<a class="header" href="#schnorr-multi-signatures" id="schnorr-multi-signatures"><h2>Schnorr multi-signatures</h2></a>
<p>First, a mulit-signature (mulitsig) has multiple participants that produce a signature. Every participant might product a separate signature and concatenate them forming a mulitsig.</p>
<p>With Schnorr Signatures, one can have a single public key, which is the sum of many different people's public keys. the resulting key is one that signatures will be verifiable against. <a href="https://joinmarket.me/blog/blog/flipping-the-scriptless-script-on-schnorr/">[5]</a></p>
<p>The formulation of a mulitsig involves taking the sum of all components; thus all nonces and <em>s</em> values result in the formulation of a mulitsig. <a href="https://www.youtube.com/watch?v=0mVOq1jaR1U&amp;feature=youtu.be&amp;t=39m20">[4]</a></p>
<p>$$
s=Σs(i)
$$</p>
<p>It can therefore be seen that these signatures are essentially scriptless scripts. Independent public keys of several participants are joint to form a single key and signature, which when published do not divulge the details as to the number of participants involved or the original public keys.</p>
<hr />
<a class="header" href="#adaptor-signatures" id="adaptor-signatures"><h2>Adaptor Signatures</h2></a>
<p>This mulitsig protocol can be modified to produce an adaptor signature, which serves as the building block for all scriptless script functions. <a href="https://joinmarket.me/blog/blog/flipping-the-scriptless-script-on-schnorr/">[5]</a></p>
<p>Instead of functioning as full valid signature on a message with a key, an adaptor signature is a promise that a signature agreed to be published, will reveal a secret.</p>
<p>This concept is similar to that of atomic swaps, however no scrips are implemented. Since this is elliptic curve cryptography, there is only scalar multiplication of elliptic curve points. Fortunately, like a hash function, elliptic curve function in one way, so an elliptic curve point (<em>T</em>), can simply be shared and the secret will be it's corresponding private key.</p>
<p>If two parties are considered: rather than providing their nonce <em>R</em> in the mulitsig protocol, a blinding factor, taken as an elliptic curve point <em>T</em> is conceived and sent in addition to <em>R</em> (ie. <em>R+T</em>). So it can be seen that <em>R</em> is not blinded, it has instead been offset by the secret value <em>T</em>.</p>
<p>Here, the Schnorr mulitsig construction is modified such that the first party generates</p>
<p>$$
T=tG, R=rG
$$</p>
<p>where <em>t</em> is the shared secret, <em>G</em> is the generator of discreet log hard group and <em>r</em> the random nonce</p>
<p>Using this information the second party generates</p>
<p>$$
H(P||R+T||message)x
$$</p>
<p>where the coins to be swapped are contained within <em>message</em>. The first party can now calculate the complete signature <em>s</em> such that</p>
<p>$$
s=r+t+H(P||R+T||message)x
$$</p>
<p>The first party then calculates and publishes the adaptor signature <em>s'</em> to the second party (and any one else listening)</p>
<p>$$
s'=s-t
$$</p>
<p>The second party can verify the adaptor signature <em>s'</em> by asserting <em>s'G</em></p>
<p>$$
s'G =? R+H(P||R+T||message)P
$$</p>
<p>However this is not a valid signature as the hashed nonce point is <em>R+T</em> and not <em>R</em></p>
<p>The second party cannot retrieve a valid signature from this and requires ECDLP solving to recover <em>s'+t</em>, which is virtually impossible.</p>
<p>After the first party broadcasts <em>s</em> to claim the coins within <em>message</em> the second party can calculate the secret <em>t</em> from</p>
<p>$$
t=s-s'
$$</p>
<p>The above is very general however, by attaching auxiliary proofs too one can derive an adaptor signature that will let one translate correct movement of the auxiliary protocol into a valid signature.</p>
<hr />
<a class="header" href="#simultaneous-scriptless-scripts" id="simultaneous-scriptless-scripts"><h2>Simultaneous Scriptless Scripts</h2></a>
<p>The execution of separate transactions in an atomic fashion is achieved through preimages. If two transactions require the preimage to the same hash, once one is executed, the preimage is exposed so that the other one can be too. Atomic Swaps and Lightning channels use this construction. <a href="https://www.youtube.com/watch?v=0mVOq1jaR1U&amp;feature=youtu.be&amp;t=39m20">[4]</a></p>
<a class="header" href="#the-difference" id="the-difference"><h4>The Difference</h4></a>
<p>If we consider the difference of two Schnorr signatures.</p>
<p>$$
d=s-s'=k-k'+ex-e'x'
$$</p>
<p>The above equation can be verified in a similar manner to that of a single Schnorr signature, by multiplying each term by G and confirming algebraic correctness.</p>
<p>$$
dG=kG-k'G+exG-e'x'G
$$</p>
<p>It must be noted that the Schnorr signature itself is not being verified, but instead the difference <em>d</em>. <em>d</em> functions as the translating key between two separate independent Schnorr signatures. Given <em>d</em> and either <em>s</em> or <em>s'</em>, the other can be computed. So possession of <em>d</em> makes these two signatures atomic. This scheme does not link the two signatures or compromise their security.</p>
<p>For an atomic transaction, during the setup stage, someone provides the opposing party with the value <em>d</em>, and asserts it as the correct value. Once the transaction is signed it can be adjusted to complete the other transaction. Atomicity is achieved; but can only be used by the person who possesses this <em>d</em> value. Generally the party that stands to lose money requires the <em>d</em> value.</p>
<p>The <em>d</em> value provides an interesting property with regards to atomicity. It is shared before signatures are public, which in turn allows the two transactions to be atomic once the transactions are published. By taking difference of any two Schnorr signatures one is able to construct transcripts, such as an atomic swap multisig contract.</p>
<p>This is a critical feature for Mimblewimble, which was previously thought to be unable to support atomic swaps or lightning channels. <a href="https://www.youtube.com/watch?v=0mVOq1jaR1U&amp;feature=youtu.be&amp;t=39m20">[4]</a></p>
<hr />
<a class="header" href="#atomic-cross-chain-swaps-example-with-adaptor-signatures" id="atomic-cross-chain-swaps-example-with-adaptor-signatures"><h2>Atomic (Cross-chain Swaps) Example with Adaptor Signatures</h2></a>
<p>Alice has a certain number of coins on a particular block chain; Bob also has a certain number of coins on another block chain. Alice and Bob want to engage in an atomic exchange, however neither of the block chains are aware of each other nor are they able to verify each others transactions.</p>
<p>The  classical way of achieving this involves the use of the block chain's script system to put a hash preimage challenge and then reveal the same preimage on both sides: Once Alice knows the preimage, she reveals it to take her coins; Bob then copies it of one chain to the other chain to take his coins.</p>
<p>Using adaptor signatures, the same result can be achieved through simpler means. In this case, both Alice and Bob put up their coins on two of two outputs on each block chain. They sign the mulitsig protocols in parallel, where Bob then gives Alice the adaptor signatures for each side using the same value <em>T</em> ; Meaning that for Bob to take his coins he needs to reveal <em>t</em> and for Alice to take her coins she needs to reveal <em>T</em>. Bob then replaces one of the signatures and publishes <em>t</em>, taking his coins. Alice computes <em>t</em>  from the final signature, visible on the block chain and uses that to reveal another signature, giving her her coins.</p>
<p>Thus it can be seen that atomicity is achieved. One is still able to exchange information but now there are no explicit hashes or preimages on the block chain: No script properties are necessary and privacy is achieved. <a href="https://www.youtube.com/watch?v=0mVOq1jaR1U&amp;feature=youtu.be&amp;t=39m20">[4]</a></p>
<hr />
<a class="header" href="#zero-knowledge-contingent-payments" id="zero-knowledge-contingent-payments"><h2>Zero Knowledge Contingent Payments</h2></a>
<p>ZKCP is a transaction protocol. This protocol allows a buyer to purchase information from a seller using coins in a manner which is private, scalable, secure, and importantly in a trustless environment. The expected information is transferred only when  payment is made. The buyer and seller do not need to trust each other or depend on arbitration by a third party.<a href="https://bitcoincore.org/en/2016/02/26/zero-knowledge-contingent-payments-announcement/">[6]</a></p>
<hr />
<a class="header" href="#mimblewimbles-core-scriptless-script" id="mimblewimbles-core-scriptless-script"><h2>Mimblewimble's Core Scriptless Script</h2></a>
<p>As previously stated, Mimblewimble is a block chain design. Built similarly to Bitcoin, every transaction has inputs and outputs. Each input and output has a confidential transaction commitment. Confidential commitments have an interesting property where in a valid balanced transaction one can subtract the input from the output commitments, ensuring that all of the values of the Pedersen values balance out. Taking the difference of these inputs and outputs results in the mulitsig key of the owners of every output and every input in the transaction. This is referred to as the kernel.</p>
<p>Mimblewimble blocks will only have a list of new inputs, a list of new outputs and a list of signatures which are created from the aforementioned excess value. <a href="https://www.cryptocompare.com/coins/guides/what-is-mimblewimble/">[7]</a></p>
<p>Since the values are homomorphically encrypted, nodes can verify that no coin are being created or destroyed.</p>
<hr />
<a class="header" href="#references-3" id="references-3"><h2>References</h2></a>
<p>[1] Crypto Innovation Spotlight 2: Scriptless Scripts, 27 Feb 2018. https://medium.com/blockchain-capital/crypto-innovation-spotlight-2-scriptless-scripts-306c4eb6b3a8</p>
<p>[2]  Andrew Poelstra: Presentation at <a href="https://www.youtube.com/watch?v=ovCBT1gyk9c&amp;t=0s">Real World Crypto</a></p>
<p>[3]  Andrew Poelstra: Presentation at <a href="https://www.youtube.com/watch?v=jzoS0tPUAiQ&amp;t=3h36m">Layer 2 Summit Hosted by MIT DCI and Fidelity Labs</a></p>
<p>[4]  Andrew Poelstra: Presentation at <a href="https://www.youtube.com/watch?v=0mVOq1jaR1U&amp;feature=youtu.be&amp;t=39m20">MIT Bitcoin Expo Day 2017</a></p>
<p>[5]  Flipping the scriptless script on Schnorr, Nov 2017. (https://joinmarket.me/blog/blog/flipping-the-scriptless-script-on-schnorr/)</p>
<p>[6]  The first successful Zero-Knowledge Contingent Payment, 26 Feb 2016. (https://bitcoincore.org/en/2016/02/26/zero-knowledge-contingent-payments-announcement/)</p>
<p>[7]  What is Mimblewimble?, 30 Jun 2018. (https://www.cryptocompare.com/coins/guides/what-is-mimblewimble/)</p>
<a class="header" href="#fraud-proofs-and-spv-lightweight-clients---easier-said-than-done" id="fraud-proofs-and-spv-lightweight-clients---easier-said-than-done"><h1>Fraud Proofs and SPV (lightweight) clients - easier said than done?</h1></a>
<a class="header" href="#background" id="background"><h2>Background</h2></a>
<p>The Bitcoin blockchain is, as of June 2018, approximately 173 Gigabytes in size [<a href="https://www.statista.com/statistics/647523/worldwide-bitcoin-blockchain-size/" title="Size of the Bitcoin blockchain from 
2010 to 2018, by quarter (in megabytes)">1</a>]. This makes it nearly impossible for everyone to run a full Bitcoin node. Lightweight/Simplified Payment Verification (SPV) clients will have to be used by users since not everyone can run full nodes due to the computational power, bandwidth and cost needed to run a full Bitcoin node.</p>
<p>SPV clients will believe everything miners or nodes tell them, as evidenced by Peter Todd in the screenshot above showing an Android client showing millions of Bitcoins. The wallet was sent a transaction 2.1 million BTC outputs [<a href="https://www.linkedin.com/pulse/peter-todds-fraud-proofs-talk-mit-bitcoin-expo-2016-mark-morris/" title="Fraud Proofs">17</a>].
Peter modified the code for his node in order to deceive the Bitcoin wallet since the wallets can't verify coin amounts [<a href="https://github.com/petertodd/bitcoin/tree/2016-02-lie-to-spv" title="Bitcoin intergration/staging tree">27</a>] (code can be found in the &quot;Quick-n-dirty hack to lie to SPV wallets&quot; branch on his GitHub repository).</p>
<p align="center"><img src="sources/todd-btc-spv.jpg" width="301" /></p>
<div align="center"><i>Courtesy: MIT Bitcoin Expo 2016 Day 1</i></div>
<a class="header" href="#contents" id="contents"><h2>Contents</h2></a>
<ul>
<li><a href="#fraud-proofs-and-spv-lightweight-clients---easier-said-than-done">Fraud Proofs and SPV clients - easier said than done?</a>
<ul>
<li><a href="#background">Background</a></li>
<li><a href="#contents">Contents</a></li>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#full-node-vs-spv-client">Full node vs SPV client</a></li>
<li><a href="#what-are-fraud-proofs">What are fraud proofs?</a></li>
<li><a href="#fraud-proof-data-structure">Fraud proof data structure</a>
<ul>
<li><a href="#invalid-transaction-due-to-stateless-criteria-violation-correct-syntax-input-scripts-conditions-satisfiedetc">Invalid transaction due to stateless criteria violation</a></li>
<li><a href="#invalid-transaction-due-to-input-already-been-spent">Invalid transaction due to input already been spent</a></li>
<li><a href="#invalid-transaction-due-to-incorrect-generation-output-value">Invalid transaction due to incorrect generation output value</a></li>
<li><a href="#invalid-transaction-if-input-does-not-exist">Invalid transaction if input does not exist</a></li>
<li><a href="#invalid-transaction-if-input-does-not-exist-in-old-blocks">Invalid transaction if input does not exist in old blocks</a></li>
<li><a href="#missing-proof-tree-item">Missing proof tree item</a></li>
</ul>
</li>
<li><a href="#universal-fraud-proofs-suggested-improvement">Universal fraud proofs (suggested improvement)</a></li>
<li><a href="#how-spv-clients-work">How SPV clients work</a></li>
<li><a href="#security-and-privacy-issues-with-spv-clients">Security and privacy issues with SPV clients</a></li>
<li><a href="#examples-of-spv-implementations">Examples of SPV implementations</a></li>
<li><a href="#other-suggested-fraud-proof-improvements">Other suggested fraud proof improvements</a>
<ul>
<li><a href="#erasure-codes">Erasure codes</a></li>
<li><a href="#merklix-trees">Merklix trees</a></li>
<li><a href="#payment-channels">Payment channels</a></li>
</ul>
</li>
<li><a href="#conclusions-observations-recommendations">Conclusions, Observations, Recommendations</a></li>
<li><a href="#references">References</a></li>
<li><a href="#contributors">Contributors</a></li>
</ul>
</li>
</ul>
<a class="header" href="#introduction-2" id="introduction-2"><h2>Introduction</h2></a>
<p>In the original Bitcoin whitepaper, Satoshi recognized this and introduced the concept of a Simplified Payment Verification (SPV) [<a href="https://www.bitcoin.com/bitcoin.pdf" title="Bitcoin: A Peer-to-Peer Electronic Cash System, Satoshi Nakamoto">2</a>], in which he describes a technique that allows verification of payments using a lightweight client that doesn't need to download the entire Bitcoin blockchain, but rather by only downloading block headers with the longest proof-of-work chain , which are achieved by obtaining the Merkle branch linking a transaction to a block [<a href="http://docs.electrum.org/en/latest/spv.html" title="Simple Payment Verification">3</a>]. The existence of Merkle root in the chain, along with blocks added after the block containing the Merkle root, provides confirmation of the legitimacy of that chain.</p>
<p align="center"><img src="sources/proofofworkchain.png" width="700" /></p>
<div align="right"><i>Courtesy: Bitcoin: A Peer-to-Peer Electronic Cash System</i></div>
<p>In this system, the full nodes would need to provide an alert (known as a fraud proof) to SPV clients when an invalid block is detected. The SPV clients would then be prompted to download the full block and alerted transactions to
confirm the inconsistency [<a href="https://www.bitcoin.com/bitcoin.pdf" title="Bitcoin: A Peer-to-Peer Electronic Cash System, Satoshi Nakamoto">2</a>].</p>
<p>An invalid block need not be of malicious intent, but could be as a result of other accounting errors (whether by accident or malicious)</p>
<a class="header" href="#full-node-vs-spv-client" id="full-node-vs-spv-client"><h2>Full node vs SPV client</h2></a>
<p>A full Bitcoin node contains the following details:</p>
<ul>
<li>every block</li>
<li>every transaction that has ever been sent</li>
<li>all the unspent transaction outputs (UTXOs) [<a href="https://multibit.org/hd0.4/how-spv-works.html" title="SPV, Bloom filters and checkpoints">4</a>]</li>
</ul>
<p>An SPV client, however, contains:</p>
<ul>
<li>a block header with transaction data relative to the client including other transactions required to compute the Merkle root
or</li>
<li>just a block header with no transactions.</li>
</ul>
<a class="header" href="#what-are-fraud-proofs" id="what-are-fraud-proofs"><h2>What are fraud proofs?</h2></a>
<p>Fraud proofs are a way to improve the security of SPV clients [<a href="https://gist.github.com/justusranvier/451616fa4697b5f25f60" title="Improving the ability of SPV clients to detect invalid chains">5</a>] by providing a mechanism for full nodes to prove that a chain is invalid irrespective of the amount of proof of work it has [<a href="https://gist.github.com/justusranvier/451616fa4697b5f25f60" title="Improving the ability of SPV clients to detect invalid chains">5</a>]. Fraud proofs could also help with the Bitcoin scaling debate as SPV clients are easier to run and could thus help with Bitcoin scalability issues [<a href="http://www.truthcoin.info/blog/fraud-proofs/" title="Meditations on Fraud Proofs">6</a>][<a href="https://www.trustnodes.com/2017/08/12/new-satoshi-nakamoto-e-mails-revealed" title="ew Satoshi Nakamoto E-mails Revealed">18</a>].</p>
<a class="header" href="#fraud-proof-data-structure" id="fraud-proof-data-structure"><h2>Fraud proof data structure</h2></a>
<p>There are currently different proofs that are needed to prove fraud in the Bitcoin blockchain based on various actions.
Below are the various types of proofs that are needed to prove fraud based on specific fraud cases [<a href="https://gist.github.com/justusranvier/451616fa4697b5f25f60" title="Improving the ability of SPV clients to detect invalid chains">5</a>]:</p>
<a class="header" href="#invalid-transaction-due-to-stateless-criteria-violation-correct-syntax-input-scripts-conditions-satisfiedetc" id="invalid-transaction-due-to-stateless-criteria-violation-correct-syntax-input-scripts-conditions-satisfiedetc"><h3>Invalid transaction due to stateless criteria violation (correct syntax, input scripts conditions satisfied,etc)</h3></a>
<p>For an invalid transaction, the fraud proofs consist of:</p>
<ul>
<li>the header of invalid block</li>
<li>the invalid transaction</li>
<li>An invalid block's Merkle tree containing the minimum number of nodes needed to proof the existence of the invalid transaction in the tree</li>
</ul>
<a class="header" href="#invalid-transaction-due-to-input-already-been-spent" id="invalid-transaction-due-to-input-already-been-spent"><h3>Invalid transaction due to input already been spent</h3></a>
<p>For this case, the fraud proof would consist of the following:</p>
<ul>
<li>the header of the invalid block</li>
<li>the invalid transaction</li>
<li>proof that the invalid transaction is within the invalid block</li>
<li>the header of the block containing original spend transaction</li>
<li>the original spending transaction</li>
<li>proof showing that the spend transaction is within the header block of the spend transaction</li>
</ul>
<a class="header" href="#invalid-transaction-due-to-incorrect-generation-output-value" id="invalid-transaction-due-to-incorrect-generation-output-value"><h3>Invalid transaction due to incorrect generation output value</h3></a>
<p>For this case, the fraud proof consists of:</p>
<ul>
<li>the block itself</li>
</ul>
<a class="header" href="#invalid-transaction-if-input-does-not-exist" id="invalid-transaction-if-input-does-not-exist"><h3>Invalid transaction if input does not exist</h3></a>
<p>For this case, the fraud proof consists of:</p>
<ul>
<li>the entire blockchain</li>
</ul>
<p>The following fraud proofs would require changes to the Bitcoin protocol itself [<a href="https://gist.github.com/justusranvier/451616fa4697b5f25f60" title="Improving the ability of SPV clients to detect invalid chains">5</a>]</p>
<a class="header" href="#invalid-transaction-if-input-does-not-exist-in-old-blocks" id="invalid-transaction-if-input-does-not-exist-in-old-blocks"><h3>Invalid transaction if input does not exist in old blocks</h3></a>
<p>For this case, the fraud proof consists of:</p>
<ul>
<li>the header of the invalid block</li>
<li>the invalid transaction</li>
<li>proof that the header of the invalid block contains the invalid transaction</li>
<li>proof that the header of the invalid block contains the leaf node corresponding to the non-existent input</li>
<li>the block referenced by the leaf node if it exists</li>
</ul>
<a class="header" href="#missing-proof-tree-item" id="missing-proof-tree-item"><h3>Missing proof tree item</h3></a>
<p>For this case, the fraud proof consists of:</p>
<ul>
<li>the header of the invalid block</li>
<li>the transaction of the missing proof tree node</li>
<li>An indication of which input from the transaction of the missing proof tree node is missing from it</li>
<li>proof that the header of the invalid block contains the transition of the missing proof tree node</li>
<li>proof that the proof tree contains two adjacent leaf nodes</li>
</ul>
<a class="header" href="#universal-fraud-proofs-suggested-improvement" id="universal-fraud-proofs-suggested-improvement"><h2>Universal fraud proofs (suggested improvement)</h2></a>
<p>As can be seen, requiring different fraud proof constructions for different fraud proofs can get cumbersome. In a recent paper, Al-Bassam, et al [<a href="https://arxiv.org/pdf/1809.09044.pdf" title="Fraud Proofs: Maximising Light Client Security and Scaling Blockchains with Dishonest Majorities">26</a>] proposed a general, universal fraud proof construction for most cases.
Their proposition is to generalize the entire blockchain as a state transition system and represent the entire state as a Merkle root using a Sparse Merkle tree, with each transaction changing the state root of the blockchain. This can be simplified by this function:</p>
<ul>
<li><code>transaction(state,tx) = State or Error</code></li>
</ul>
<p align="center"><img src="sources/stateroot.png" width="500" /></p>
<div align="right"><i>Courtesy: Fraud Proofs: Maximising Light Client Security and Scaling Blockchains with Dishonest Majorities</i></div>
<p>In the case of the Bitcoin blockchain, representing the entire blockchain as a key-value store Sparse Merkle tree would mean:</p>
<ul>
<li><code>Key = UTXO ID</code></li>
<li><code>Value = 1 if unspent or 0 if spent</code></li>
</ul>
<p>Each transaction will change the state root of the blockchain and can be represented with this function:</p>
<ul>
<li><code>TransitionRoot(stateRoot,tx,Witnesses) = stateRoot or Error</code></li>
</ul>
<p>In this proposition, a valid fraud proof construction will consist of:</p>
<ul>
<li>the transaction</li>
<li>the pre-state root</li>
<li>the post-state root</li>
<li>Witnesses (Merkle proofs of all the parts of the state the transactions accesses/modifies)</li>
</ul>
<p>Also expressed as this function:</p>
<ul>
<li><code>rootTransition(stateRoot, tx, witnesses) != stateRoot</code></li>
</ul>
<p>So a full node would send a light client/SPV this data to proof a valid fraud proof. The SPV would compute this function and if the transition root of the state root is different from the state root in the block then the block is rejected.</p>
<p align="center"><img src="sources/fraudproof.png" width="500" /></p>
<div align="right"><i>Courtesy: Fraud Proofs: Maximising Light Client Security and Scaling Blockchains with Dishonest Majorities</i></div>
<p>The post-state root can be excluded in order to save block space but that does, however, increase the fraud proof size. This works with the assumption that the SPV client is connected to a minimum of one honest node.</p>
<a class="header" href="#how-spv-clients-work" id="how-spv-clients-work"><h2>How SPV clients work</h2></a>
<p>SPV clients make use of Bloom filters to receive transactions that are relevant to the user [<a href="https://eprint.iacr.org/2014/763.pdf" title="On the Privacy Provisions of Bloom Filters in Lightweight Bitcoin Clients">7</a>]. Bloom filters are probabilistic data structures used to check the existence of an element in a set quicker by responding with a boolean answer [<a href="https://medium.com/blockchain-musings/a-case-of-false-positives-in-bloom-filters-da09ec487ff0" title="A Case of False Positives in Bloom Filters,">9</a>]</p>
<p align="center"><img src="sources/spv.png" width="600" /></p>
<div align="right"><i>Courtesy: On the Privacy Provisions of Bloom Filters in Lightweight Bitcoin Clients [[7]]</i></div>
<p>In addition to Bloom filters, SPV clients rely on Merkle trees [<a href="https://arxiv.org/pdf/1809.09044.pdf" title="Fraud Proofs: Maximising Light Client Security and Scaling Blockchains with Dishonest Majorities">26</a>] - binary structures that have a list of all the hashes between the block (apex) and the transaction (leaf). With Merkle trees, one only needs to check a small part of the block, called a Merkle root, to prove that the transaction has been accepted in the network [<a href="https://multibit.org/hd0.4/how-spv-works.html" title="SPV, Bloom filters and checkpoints">8</a>].</p>
<p align="center"><img src="sources/merkle-tree.png" width="800" /></p>
<p>Fraud proofs are integral to the security of SPV clients, however, the other components in SPV clients are not without issues.</p>
<a class="header" href="#security-and-privacy-issues-with-spv-clients" id="security-and-privacy-issues-with-spv-clients"><h2>Security and privacy issues with SPV clients</h2></a>
<ul>
<li><strong>Weak Bloom filters and Merkle tree designs</strong></li>
</ul>
<p>In August 2017, a weakness in the Bitcoin Merkle tree design was found to reduce the security of SPV clients which could allow an attacker to simulate a payment of arbitrary amount to a victim using a SPV wallet, and trick the victim into accepting it as valid [<a href="s-reduces-the-security-of-spv-clients/" title="The Design Of Bitcoin Merkle Trees Reduces The Security Of SPV Clients">10</a>]. The bitcoin Merkle tree makes no distinction between inner and leaf nodes and could thus be manipulated by an attack that could re-interpret transactions as nodes and nodes as transactions [<a href="https://bitslog.wordpress.com/2018/06/09/leaf-node-weakness-in-bitcoin-merkle-tree-design/" title="Leaf-Node weakness in Bitcoin Merkle Tree Design">11</a>]. This weakness is due to inner nodes having no format and only requiring the length to be 64 bytes.</p>
<p>This brute force attack particularly affects systems that automatically accept SPV proofs and could be carried out with an investment of approximately $3 million. One proposed solution is to ensure that no internal, 64-bit node is ever accepted as a valid transaction by SPV wallets/clients [<a href="https://bitslog.wordpress.com/2018/06/09/leaf-node-weakness-in-bitcoin-merkle-tree-design/" title="Leaf-Node weakness in Bitcoin Merkle Tree Design">11</a>].</p>
<p>The BIP37 SPV [<a href="https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki" title="bip-0037.mediawiki">13</a>] Bloom filters don't have relevant privacy features [<a href="https://eprint.iacr.org/2014/763.pdf" title="On the Privacy Provisions of Bloom Filters in Lightweight Bitcoin Clients">7</a>] and leak information such as determining if multiple address belong to a single owner, as well as leaking of IP addresses of the user [<a href="https://bisq.network/blog/privacy-in-bitsquare/" title="rivacy in bitsquare">12</a>] (if TOR or VPNs aren't used).</p>
<p>Furthermore, SPV clients pose the risk of a denial of service attack against full nodes due to processing load (80Gig disk reads) when SPV clients sync and full nodes themselves can cause a denial of service against SPV clients by returning NULL filter responses to requests [<a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-May/012636.html" title="Committed bloom filters for improved wallet performance and SPV security">14</a>]. Peter Todd's Bloom-io-attack aptly demonstrates the risk of SPV denial of service [<a href="https://github.com/petertodd/bloom-io-attack" title="Bloom-io-attack">15</a>].</p>
<p>To address this, a new concept called committed Bloom filters was introduced to improve the performance and security of SPV clients. In this concept, which can be used in lieu of BIP37 [<a href="https://www.newsbtc.com/2016/05/10/developers-introduce-bloom-filters-improve-bitcoin-wallet-security/" title="Committed Bloom Filters Versus BIP37 SPV">16</a>], a Bloom filter digest (BFD) of every blocks inputs, outputs and transactions is created with a filter that consists of a small size of the overall block size [<a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-May/012636.html" title="Committed bloom filters for improved wallet performance and SPV security">14</a>].</p>
<p>A second Bloom filter is created with all transactions and a binary comparison is made to determine matching transactions. This BFD allows the caching of filters by SPV clients without the need to re-compute [<a href="https://www.newsbtc.com/2016/05/10/developers-introduce-bloom-filters-improve-bitcoin-wallet-security/" title="Committed Bloom Filters Versus BIP37 SPV">16</a>] and also introduces semi-trusted oracles to improve the security and privacy of SPV clients by allowing SPV clients to download block data via any out of band method. [<a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-May/012636.html" title="Committed bloom filters for improved wallet performance and SPV security">14</a>]</p>
<a class="header" href="#examples-of-spv-implementations" id="examples-of-spv-implementations"><h2>Examples of SPV implementations</h2></a>
<p>There are two well-known SPV implementations for Bitcoin - Bitcoinj and Electrum. The latter does SPV level validation, comparing multiple electrum servers against each other. It's got very similar security to Bitcoinj, but potentially better privacy [<a href="https://www.reddit.com/r/Bitcoin/comments/3c3zn4/whats_the_difference_between_an_api_wallet_and_a/" title="Whats the difference between an API wallet and a SPV wallet?">25</a>] due to Bitcoinj's Bloom filters implementation [<a href="https://eprint.iacr.org/2014/763.pdf" title="On the Privacy Provisions of Bloom Filters in Lightweight Bitcoin Clients">7</a>].</p>
<a class="header" href="#other-suggested-fraud-proof-improvements" id="other-suggested-fraud-proof-improvements"><h2>Other suggested fraud proof improvements</h2></a>
<a class="header" href="#erasure-codes" id="erasure-codes"><h3>Erasure codes</h3></a>
<p>Along with the proposed universal fraud proof solution, another data availability issue with fraud proofs is erasure coding. Erasure coding allows a piece of data M chunks long to be expanded into a piece of data N chunks long (“chunks” can be of arbitrary size), such that any M of the N chunks can be used to recover the original data. Blocks are then required to commit the Merkle root of this extended data and have light clients probabilistically check that the majority of the extended data is available [<a href="https://www.trustnodes.com/2017/08/14/vitalik-buterin-peter-todd-go-head-head-crypto-culture-wars" title="Vitalik Buterin and Peter Todd Go Head to Head in the Crypto Culture Wars">21</a>].</p>
<p>According to the proposed solution, one of three conditions will be true to the SPV client when using erasure codes [<a href="https://github.com/ethereum/research/wiki/A-note-on-data-availability-and-erasure-coding" title="A note on data availability and erasure coding">20</a>]:</p>
<ol>
<li>The entire extended data is available, the erasure code is constructed correctly, and the block is valid.</li>
<li>The entire extended data is available, the erasure code is constructed correctly, but the block is invalid.</li>
<li>The entire extended data is available, but the erasure code is constructed incorrectly.</li>
</ol>
<p>In case (1), the block is valid and the light client can accept it. In case (2), it is expected that some other node will quickly construct and relay a fraud proof. In case (3), it is also expected that some other node will quickly construct and relay a specialized kind of fraud proof that shows that the erasure code is constructed incorrectly.</p>
<a class="header" href="#merklix-trees" id="merklix-trees"><h3>Merklix trees</h3></a>
<p>Another suggested fraud proof improvement for the Bitcoin blockchain is by means of block sharding and validation using Merklix trees. Merklix trees are essentially Merkle trees that use unordered set [<a href="https://www.deadalnix.me/2016/09/24/introducing-merklix-tree-as-an-unordered-merkle-tree-on-steroid/" title="Introducing Merklix tree as an unordered Merkle tree on steroid">22</a>].
This also assumes that there is at least one honest node per shard. Using Merklix proofs, the following can be proven [<a href="https://www.deadalnix.me/2016/11/06/using-merklix-tree-to-shard-block-validation/" title="Using Merklix tree to shard block validation">23</a>]:</p>
<ol>
<li>
<p>A transaction is in the block;</p>
</li>
<li>
<p>It's inputs and outputs are or aren't in the UTXO set.</p>
</li>
</ol>
<p>In this scenario, SPV clients can be made aware of any invalidity in blocks and can’t be lied to about the UTXO set.</p>
<a class="header" href="#payment-channels" id="payment-channels"><h3>Payment channels</h3></a>
<p>Bitcoin is made to be resilient to denial of service (Dos) attacks, however, the same cannot be said for SPV clients. This could be an issue if malicious alerting nodes spam with false fraud proofs.
A proposed solution to this is payment channels [<a href="http://www.truthcoin.info/blog/fraud-proofs/" title="Meditations on Fraud Proofs">6</a>] due to them:</p>
<ol>
<li>Operating at near instant speeds thus allowing quick alerting of fraud proofs;</li>
<li>Facilitate micro-transactions;</li>
<li>Are robust to temporary mining failures (as they use long “custodial periods”).</li>
</ol>
<p>In this way, the use of payment channels can help with incentivising full nodes to issue fraud proofs.</p>
<a class="header" href="#conclusions-observations-recommendations" id="conclusions-observations-recommendations"><h2>Conclusions, Observations, Recommendations</h2></a>
<p>Fraud proofs can be complex [<a href="http://www.truthcoin.info/blog/fraud-proofs/" title="Meditations on Fraud Proofs">6</a>] and hard to implement, but appear to be necessary for scale ability of blockchains and the security and privacy for SPV clients, since not everyone can nor should want to run a full node to participate in the network. The current SPV implementations are working on improving the security and privacy of these SPV clients. Furthermore, for current blockchains, a hard or soft fork would need to be done in order to accommodate the data in the block headers.</p>
<p>Based on <a href="#suggested-fraud-proof-improvements">3 different fraud proof proposals</a> that suggest some sort of incentive for nodes that issue alert/fraud proofs, it seems likely that some sort of fraud proof providers and consumers market place will have to emerge.</p>
<p>Where Tari is concerned, it would appear that the universal fraud proof proposals or something similar would need to be looked into as undoubtedly end users of the protocol/network will mostly be using light clients. However, since these fraud proofs work on the assumption of a minimum of one honest node, in the case of a digital issuer (which may be one or more), a fraud proof won't be viable on this assumption as the digital issuer could be the sole node.</p>
<a class="header" href="#references-4" id="references-4"><h2>References</h2></a>
<p>[<a href="https://www.statista.com/statistics/647523/worldwide-bitcoin-blockchain-size/" title="Size of the Bitcoin blockchain from 
2010 to 2018, by quarter (in megabytes)">1</a>] Size of the Bitcoin blockchain from 2010 to 2018, by quarter (in megabytes),  https://www.statista.com/statistics/647523/worldwide-bitcoin-blockchain-size/, Date accessed: 2018-09-10.</p>
<p>[<a href="https://www.bitcoin.com/bitcoin.pdf" title="Bitcoin: A Peer-to-Peer Electronic Cash System, Satoshi Nakamoto">2</a>] Bitcoin: A Peer-to-Peer Electronic Cash System, Satoshi Nakamoto, https://www.bitcoin.com/bitcoin.pdf, Date accessed: 2018-09-10.</p>
<p>[<a href="http://docs.electrum.org/en/latest/spv.html" title="Simple Payment Verification">3</a>] Simple Payment Verification, http://docs.electrum.org/en/latest/spv.html , Date accessed: 2018-09-10.</p>
<p>[<a href="https://multibit.org/hd0.4/how-spv-works.html" title="SPV, Bloom filters and checkpoints">4</a>] SPV, Bloom filters and checkpoints, https://multibit.org/hd0.4/how-spv-works.html, Date accessed: 2018-09-10.</p>
<p>[<a href="https://gist.github.com/justusranvier/451616fa4697b5f25f60" title="Improving the ability of SPV clients to detect invalid chains">5</a>] Improving the ability of SPV clients to detect invalid chains
, https://gist.github.com/justusranvier/451616fa4697b5f25f60, Date accessed: 2018-09-10.</p>
<p>[<a href="http://www.truthcoin.info/blog/fraud-proofs/" title="Meditations on Fraud Proofs">6</a>] Meditations on Fraud Proofs, http://www.truthcoin.info/blog/fraud-proofs/, Dated accessed: 2018-09-10.</p>
<p>[<a href="https://eprint.iacr.org/2014/763.pdf" title="On the Privacy Provisions of Bloom Filters in Lightweight Bitcoin Clients">7</a>] On the Privacy Provisions of Bloom Filters in Lightweight Bitcoin Clients, Arthur Gervais, et al, https://eprint.iacr.org/2014/763.pdf, Date accessed: 2018-09-10.</p>
<p>[<a href="https://multibit.org/hd0.4/how-spv-works.html" title="SPV, Bloom filters and checkpoints">8</a>] SPV, Bloom filters and checkpoints, https://multibit.org/hd0.4/how-spv-works.html, Date accessed: 2018-09-10.</p>
<p>[<a href="https://medium.com/blockchain-musings/a-case-of-false-positives-in-bloom-filters-da09ec487ff0" title="A Case of False Positives in Bloom Filters,">9</a>] A Case of False Positives in Bloom Filters, https://medium.com/blockchain-musings/a-case-of-false-positives-in-bloom-filters-da09ec487ff0, Date accessed: 2018-09-11.</p>
<p>[<a href="s-reduces-the-security-of-spv-clients/" title="The Design Of Bitcoin Merkle Trees Reduces The Security Of SPV Clients">10</a>] The Design Of Bitcoin Merkle Trees Reduces The Security Of SPV Clients, https://media.rsk.co/the-design-of-bitcoin-merkle-trees-reduces-the-security-of-spv-clients/, Date accessed: 2018-09-11.</p>
<p>[<a href="https://bitslog.wordpress.com/2018/06/09/leaf-node-weakness-in-bitcoin-merkle-tree-design/" title="Leaf-Node weakness in Bitcoin Merkle Tree Design">11</a>] Leaf-Node weakness in Bitcoin Merkle Tree Design,https://bitslog.wordpress.com/2018/06/09/leaf-node-weakness-in-bitcoin-merkle-tree-design/, Date accessed: 2018-09-11.</p>
<p>[<a href="https://bisq.network/blog/privacy-in-bitsquare/" title="rivacy in bitsquare">12</a>] Privacy in bitsquare, https://bisq.network/blog/privacy-in-bitsquare/, Date accessed: 2018-09-11.</p>
<p>[<a href="https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki" title="bip-0037.mediawiki">13</a>] bip-0037.mediawiki, https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki, Date accessed: 2018-09-11.</p>
<p>[<a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-May/012636.html" title="Committed bloom filters for improved wallet performance and SPV security">14</a>] Committed Bloom filters for improved wallet performance and SPV security, https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-May/012636.html, Date accessed: 2018-09-11.</p>
<p>[<a href="https://github.com/petertodd/bloom-io-attack" title="Bloom-io-attack">15</a>] Bloom-io-attack, https://github.com/petertodd/bloom-io-attack, Date accessed: 2018-09-11.</p>
<p>[<a href="https://www.newsbtc.com/2016/05/10/developers-introduce-bloom-filters-improve-bitcoin-wallet-security/" title="Committed Bloom Filters Versus BIP37 SPV">16</a>] Committed Bloom Filters Versus BIP37 SPV, https://www.newsbtc.com/2016/05/10/developers-introduce-bloom-filters-improve-bitcoin-wallet-security/, Date accessed: 2018-09-12.</p>
<p>[<a href="https://www.linkedin.com/pulse/peter-todds-fraud-proofs-talk-mit-bitcoin-expo-2016-mark-morris/" title="Fraud Proofs">17</a>] Fraud Proofs, https://www.linkedin.com/pulse/peter-todds-fraud-proofs-talk-mit-bitcoin-expo-2016-mark-morris/, Date accessed: 2018-09-12.</p>
<p>[<a href="https://www.trustnodes.com/2017/08/12/new-satoshi-nakamoto-e-mails-revealed" title="ew Satoshi Nakamoto E-mails Revealed">18</a>] New Satoshi Nakamoto E-mails Revealed
, https://www.trustnodes.com/2017/08/12/new-satoshi-nakamoto-e-mails-revealed, Date accessed: 2018-09-12.</p>
<p>[<a href="https://plasma.io/plasma.pdf" title="Plasma: Scalable Autonomous Smart Contracts">19</a>] Plasma: Scalable Autonomous Smart Contracts, Joseph Poon &amp; Vitalik Buterin, https://plasma.io/plasma.pdf, Date accessed: 2018-09-13.</p>
<p>[<a href="https://github.com/ethereum/research/wiki/A-note-on-data-availability-and-erasure-coding" title="A note on data availability and erasure coding">20</a>] A note on data availability and erasure coding
, https://github.com/ethereum/research/wiki/A-note-on-data-availability-and-erasure-coding, Date accessed: 2018-09-13.</p>
<p>[<a href="https://www.trustnodes.com/2017/08/14/vitalik-buterin-peter-todd-go-head-head-crypto-culture-wars" title="Vitalik Buterin and Peter Todd Go Head to Head in the Crypto Culture Wars">21</a>] Vitalik Buterin and Peter Todd Go Head to Head in the Crypto Culture Wars, https://www.trustnodes.com/2017/08/14/vitalik-buterin-peter-todd-go-head-head-crypto-culture-wars, Date accessed: 2018-09-14.</p>
<p>[<a href="https://www.deadalnix.me/2016/09/24/introducing-merklix-tree-as-an-unordered-merkle-tree-on-steroid/" title="Introducing Merklix tree as an unordered Merkle tree on steroid">22</a>] Introducing Merklix tree as an unordered Merkle tree on steroid, https://www.deadalnix.me/2016/09/24/introducing-merklix-tree-as-an-unordered-merkle-tree-on-steroid/, Date accessed 2018-09-14.</p>
<p>[<a href="https://www.deadalnix.me/2016/11/06/using-merklix-tree-to-shard-block-validation/" title="Using Merklix tree to shard block validation">23</a>] Using Merklix tree to shard block validation, https://www.deadalnix.me/2016/11/06/using-merklix-tree-to-shard-block-validation/, Date accessed: 2018-09-14.</p>
<p>[<a href="https://bitco.in/forum/threads/fraud-proofs.1617/" title="fraud proofs">24</a>] fraud proofs, https://bitco.in/forum/threads/fraud-proofs.1617/, Date accessed: 2018-09-18.</p>
<p>[<a href="https://www.reddit.com/r/Bitcoin/comments/3c3zn4/whats_the_difference_between_an_api_wallet_and_a/" title="Whats the difference between an API wallet and a SPV wallet?">25</a>] Whats the difference between an API wallet and a SPV wallet?, https://www.reddit.com/r/Bitcoin/comments/3c3zn4/whats_the_difference_between_an_api_wallet_and_a/, Date accessed: 2018-09-21.</p>
<p>[<a href="https://arxiv.org/pdf/1809.09044.pdf" title="Fraud Proofs: Maximising Light Client Security and Scaling Blockchains with Dishonest Majorities">26</a>] Fraud Proofs: Maximising Light Client Security and Scaling Blockchains with Dishonest Majorities, Mustafa Al-Bassam, Alberto Sinnino, Vitalik Butterin, https://arxiv.org/pdf/1809.09044.pdf, Date accessed: 2018-10-08.</p>
<p>[<a href="https://github.com/petertodd/bitcoin/tree/2016-02-lie-to-spv" title="Bitcoin intergration/staging tree">27</a>] Bitcoin intergration/staging tree, https://github.com/petertodd/bitcoin/tree/2016-02-lie-to-spv , Date accessed: 2018-10-12.</p>
<a class="header" href="#contributors-1" id="contributors-1"><h2>Contributors</h2></a>
<ul>
<li><a href="https://github.com/ksloven">https://github.com/ksloven</a></li>
<li><a href="https://github.com/CjS77">https://github.com/CjS77</a></li>
<li><a href="https://github.com/hansieodendaal">https://github.com/hansieodendaal</a></li>
</ul>
<a class="header" href="#consensus-mechanisms" id="consensus-mechanisms"><h1>Consensus Mechanisms</h1></a>
<p>From <a href="https://www.investopedia.com/terms/c/consensus-mechanism-cryptocurrency.asp"><u><strong>Investopedia</strong></u></a></p>
<p>A consensus mechanism is a fault-tolerant mechanism that is used in computer and blockchain systems to achieve the necessary agreement on a single data value or a single state of the network among distributed processes or multi-agent systems.</p>
<p>From <a href="https://assets.kpmg.com/content/dam/kpmg/pdf/2016/06/kpmg-blockchain-consensus-mechanism.pdf"><strong><u>KPMG</u></strong></a></p>
<p>Consensus mechanism: A method of authenticating and validating a value or transaction on a Blockchain or a distributed ledger without the need to trust or rely on a central authority. Consensus mechanisms are central to the functioning of any blockchain or distributed ledger.</p>
<a class="header" href="#bft-consensus-mechanisms" id="bft-consensus-mechanisms"><h1>BFT Consensus Mechanisms</h1></a>
<iframe width=750 height=600 src="https://gitpitch.com/tari-labs/tari-university/master?p=/src/consensus-mechanisms/BFT-consensusmechanisms#/"></iframe>
<a class="header" href="#having-trouble-viewing-this-presentation-1" id="having-trouble-viewing-this-presentation-1"><h3>Having trouble viewing this presentation?</h3></a>
<p>View it in a <a href="https://gitpitch.com/tari-labs/tari-university/master?p=/src/consensus-mechanisms/BFT-consensusmechanisms#/">separate window</a>.</p>
<a class="header" href="#introduction-to-applications-of-byzantine-consensus-mechanisms" id="introduction-to-applications-of-byzantine-consensus-mechanisms"><h1>Introduction to Applications of Byzantine Consensus Mechanisms</h1></a>
<p>When considering the how Tari will potentially build its second layer, an analysis of the most promising Byzantine Consensus Mechanisms and their applications was sought.</p>
<p>Important to consider is the 'scalability trilemma'; a phrase referred to by Vitalik Buterin, which takes into account the potential trade-offs regarding decentralization, security and scalability. [<a href="https://bitcoinist.com/breaking-down-the-scalability-trilemma/" title="Breaking down the Blockchain 
Scalability Trilemma, Asolo,">19</a>]</p>
<p><strong>Decentralization</strong> : a core principle on which majority of the systems are build, taking into account censorship-resistance and ensuring that everyone, without prejudice, is permitted to partake in the decentralized system.</p>
<p><strong>Scalability</strong> : encompasses the ability of the network to process transactions. Thus, if a public block chain is deemed to be efficient, effective and usable, it should be designed to handle millions of users on the network.</p>
<p><strong>Security</strong> : refers to the immutability of the ledger and takes into account threats of 51% attacks, Sybil attacks and DDoS attacks etc.</p>
<p>Through the recent development of this ecosystem, most block chains have focused on two of the three factors, namely decentralization and security; at the expense of scalability. The primary reason for this is that nodes must reach consensus before transactions can be processed. [<a href="https://bitcoinist.com/breaking-down-the-scalability-trilemma/" title="Breaking down the Blockchain 
Scalability Trilemma, Asolo,">19</a>]</p>
<p>This report sees the examination of proposals considering Byzantine Fault Tolerant (BFT) consensus mechanisms and considers their feasibility and efficiency in meeting the characteristics of scalability, decentralization and security. In each instance the protocol assumptions, reference implementations and discernment on whether the protocol may be used for Tari as a means to maintain the distributed asset state will be assessed.</p>
<p>This report discusses several terms and concepts related to consensus mechanisms; these include definitions of <a href="./Appendix.html#consensus">Consensus</a>, <a href="./Appendix.html#binary-consensus">Binary Consensus</a>, <a href="./Appendix.html#byzantine-fault-tolerance">Byzantine Fault Tolerance</a>, <a href="./Appendix.html#practical-byzantine-fault-tolerant-variants">Practical Byzantine Fault Tolerant Variants</a>, <a href="./Appendix.html#deterministic-and-non-deterministic-protocols">Deterministic and Non-Deterministic Protocols</a> and <a href="./Appendix.html#scalability-performance-trade-off">Scalability-performance trade off</a>. An important characteristic of consensus mechanisms are degrees of synchrony which range from <a href="./Appendix.html#synchrony">Synchrony</a>, <a href="./Appendix.html#partial-synchrony">Partial Synchrony</a>, <a href="./Appendix.html#weak-synchrony">Weak Synchrony</a>, <a href="./Appendix.html#random-synchrony">Random Synchrony</a> and <a href="./Appendix.html#asynchrony">Asynchrony</a>, as well as <a href="./Appendix.html#the-problem-with-timing-assumptions">The Problem with Timing Assumptions</a>. Definitions on <a href="./Appendix.html#denial-of-service-attack">Denial of Service Attack</a>, <a href="./Appendix.html#the-flp-impossibility">The FLP Impossibility</a> and <a href="./Appendix.html#randomized-agreement">Randomized Agreement</a> are also provided.</p>
<a class="header" href="#a-brief-survey-of-byzantine-fault-tolerant-consensus-mechanisms" id="a-brief-survey-of-byzantine-fault-tolerant-consensus-mechanisms"><h2>A brief survey of Byzantine Fault Tolerant Consensus Mechanisms</h2></a>
<p>Many peer-to-peer online Real-time strategy games use a modified Lockstep protocol as a consensus protocol in order to manage game state between players in a game. Each game action results in a game state delta broadcast to all other  players in the game along with a hash of the total game state. Each player validates the change by applying the delta to their own game state and comparing the game state hashes. If the hashes do not agree then a vote is cast, and those players whose game state is in the minority are disconnected and removed from the game (known as a desync.) [<a href="https://en.wikipedia.org/wiki/Consensus_(computer_science)" title="Consensus Mechanisms, Wikipedia">21</a>]</p>
<a class="header" href="#permissioned-byzantine-fault-tolerant-protocols" id="permissioned-byzantine-fault-tolerant-protocols"><h1>Permissioned Byzantine Fault Tolerant Protocols</h1></a>
<ul>
<li><a href="#introduction">Introduction</a>
<ul>
<li><a href="#hyperledger-fabric-hlf">Hyperledger Fabric (HLF)</a></li>
<li><a href="#tendermint">Tendermint</a>
<ul>
<li><a href="#sentry-nodes">Sentry Nodes</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<a class="header" href="#introduction-3" id="introduction-3"><h2>Introduction</h2></a>
<p>Byzantine agreement schemes are considered well suited for permissioned block chains, where the identity of the participants is known. Examples include Hyperledger and Tendermint. Here the Federated Consensus Algorithm is implemented. [<a href="http://conferences.inf.ed.ac.uk/EuroDW2018/papers/eurodw18-Rusch.pdf" title="High-Performance Consensus Mechanisms for Blockchains,
Rusch">9</a>]</p>
<a class="header" href="#hyperledger-fabric-hlf" id="hyperledger-fabric-hlf"><h3>Hyperledger Fabric (HLF)</h3></a>
<p>HLF began as a project under the LinX Foundation in early 2016 [<a href="https://www.zurich.ibm.com/dccl/papers/cachin_dccl.pdf" title="Architecture of the Hyperledger 
Blockchain Fabric, Cachin">13</a>], with the aim of creating an open-source cross-industry standard platform for distributed ledgers. HLF is an implementation of a distributed ledger platform for running smart contracts, leveraging familiar and proven technologies, with a modular architecture allowing pluggable implementations of various functions. The distributed ledger protocol of the fabric is run on the peers. The fabric distinguishes peers as validating peers (they run the consensus algorithm, thus validating the transactions) and non-validating peers (they act as a proxy that helps in connecting clients to validating peers). The validating peers run a BFT consensus protocol for executing a replicated state machine that accepts deploy, invoke and query transactions as operations. [<a href="https://ieeexplore.ieee.org/document/8014672/" title="Survey of Consensus Protocols of Blockchain Applications,
4th International Conference on Advanced Computing 
and Communication Systems, Sankar et al.">11</a>]</p>
<p>The block chain's hash chain is computed based on the executed transactions and resulting persistent state. The replicated execution of chaincode (the transaction which involves accepting the code of the smart contract to be deployed) is used for validating the transactions. They assume that among <em>n</em> validating peers, at most <em>f&lt;n/3</em> (where <em>f</em> is the number of faulty nodes and <em>n</em> is the number of nodes present in the network) may behave arbitrarily, while others will execute correctly, thus adapting to concept BFT consensus. Since HLF proposes to follow PBFT, the chaincode transactions must be deterministic in nature, otherwise different peers might have different persistent state. The SIEVE protocol is used to filter out the non-deterministic transactions, thus assuring a unique persistent state among peers. [<a href="https://ieeexplore.ieee.org/document/8014672/" title="Survey of Consensus Protocols of Blockchain Applications,
4th International Conference on Advanced Computing 
and Communication Systems, Sankar et al.">11</a>]</p>
<p>While being redesigned for a v1.0 release, the format's goal was to achieve extensibility. This version allowed for modules such as membership and consensus mechanism to be exchanged. Being permissioned, this consensus mechanism is mainly responsible for receiving the transaction request from the clients and establishing a total execution order. So far, these pluggable consensus modules include a centralized, single order for testing purposes and a crash-tolerant ordering service based on Apache Kafka. [<a href="http://conferences.inf.ed.ac.uk/EuroDW2018/papers/eurodw18-Rusch.pdf" title="High-Performance Consensus Mechanisms for Blockchains,
Rusch">9</a>]</p>
<a class="header" href="#tendermint" id="tendermint"><h3>Tendermint</h3></a>
<p>Tendermint Core is a BFT Proof-of-Stake (PoS) protocol which is composed of two protocols in one: a consensus algorithm and a peer-to-peer networking protocol. Jae Kwon and Ethan Buchman, inspired by the design goal behind <a href="./Permissionless-Byzantine-Fault-Tolerant-Protocols(Part1).html#raft">Raft</a>, specified Tendermint as an easy to understand, developer-friendly algorithm while doing algorithmically complex systems engineering. [<a href="https://blog.cosmos.network/tendermint-explained-bringing-bft-based-pos-to-the-public-blockchain-domain-f22e274a0fdb" title="Tendermint Explained- Bringing BFT-based
PoS to the Public Blockchain Domain">34</a>]</p>
<p>Tendermint is modeled as a deterministic protocol, live under partial synchrony, which achieves throughput within the bounds of the latency of the network and individual processes themselves.</p>
<p>Tendermint rotates through the validator set, in a weighted round-robin fashion: where the higher the stake (i.e. voting power) that a validator possesses, the greater their weighting, the proportionally more times they will be elected as leaders. Thus, if one validator has the same amount of voting power as another validator, they will both be elected by the protocol an equal amount of times. [<a href="https://blog.cosmos.network/tendermint-explained-bringing-bft-based-pos-to-the-public-blockchain-domain-f22e274a0fdb" title="Tendermint Explained- Bringing BFT-based
PoS to the Public Blockchain Domain">34</a>]</p>
<p>Critics have argued that Tendermint is not decentralized, and one can distinguish and target leadership, launching a DDoS attack against them, sniffling the progression of the chain. Although Sentry Architecture (containing <a href="#sentry-nodes">Sentry Nodes</a>) has been implemented in Tendermint, the argument on the degree of decentralization is still questionable.</p>
<a class="header" href="#sentry-nodes" id="sentry-nodes"><h4>Sentry Nodes</h4></a>
<p>Sentry Nodes are guardians of a validator node and provide the validator nodes with access to the rest of the network. Sentry nodes are well connected to other full nodes on the network. Sentry nodes may be dynamic, but should maintain persistent connections to some evolving random subset of each other. They should always expect to have direct incoming connections from the validator node and its backup(s). They do not report the validator node's address in the Peer Exchange Reactor (PEX) and they may be more strict about the quality of peers they keep.</p>
<p>Sentry nodes belonging to validators that trust each other may wish to maintain persistent connections via Virtual Private Network (VPN) with one another, but only report each other sparingly in the PEX. [<a href="https://github.com/tendermint/tendermint/blob/master/docs/spec/p2p/node.md" title="Tendermint Peer Discovery
GitHub repository">44</a>]</p>
<a class="header" href="#permissionless-byzantine-fault-tolerant-protocols-part-1" id="permissionless-byzantine-fault-tolerant-protocols-part-1"><h1>Permissionless Byzantine Fault Tolerant Protocols (Part 1)</h1></a>
<ul>
<li><a href="#introduction">Introduction</a>
<ul>
<li><a href="#paxos">Paxos</a></li>
<li><a href="#chandra-toueg">Chandra Toueg</a></li>
<li><a href="#raft">Raft</a></li>
<li><a href="#hashgraph">HashGraph</a>
<ul>
<li><a href="#the-gossip-protocol">The Gossip Protocol</a></li>
<li><a href="#ancestors">Ancestors</a></li>
<li><a href="#seeing">Seeing</a></li>
<li><a href="#strongly-seeing">Strongly seeing</a></li>
<li><a href="#the-construct-of-gossiping">The Construct of Gossiping</a></li>
<li><a href="#internal-consensus">Internal consenus</a></li>
<li><a href="#criticisms">Criticisms</a></li>
</ul>
</li>
<li><a href="#sintra">SINTRA</a></li>
</ul>
</li>
</ul>
<a class="header" href="#introduction-4" id="introduction-4"><h2>Introduction</h2></a>
<p>BFT protocols face several limitations when utilized in permissionless block chains. They do not scale well with the number of participants, resulting in performance deterioration for the targeted network sizes. In addition, they are not well established in this setting, thus they are prone to security issues, e.g. Sybil attacks. Currently, there are approaches that attempt to circumvent or solve this problem. [<a href="http://conferences.inf.ed.ac.uk/EuroDW2018/papers/eurodw18-Rusch.pdf" title="High-Performance Consensus Mechanisms for Blockchains,
Rusch">9</a>]</p>
<a class="header" href="#paxos" id="paxos"><h3>Paxos</h3></a>
<p>The Paxos family of protocols includes a spectrum of trade-offs between the number of processors, number of message delays before learning the agreed value, the activity level of individual participants, number of messages sent,  and types of failures. Although the FLP theorem states that there is no deterministic fault-tolerant consensus protocol that can guarantee progress in an asynchronous network, Paxos guarantees safety (consistency), and the conditions that could prevent it from making progress are difficult to provoke [<a href="https://en.wikipedia.org/wiki/Paxos_(computer_science)" title="Paxos, Wikipedia">29</a>].</p>
<p>Paxos achieves consensus as long as there are <em>f</em> failures, where <em>f &lt; (n-1)/2</em>. These failures cannot be Byzantine (otherwise the BFT proof would be violated). Thus it is assumed that messages are never corrupted, and that nodes do not collude to subvert the system.</p>
<p>Paxos proceeds through a set of negotiation rounds, with one node having 'Leadership' status. Progress will stall if the leader becomes unreliable, until a new leader is elected, or if suddenly an old leader comes back online and a dispute between two leader nodes arises.</p>
<a class="header" href="#chandra-toueg" id="chandra-toueg"><h3>Chandra-Toueg</h3></a>
<p>The Chandra–Toueg consensus algorithm was published by Tushar Deepak Chandra and Sam Toueg in 1996. It relies on a special node that acts as a failure detector. In essence, it pings other nodes to make sure they're still responsive.</p>
<p>This implies that the detector stays online and that the detector must continuously be made aware when new nodes join the network.</p>
<p>The algorithm itself is similar to the Paxos algorithm, which also relies on failure detectors and as such requires <em>f&lt;n/2</em>, where n is the total number of processes. [<a href="https://en.wikipedia.org/wiki/Chandra%E2%80%93Toueg_consensus_algorithm" title="Chandra-Toueg Consensus Algorithm, Wikipedia">27</a>]</p>
<a class="header" href="#raft" id="raft"><h3>Raft</h3></a>
<p>Raft is a consensus algorithm designed as an alternative to Paxos. It was meant to be more understandable than Paxos by means of separation of logic, but it is also formally proven safe and offers some additional features [<a href="https://en.wikipedia.org/wiki/Raft_(computer_science)" title="Raft, Wikipedia">28</a>].</p>
<p>Raft achieves consensus via an elected leader. Each follower has a timeout in which it expects the heartbeat from the leader. It is thus a synchronous protocol. If the leader fails, an election is held to find a new leader. This entails nodes nominating themselves on a first-come, first-served basis. Hung votes require the election to be scrapped and restarted. This suggests that a high degree of cooperation is required by nodes and that malicious nodes could easily collude to  disrupt a leader and then prevent a new leader from being elected. Raft is a simple algorithm but is clearly unsuitable for consensus in cryptocurrency applications.</p>
<p>While Paxos and Raft and many other well-known protocols tolerate crash faults, Byzantine fault tolerant protocols beginning with PBFT, tolerate even arbitrary corrupted nodes. Many subsequent protocols offer improved performance, often through optimistic execution that provides excellent performance when there are no faults, clients do not contend much, and the network is well behaved, and at least some progress otherwise.</p>
<p>In general, BFT systems are evaluated in deployment scenarios where latency and CPU are the bottleneck, thus the most effective protocols reduce the number of rounds and minimize expensive cryptographic operations.</p>
<p>Clement et al. [<a href="https://www.usenix.org/legacy/event/nsdi09/tech/full_papers/clement/clement.pdf" title="Making Byzantine fault Tolerant Systems Tolerate Byzantine Faults , 
Clement et al.">40</a>] initiated a recent line of work by advocating improvement of the worst-case performance, providing service quality guarantees even when the system is under attack, even if this comes at the expense of performance in the optimistic case. However, although the &quot;Robust BFT protocols in this vein gracefully tolerate comprised nodes, they still rely on timing assumptions about the underlying network&quot;.  Thus focus shifted to asynchronous networks. [<a href="https://eprint.iacr.org/2016/199.pdf" title="The Honey Badger of BFT Protocols WhitePaper,
Miller  et al.">6</a>]</p>
<a class="header" href="#hashgraph" id="hashgraph"><h3>HashGraph</h3></a>
<p>The Hashgraph consensus algorithm [<a href="https://www.swirlds.com/downloads/SWIRLDS-TR-2016-01.pdf" title="Hashgraph WhitePaper, Baird">30</a>], was released in 2016.  It claims Byzantine fault tolerance under complete <strong>asynchrony</strong> assumptions, no leaders, no round robin, no proof-of-work, eventual consensus with probability one, and high speed in the absence of faults.</p>
<p>It is based on the gossip protocol, which is a fairly efficient distribution strategy that entails nodes randomly sharing information with each other, similar to how human beings gossip with each other.</p>
<p>Nodes jointly build a hash graph reflecting all of the gossip events. This allows Byzantine agreement to be achieved through virtual voting. Alice does not send Bob a vote over the Internet. Instead, Bob calculates what vote Alice would have sent, based on his knowledge of what Alice knows.</p>
<p>HashGraph uses digital signatures to prevent undetectable changes to transmitted messages.</p>
<p>HashGraph does not violate the FLP theorem, since it is <em>non-deterministic</em>.</p>
<p>The Hash graph has some similarities to a block chain. To quote the white paper: &quot;The HashGraph consensus algorithm is equivalent to a block chain in which the 'chain' is constantly branching, without any pruning, where no blocks are ever stale, and where each miner is allowed to mine many new blocks per second, without proof-of-work&quot; [<a href="https://www.swirlds.com/downloads/SWIRLDS-TR-2016-01.pdf" title="Hashgraph WhitePaper, Baird">30</a>].</p>
<p>Because each node keeps track of the hash graph, there is no need to have voting rounds in HashGraph; each node already knows what all of its peers will vote for and thus consensus is reached purely by analyzing the graph.</p>
<a class="header" href="#the-gossip-protocol" id="the-gossip-protocol"><h4>The Gossip Protocol</h4></a>
<p>The gossip protocol works like this:</p>
<ul>
<li>
<p>Alice selects a random peer node, say Bob, and sends him <em>everything she knows</em>. She then selects another random node and repeats the process indefinitely.</p>
</li>
<li>
<p>Bob, on receiving Alice's information, marks this as a gossip event and fills in any gaps in his knowledge from Alice's information. Once done, he continues gossiping with his updated information.</p>
</li>
</ul>
<p>The basic idea behind the Gossip Protocol is the following: A node wants to share some information to the other nodes in the network. Then periodically it randomly selects a node from the set of nodes and exchanges the information. The node that receives the information performs the randomly selects a node from the set of nodes and exchanges the information, and so on. The information is periodically sent to <em>N</em> targets, where <em>N</em> is the fanout. [<a href="https://managementfromscratch.wordpress.com/2016/04/01/introduction-to-gossip/" title="Introduction to Gossip">45</a>]</p>
<p>The <em>cycle</em> is the number of rounds to spread the information. The <em>fanout</em> is the number of nodes a node gossips with in each cycle.</p>
<p>With a fanout=1, $O(LogN)$ cycles are necessary for the update to reach all the nodes.</p>
<p>In this way, information spreads throughout the network in an exponential fashion. [<a href="https://www.swirlds.com/downloads/SWIRLDS-TR-2016-01.pdf" title="Hashgraph WhitePaper, Baird">30</a>]</p>
<p align="center"><img src="../assets/gossip.png" width="400" /></p>
<p align="center"><b>Figure 1: Gossip Protocol Directed Graph</b></p>
<p>The gossip history can be represented as a directed graph, as in Figure 1.</p>
<p>HashGraph introduces a few important concepts that are used repeatedly in later BFT consensus algorithms: famous witnesses, and strongly seeing.</p>
<a class="header" href="#ancestors" id="ancestors"><h4>Ancestors</h4></a>
<p>If an event (<em>x1</em>) comes before another event (<em>x2</em>), and they are connected by a line; the older event is an <em>ancestor</em> of that event.</p>
<p>If both events were created by the <em>same node</em>, then <em>x1</em> is a <em>self-ancestor</em> of <em>x2</em>.</p>
<p><strong>Note</strong>: The gossip protocol defines an event as being a (self-)ancestor of itself!</p>
<a class="header" href="#seeing" id="seeing"><h4>Seeing</h4></a>
<p>If an event <em>x1</em> is an ancestor of <em>x2</em>, then we say that <em>x1</em> <strong>sees</strong> <em>x2</em> as long as the node is not aware of any forks from <em>x2</em>.</p>
<p>So in the absence of forks, all events will <em>see</em> all of their ancestors.</p>
<pre><code class="language-text">     +-----&gt; y
     |
x +--+
     |
     +-----&gt; z
</code></pre>
<p>In the example above, <em>x</em> is an ancestor to both y and z. However, because there is no ancestor relationship between <em>y</em> and <em>z</em>, the <em>seeing</em> condition fails, and so <em>y</em> cannot see <em>x</em>, and <em>z</em> cannot see <em>x</em>.</p>
<p>It may be the case that it takes time before nodes in the protocol detect the fork. For instance Bob may create <em>z</em> and <em>y</em>; but share <em>z</em> with Alice and <em>y</em> with Charlie. Both Alice and Charlie will eventually learn about the deception, but until that point, Alice will believe that <em>y</em> sees <em>x</em>, and Charlie will believe that <em>z</em> sees <em>x</em>.</p>
<p>This is where the concept of <em>strongly seeing</em> comes in.</p>
<a class="header" href="#strongly-seeing" id="strongly-seeing"><h4>Strongly seeing</h4></a>
<p>If a node examines its hash graph and notices that an event <em>z</em> <em>sees</em> an event <em>x</em>, and not only that, but it can draw an ancestor relationship (usually via multiple routes) through a super-majority of peer nodes, and that a different event from each node also sees <em>x</em>; then it is said that according to this node, that <em>z</em> <em>strongly sees</em> <em>x</em>.</p>
<p>The following example comes from [<a href="https://www.swirlds.com/downloads/SWIRLDS-TR-2016-01.pdf" title="Hashgraph WhitePaper, Baird">30</a>]:</p>
<p align="center"><img src="../assets/strongly-seeing.png" width="600" /></p>
<p align="center"><b>Figure 2: Illustration of Strongly-Seeing </b></p>
<a class="header" href="#the-construct-of-gossiping" id="the-construct-of-gossiping"><h4>The Construct of Gossiping</h4></a>
<p>The main consensus algorithm loop consists of every node (Alice), selecting a random peer node (Bob) and sharing their graph history. Now Alice and Bob have the same graph history.</p>
<p>Alice and Bob both create a new event with the new knowledge they have just learnt from their peer.</p>
<p>Alice repeats this process continuously.</p>
<a class="header" href="#internal-consensus" id="internal-consensus"><h4>Internal consensus</h4></a>
<p>After a sync, a node will determine the order for as many events as possible, using three procedures.
The algorithm uses constant <em>n</em> (the number of nodes) and a small constant value <em>c</em>&gt;2.</p>
<pre><code class="language-text">in parallel:
    loop
      sync all known events to a random member
    end loop

    loop
      receive a sync
      create a new event
      call divideRounds
      call decideFame
      call findOrder
    end loop
</code></pre>
<p>Here we have the Swirlds HashGraph consensus algorithm. Each member runs this in parallel. Each sync brings in new events, which are then added to the hash graph. All known events are then divided into rounds. Then the first events in each round are decided as being famous or not (through purely local Byzantine agreement with virtual voting). Then the total order is found on those events for which enough information is available. If two members independently assign a position in history to an event, they are guaranteed to assign the same position, and guaranteed to never change it, even as more information comes in. Furthermore, each event is eventually assigned such a position, with probability one. [<a href="https://www.swirlds.com/downloads/SWIRLDS-TR-2016-01.pdf" title="Hashgraph WhitePaper, Baird">30</a>]</p>
<pre><code class="language-proceduredivideRounds">   for each event x
     r ← max round of parents of x ( or 1 if none exist )
     if x can strongly see more than 2/3*n round r witnesses
       x.round ← r + 1
     else
       x.round ← r
     x.witness ← ( x has no self parent ) || ( x.round &gt; x.selfParent.round )
</code></pre>
<p>The above is deemed the divideRounds procedure. As soon as an event x is known, it is assigned a round number x.round, and the boolean value x.witness is calculated, indicating whether it is the first event that a member created in that round. [<a href="https://www.swirlds.com/downloads/SWIRLDS-TR-2016-01.pdf" title="Hashgraph WhitePaper, Baird">30</a>]
​</p>
<pre><code class="language-proceduredecideFame">   for each event x in order from earlier rounds to later
     x.famous ← UNDECIDED
     for each event y in order from earlier rounds to later
       if x.witness and y.witness and y.round &gt; x.round
         d ← y.round - x.round
         s ← the set of witness events in round y.round-1 that y can strongly see
         v ← majority vote in s ( is TRUE for a tie )
         t ← number of events in s with a vote of v
         if d = 1 // first round of the election
           y.vote ← can y see x ?
         else if d mod c &gt; 0 // this is a normal round
             if t &gt; 2* n /3 // if supermajority, then decide
               x.famous ← v
               y.vote ← v
               break // y loop
             else // else, just vote
               y.vote ← v
         else if t &gt; 2* n /3 // this is a coin round
           y.vote ← v
         else // else flip a coin
           y.vote ← middle bit of y.signature
</code></pre>
<p>This is the decideFame procedure. For each witness event (i.e., an event x where x.witness is true), decide whether it is famous (i.e., assign a boolean to x.famous). This decision is done by a Byzantine agreement protocol based on virtual voting. Each member runs it locally, on their own copy of the hashgraph, with no additional communication. It treats the events in the hashgraph as if they were sending votes to each other, though the calculation is purely local to a member’s computer. The member assigns votes to the witnesses of each round, for several rounds, until more than 2/3 of the population agrees. [<a href="https://www.swirlds.com/downloads/SWIRLDS-TR-2016-01.pdf" title="Hashgraph WhitePaper, Baird">30</a>]</p>
<a class="header" href="#criticisms" id="criticisms"><h4>Criticisms</h4></a>
<p>An attempt to address some of these criticisms has been presented. [<a href="http://www.swirlds.com/downloads/Swirlds-and-Sybil-Attacks.pdf" title="Swirlds and Sybil Attacks, Baird">31</a>],</p>
<ul>
<li>The HashGraph protocol is patented and is not open source.</li>
<li>In addition, the HashGraph white paper assumes that <em>n</em>, the number of nodes in the network, is constant. In practice, <em>n</em> can increase, but performance likely degrades badly as <em>n</em> becomes large. [<a href="https://hackernoon.com/demystifying-hashgraph-benefits-and-challenges-d605e5c0cee5" title="Demystifying HashGraph">32</a>]</li>
<li>HashGraph is not as &quot;fair&quot; as claimed in their paper, with at least one attack being proposed. [<a href="https://medium.com/opentoken/hashgraph-a-whitepaper-review-f7dfe2b24647" title="HashGraph: A WhitePaper Review">33</a>]</li>
</ul>
<a class="header" href="#sintra" id="sintra"><h3>SINTRA</h3></a>
<p>SINTRA is a Secure Intrusion-Tolerant Replication Architecture used for the coordination in asynchronous networks subject to Byzantine faults. It consists of a collection of protocols and are implemented in Java, providing secure replication and coordination among a group of servers connected by a wide-area network, such as the Internet. For a group consisting of <em>n</em> servers, it tolerates up to $t&lt;n/3$ servers failing in arbitrary, malicious ways, which is optimal for the given model. The servers are connected only by asynchronous point-to-point communication links. Thus, SINTRA automatically tolerates timing failures as well as attacks that exploit timing. The SINTRA group model is static, which means that failed servers must be recovered by mechanisms outside of SINTRA, and the group must be initialized by a trusted process.</p>
<p>The protocols exploit randomization, which is needed to solve Byzantine agreement in such asynchronous distributed systems. Randomization is provided by a threshold-cryptographic pseudorandom generator, a coin-tossing protocol based on the Diffie-Hellman problem. Threshold cryptography is a fundamental concept in SINTRA as it allows the group to perform a common cryptographic operation for which the secret key is shared among the servers in such a way that no single server or small coalition of corrupted servers can obtain useful information about it. SINTRA provides threshold-cryptographic schemes for digital signatures, public-key encryption, and unpredictable pseudo-random number generation (coin-tossing). It contains broadcast primitives for reliable and consistent broadcasts, which provide agreement on individual messages sent by distinguished senders. However, these primitives cannot guarantee a total order for a stream of multiple messages delivered by the system, which is needed to build fault-tolerant services using the state machine replication paradigm. This is the problem of atomic broadcast and requires more expensive protocols based on Byzantine agreement. SINTRA provides multiple randomized Byzantine agreement protocols, for binary and multi-valued agreement, and implements an atomic broadcast channel on top of agreement. An atomic broadcast that also maintains a causal order in the presence of Byzantine faults is provided by the secure causal atomic broadcast channel. [<a href="https://cachin.com/cc/papers/sintra.pdf" title="Secure Intrusion-tolerant Replication 
on the Internet, Cachin et al.">51</a>]</p>
<p>SINTRA is designed in a modular way as shown in Figure 3. Modularity greatly simplifies the construction
and analysis of the complex protocols needed to tolerate Byzantine faults.</p>
<p align="center"><img src="../assets/design-of-sintra.png" width="300" /></p>
<p align="center"><b>Figure 3: The Design of SINTRA </b></p>
<a class="header" href="#permissionless-byzantine-fault-tolerant-protocols-part-2" id="permissionless-byzantine-fault-tolerant-protocols-part-2"><h1>Permissionless Byzantine Fault Tolerant Protocols (Part 2)</h1></a>
<ul>
<li><a href="#honeybadgerbft">HoneyBadgerBFT</a></li>
<li><a href="#stellar-consensus-protocol">Stellar Consensus Protocol</a></li>
<li><a href="#linbft">LinBFT</a></li>
<li><a href="#algorand">Algorand</a></li>
<li><a href="#thunderella">Thunderella</a></li>
<li><a href="#snowflake-to-avalanche">Snowflake to Avalanche</a></li>
<li><a href="#parsec">PARSEC</a></li>
<li><a href="#democratic-bft">Democratic BFT</a></li>
</ul>
<a class="header" href="#honeybadgerbft" id="honeybadgerbft"><h2>HoneyBadgerBFT</h2></a>
<p>HoneyBadgerBFT was released in November 2016 and is seen as the first practical <strong>asynchronous</strong> BFT consensus algorithm. Designed with cryptocurrencies in mind, where bandwidth is considered scarce, but an abundance of CPU power is available. Thus, the protocol implements public-private key encryption to increase the efficiency of the establishment of consensus. The protocol works with a fixed set of servers to run the consensus; however, this leads to centralization and allows an attacker to specifically target these servers. [<a href="http://conferences.inf.ed.ac.uk/EuroDW2018/papers/eurodw18-Rusch.pdf" title="High-Performance Consensus Mechanisms for Blockchains,
Rusch">9</a>]</p>
<p>In its threshold encryption scheme, any one party can encrypt a message using a master public key, and it requires f+1 correct nodes to compute and reveal decryption shares for a ciphertext before the plaintext can be recovered.</p>
<p>The work of HoneyBadgerBFT is closely related to <a href="./Permissionless-Byzantine-Fault-Tolerant-Protocols(Part1).html#sintra">SINTRA</a> , which as mentioned before, is a system implementation based on the asynchronous atomic broadcast protocol from Cachin et al. [<a href="https://www.shoup.net/papers/ckps.pdf" title="Secure and Efficent Asynchronous Broadcast Protocols, 
Cachin et al.">41</a>] This protocol consists of a reduction from Atomic Broadcast Channel (ABC) to Asynchronous Common Subset (ACS), as well as a reduction from ACS to Multi-Value Validated Agreement (MVBA)</p>
<p>HoneyBadger offers a novel reductions from ABC to ACS that provides better efficiency (by O(N) factor) through batching, while using threshold encryption to preserve censorship resilience. Better efficiency is also obtained by cherry-picking improved instantiations of sub-components. For example, the expensive MVBA is circumvented by using an alternative ACS along with an effect reliable broadcast (RBC). [<a href="https://eprint.iacr.org/2016/199.pdf" title="The Honey Badger of BFT Protocols WhitePaper,
Miller  et al.">6</a>]</p>
<a class="header" href="#stellar-consensus-protocol" id="stellar-consensus-protocol"><h2>Stellar Consensus Protocol</h2></a>
<p>Stellar Consensus Protocol (SCP) is an <strong>asynchronous</strong> protocol proposed by David Mazieres. It considered to be a global consensus protocol consisting of nomination protocol and ballot protocol, and is said to be BFT by bringing with it the concept of quorum slices and defeated byzantine fault tolerance. [<a href="https://ieeexplore.ieee.org/document/8014672/" title="Survey of Consensus Protocols of Blockchain Applications,
4th International Conference on Advanced Computing 
and Communication Systems, Sankar et al.">11</a>]</p>
<p>Each participant forms a quorum of other users, thus creating a trust hierarchy, which requires complex trust decisions. [<a href="http://conferences.inf.ed.ac.uk/EuroDW2018/papers/eurodw18-Rusch.pdf" title="High-Performance Consensus Mechanisms for Blockchains,
Rusch">9</a>]</p>
<p>Initially the nomination proctor is run. During this, new values called candidate values are proposed for agreement. Each node receiving these values will vote for a single value among these. Eventually it results in unanimously selected values for that slot.</p>
<p>After successful execution of nomination protocol, the nodes deploy the ballot protocol. This involves the federated voting to either commit or abort the values resulting from nomination protocol. This results in externalizing the ballot for the current slot. The aborted ballots are now declared irrelevant. However, there can be stuck states where nodes cannot reach a conclusion, whether to abort or commit a value. This situation is avoided by moving it to a higher valued ballot, considering it in a new ballot protocol execution. This aids in case a node believes that this stuck ballot was committed. Thus SCP assures avoidance and management of stuck states and thus provides liveliness.</p>
<p>The concept of quorum slices in case of SCP provides asymptotic security and flexible trust, making it more acceptable than other earlier consensus algorithms utilizing Federated BFT, like the Ripple consensus protocol. [<a href="https://ripple.com/files/ripple_consensus_whitepaper.pdf" title="The Ripple Protocol Consensus 
Algorithm, Schwartz et al.">14</a>] Here, the user is provided more independence in deciding whom to trust. [<a href="https://tendermint.com/static/docs/tendermint.pdf" title="Tendermint: Consensus without Mining, Kwon">15</a>]</p>
<p>SCP protocol claims to be free of blocked states, provides decentralized control, asymptotic security, flexible trust and low latency. But it does not guarantee safety all the time. If the user node chooses an inefficient quorum slice security is not guaranteed. In the event of partition or misbehaving nodes, it halts progress of the network until consensus can be reached.</p>
<a class="header" href="#linbft" id="linbft"><h2>LinBFT</h2></a>
<p>LinBFT is a Byzantine fault tolerance protocol for block chain systems that allows for the amortized communication volume per block <em>O(n)</em> under reasonable conditions (where <em>n</em> is the number of participants) while satisfying deterministic guarantees on safety and liveness. It satisfies liveness in a <strong>partially synchronous</strong> network.</p>
<p>LinBFT cuts down its <em>O(n</em><sup>4</sup><em>)</em> complexity by implementing changes each by  <em>O(n)</em>: linear view change, threshold signatures and verifiable random functions.</p>
<p>This is clearly optimal, in the sense that disseminating a block already takes <em>O(n)</em> transmissions.</p>
<p>LinBFT is designed to be implemented for permission-less, public block chain systems and takes into account anonymous participants without a public-key infrastructure, PoS, rotating leader and a dynamic participant set. [<a href="https://arxiv.org/pdf/1807.01829.pdf" title="LinBFT: Linear-Communication Byzantine 
Fault Tolerance for Public Blockchains, Yang">16</a>]</p>
<p>For instance, participants can be anonymous, without a centralized public key infrastructure (PKI) public key among themselves, and participate in a distributed key generation (DKG) protocol required to create threshold signatures, both of which are communication-heavy processes.</p>
<p>LinBFT is compatible with proof-of-state, which counters Sybil attacks and deters dishonest behavior through slashing. [<a href="https://arxiv.org/pdf/1807.01829.pdf" title="LinBFT: Linear-Communication Byzantine 
Fault Tolerance for Public Blockchains, Yang">16</a>]</p>
<a class="header" href="#algorand" id="algorand"><h2>Algorand</h2></a>
<p>The Algorand WhitePaper was released in May 2017, and is a <strong>synchronous</strong> BFT consensus mechanism; where the blocks get added at a minimum rate. [<a href="https://arxiv.org/pdf/1607.01341.pdf" title="Algorand WhitePaper 
Chen and Micali">25</a>]</p>
<p>Algorand allows participants to privately check whether they are chosen for consensus participation and requires only one message per user, thus limiting possible attacks. [<a href="http://conferences.inf.ed.ac.uk/EuroDW2018/papers/eurodw18-Rusch.pdf" title="High-Performance Consensus Mechanisms for Blockchains,
Rusch">9</a>]</p>
<p>Alogrand, scales up to 500 000 users by employing Verifiable Random Functions, which are pseudo-random functions able to provide verifiable proofs that the output of said function is correct. [<a href="http://conferences.inf.ed.ac.uk/EuroDW2018/papers/eurodw18-Rusch.pdf" title="High-Performance Consensus Mechanisms for Blockchains,
Rusch">9</a>]</p>
<p>It introduces the concept of a <em>concrete coin</em>. Most of these BFT algorithms require some sort of randomness oracle, but all nodes need to see the same value if the oracle is consulted. This had previously been achieved through a <em>common coin</em> idea; the <em>concrete coin</em> uses a much simpler approach; but only returns a binary value. [<a href="https://arxiv.org/pdf/1607.01341.pdf" title="Algorand WhitePaper 
Chen and Micali">25</a>]</p>
<a class="header" href="#thunderella" id="thunderella"><h2>Thunderella</h2></a>
<p>Thunderella, implements an asynchronous strategy, where a <strong>synchronous</strong> strategy is used as a fall back in the event of a malfunction [<a href="https://eprint.iacr.org/2017/913.pdf" title="Thunderella WhitePaper, Pass and Shi">26</a>], thus it achieves both robustness and speed.</p>
<p>It can be applied in permissionless networks using proof-of-work. Network robustness and &quot;instant confirmations&quot; requires both 75% of the network to be honest, as well as the presence of a leader node.</p>
<a class="header" href="#snowflake-to-avalanche" id="snowflake-to-avalanche"><h2>Snowflake to Avalanche</h2></a>
<p>This consensus protocol was first seen in the WhitePaper entitled &quot;Snowflake to Avalanche&quot;. Outlined in the paper are four protocols which are building blocks forming a protocol family. These leaderless Byzantine fault tolerance protocols are build on a metastable mechanism and are referred to as: Slush; Snowflake; Snowball and Avalanche.</p>
<p>The protocols published by Team Rocket differ from the traditional consensus protocols and the Nakamoto consensus protocols by not requiring an elected leader, but instead the protocol simply guides all the nodes to consensus.</p>
<p>These four protocols are described as a new family of protocols due to this concept of metastability: a means to establish consensus by guiding all nodes towards an emerging consensus without requiring leaders, while still maintaining the same level of security and inducing a speed that exceeding current protocols.</p>
<p>This is achieved through the formation of 'sub-quorums', which are small randomized samples from nodes on the network. This allows for greater throughputs and sees parallel consensuses running before they merge to form the overarching consensus: what can be seen as similar in nature to the gossip protocol.</p>
<p>With regards to safety, throughput (the number of transactions per second) and scalability (the number of people supported by the network) Slush, Snowflake, Snowball and Avalanche seem to be able to achieve all three. They impart a probabilistic safety guarantee in the presence of Byzantine adversaries and achieve a high throughput and scalability due to their concurrent nature. A <strong>synchronous</strong> network is assumed.</p>
<p>This is the current problem facing the design of BFT protocols, in that a system can be very fast when a small number of nodes are active, since there are less decisions to make, however, when there are many users and an increase in transactions, the system cannot be maintained.</p>
<p>Unlike the PoW implementation, which requires constant active participation from the miners, Avalanche can function with the even when nodes are dormant.</p>
<p>While traditional consensus protocols require <em>O</em>(n<sup>2</sup>) communication, their communication complexity ranges from <em>O(kn log n)</em> to <em>O(kn)</em> for some security parameter <em>k&lt;&lt;n</em>. In a sense, Team Rocket highlight that the communication complexity of their protocols is less intensive than that of <em>O</em>(n<sup>2</sup>) communications, thus making these protocols faster and more scalable.</p>
<p>To backtrack a bit, Big <em>O</em> notation is used in Computer Science to describe the performance or complexity of an algorithm. It describes the worst-case scenario and can be used to describe the execution time required by an algorithm [<a href="https://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/" title="A beginner's guide to Big O notation">49</a>]. In the case of consensus algorithms, <em>O</em> describes a finite expected number of steps or operations [<a href="http://www.cs.yale.edu/homes/aspnes/papers/jalg90.pdf" title="Fast Randomized Consensus using Shared Memory,
Aspnes et al.">50</a>]. For example, <em>O</em>(1) describes an algorithm that will always execute in the same time regardless of the size of the input data set. <em>O</em>(n)_ describes an algorithm whose performance will grow linearly and in direct proportion to the size of the input data set.<em>O</em>(n<sup>2</sup>)represents an algorithm whose performance is directly proportional to the square of the size of the input data set.</p>
<p>The reason for this is <em>O(n<sup>2</sup>)</em> suggests that the rate of growth of function is determined by <em>n<sup>2</sup></em> where <em>n</em> is the number of people on the network. Thus, the addition of a person exponentially increases the time taken to disseminate the information on the network while traditional consensus protocols require everyone to communicate with one another- making it a laborious process. [<a href="https://flatoutcrypto.com/home/avalancheprotocol" title="Protocol Spotlight: Avalanche Part 1">18</a>]</p>
<p>Despite assuming a synchronous network, which is susceptible to the DoS attacks, this new family of protocols &quot;reaches a level of security that is simply good enough while surging forward with other advancements&quot;. [<a href="https://flatoutcrypto.com/home/avalancheprotocol" title="Protocol Spotlight: Avalanche Part 1">18</a>]</p>
<a class="header" href="#parsec" id="parsec"><h2>PARSEC</h2></a>
<p>PARSEC is a byzantine fault tolerant consensus algorithm possessing <strong>weak synchrony</strong> assumptions (highly asynchronous, assuming random delays with finite expected value)</p>
<p>Similar to HashGraph, it has no leaders, no round robin, no proof of work and reaches eventual consensus with probability one. It differs from HashGraph, in that it provides high speed in the absence and presence of faults.  Thus, it avoids the structures of delegated PoS (DPoS), which requires a trusted set of leaders, and does not have a round robin (where a permissioned set of miners sign each block)</p>
<p>It is fully open, unlike HashGraph, which is patented and closed sourced. The reference implementation of PARSEC, written in Rust, was released a few weeks after the whitepaper. ([<a href="http://docs.maidsafe.net/Whitepapers/pdf/PARSEC.pdf" title="Protocol for Asynchronous, Reliable, 
Secure and Efficient Consensus (PARSEC) 
WhitePaper, Chevalier et al.">1</a>], [<a href="https://github.com/maidsafe/parsec" title="GitHub repository: Protocol for Asynchronous,
Reliable, Secure and Efficient Consensus">37</a>])</p>
<p>The general problem of reaching Byzantine agreement on any value is reduced to the simple problem of reaching binary Byzantine agreement on the nodes participating in each decision. This has allowed for PARSEC to reuse the binary Byzantine agreement protocol (Signature-Free Asynchronous Byzantine Consensus) after adapting it to the gossip protocol. [<a href="https://medium.com/@flatoutcrypto/project-spotlight-maidsafe-and-parsec-part-1-4830cec8d9e3" title="Project Spotlight: Maidsafe and PARSEC Part 1">5</a>]</p>
<p>Similar to Honeybadger BFT, this protocol is composed through the additions of interesting ideas presented in literature.</p>
<p>Like HashGraph and Avalanche, a gossip protocol is used to allow efficient communication between nodes. [<a href="http://docs.maidsafe.net/Whitepapers/pdf/PARSEC.pdf" title="Protocol for Asynchronous, Reliable, 
Secure and Efficient Consensus (PARSEC) 
WhitePaper, Chevalier et al.">1</a>]</p>
<p>Finally, the need for a trusted leader or a trusted setup phase implied in Mostefaoui et al. [<a href="https://hal.inria.fr/hal-00944019v2/document" title="Signature-Free Asynchronous Byzantine Consensus 
with t&lt;n/3 and O(n2) Messages,
Mostefaoui et al.">2</a>] is removed by porting the key ideas to an asynchronous setting [<a href="https://people.csail.mit.edu/silvio/Selected%20Scientific%20Papers/Distributed%20Computation/BYZANTYNE%20AGREEMENT%20MADE%20TRIVIAL.pdf" title="Byzantine Agreement Made Trivial
Micali">3</a>].</p>
<p>The network is set to <em>N of N</em> instances of the algorithm communicating via randomly synchronous connections.</p>
<p>Due to random synchrony, all users can reach an agreement on what is going on, there is no guarantee for nodes on the timing that they should be receiving messages and a possibility of up to <em>t</em> Byzantine (arbitrary) failures are allowed, were <em>3t</em>&lt;N. The instances where no failures have occurred are deemed correct or honest, while the failed instances are termed faulty or malicious. Since a Byzantine failure model allows for malicious behavior, any set of instances containing more than 2/3N of them are referred to as the supermajority.</p>
<p>When a node receives a gossip request, it creates a new event and sends a response back (in HashGraph, the response was optional). Each gossip event contains [<a href="https://flatoutcrypto.com/home/maidsafeparsecexplanationpt2" title="Project Spotlight: Maidsafe and PARSEC Part 2">35</a>]:</p>
<ol>
<li>The data being transmitted</li>
<li>The self-parent (the hash of another gossip event created by the same node)</li>
<li>The other-parent (a hash of another gossip event created by a different node)</li>
<li>The <em>Cause</em> for creation which can either be a Request for information, a Response to another node’s request, or an
<em>Observation</em>. An observation is when a node creates a gossip event to record an observation that the node made themselves.</li>
<li>Creator ID (public key)</li>
<li>Signature – signing the above information.</li>
</ol>
<p>The self-parent and other-parent prevents tampering because they are signed and related to other gossip events [<a href="https://flatoutcrypto.com/home/maidsafeparsecexplanationpt2" title="Project Spotlight: Maidsafe and PARSEC Part 2">35</a>].</p>
<p>As with HashGraph, it is difficult for adversaries to interfere with the consensus algorithm because all voting is <em>virtual</em> and done without sharing details of votes cast; each node figures out what other nodes would have voted based on their
copy of the gossip graph.</p>
<p>PARSEC also uses the concept of a <em>concrete coin</em>, from Algorand that is used to break ties; particularly in cases where an adversary is carefully managing communication between nodes in order to maintain a deadlock on votes.</p>
<p>First nodes try and converge on a 'true' result for a set of results. If this is not achieved, they move onto step 2, which is trying to converge on a 'false' result. If consensus still cannot be reached, a coin flip is made and we go back to step 1
in another voting round.</p>
<a class="header" href="#democratic-bft" id="democratic-bft"><h2>Democratic BFT</h2></a>
<p>This is a deterministic Byzantine consensus algorithm that relies on a new weak coordinator. This protocol is implemented in the Red Belly Block chain and is said to achieve 30 000 transactions/second on Amazon Cloud Trials [<a href="https://www.ccn.com/tag/red-belly-blockchain/" title="Red Belly Blockchain">36</a>], Through the coupling with an optimized variant of the reduction of multivalve to binary consensus from Ben-Or et al., the Democratic BFT (DBFT) consensus algorithm was generated which terminates in 4 message delays in the good case, when all non-faulty processes propose the same value. [<a href="http://gramoli.redbellyblockchain.io/web/doc/pubs/DBFT-preprint.pdf" title="DBFT: Efficient Byzantine Consensus 
with a Weak Coordinator and its Application 
to Consortium Blockchains, Crain et al.">17</a>]</p>
<p>The term weak coordinator is used to describe the ability of the algorithm to terminate in the presence of a faulty or slow coordinator unlike previous algorithms that do not have the ability to terminate. The fundamental idea here is to allow processes to complete asynchronous rounds as soon as they receive a threshold of messages, instead of having to wait for a message from a coordinator that may be slow.</p>
<p>The resulting algorithm assumes partial synchrony, is resilience optimal, time optimal and does not require signatures.</p>
<p>Moving away from the impossibility of solving consensus in asynchronous message systems, where processes can be faulty or <em>Byzantine</em>, the technique of randomization or additional synchrony is adopted.</p>
<p>Randomized algorithms can use per-process &quot;local&quot; coins or a shared <em>common coin</em> to solve consensus probabilistically among <em>n</em> processes despite $t&lt;n/3$ Byzantine processes. When based on local coins, the existing algorithms converge <em>O(n</em><sup>2.5</sup><em>)</em> expected time.</p>
<p>A recent randomized algorithm that does not contain a signature solves consensus in <em>O</em>(1) expected time under a fair scheduler, where <em>O</em> is the binary.</p>
<p>To solve the consensus problem deterministically and prevent the use of the common coin, researchers have assumed partial or eventual synchrony. Here, these solutions require a unique coordinator process, referred to as the leader, in order to remain non-faulty. There are both advantages and disadvantages to this technique: the advantage is if the coordinator is non-faulty and if the messages are delivered in a timely manner in an asynchronous round, then the coordinator broadcasts its proposal to all processes and this value is decided after a contest number of message delays; however a faulty coordinator can dramatically impact the algorithm performance by leveraging the power it has in a round and imposing its value to all. Non-faulty processes thus have no other choices but to decide nothing in this round.</p>
<p>This protocol sees the use of a weak coordinator; a weak coordinator allows for the introduction of a new deterministic Byzantine consensus algorithm that is time optimal, resilience optimal and does not require the use of signatures. Unlike the classic, strong coordinator, the weak coordinator does not impose its value. It allows non-faulty processes to decide a value quickly, without the need of the coordinator, while helping the algorithm to terminate if non-faulty processes know that they proposed distinct values that might all be decided. In addition, the presence of a weak coordinator allows rounds to be executed optimistically without waiting for a specific message. This is unlike classic BFT algorithms that have to wait for a particular message from their coordinator and occasionally has to recover from a slow network or faulty coordinator.</p>
<p>With regards to the problem of a slow of Byzantine coordinator, the weak coordinator helps agreement by contributing a value while still allowing termination in a constant number of message delays and thus is unlike the classic coordinator or the eventual leader which cannot be implemented in the Binary Byzantine Consensus Algorithm, BAMP<sub>n,t</sub>[<em>t&lt;n/3</em>].</p>
<p>The validation of protocol was conducted similarly to that of the HoneyBadger block chain, where &quot;Coin&quot;, the randomization algorithm from Moustefaoui et al. was used [<a href="https://hal.inria.fr/hal-00944019v2/document" title="Signature-Free Asynchronous Byzantine 
Consensus with $t&lt;n/3$ and 
*O*(n&lt;sup&gt;2&lt;/sup&gt;) Messages, 
Mostefaoui et al.">38</a>]. Using the 100 Amazon Virtual Machines located in 5 data centers on different continents, it was shown that the DBFT algorithm outperforms that of &quot;Coin&quot;; which is known to terminate in <em>O</em>(1) round in expectation. In addition, since Byzantine behaviors have been seen to severely affect the performance of strong coordinator-based consensus, 4 different Byzantine attacks have been tested in the validation.</p>
<a class="header" href="#summary-of-findings" id="summary-of-findings"><h2>Summary of Findings</h2></a>
<p>Here is a table highlighting characteristics of the above mentioned BFT Protocols. Asymptotic Security, Permissionless Blockchain, Timing Assumptions, Decentralized Control, Low Latency and Flexible Trust form part of the value system.</p>
<ul>
<li>Asymptotic Security: This depends only on digital signatures (and hash functions) for security</li>
<li>Permissionless Protocol: This allows anybody to create an address and begin interacting with the protocol.</li>
<li>Timing Assumptions: Please see <a href="./Appendix.html#many-forms-of-timing-assumptions-degrees-of-synchrony">Many Forms of Timing Assumptions (Degrees of Synchrony)</a></li>
<li>Decentralized Control: Consensus is achieved and defended by protecting the identity of that node until their job is done, through a leaderless nodes.</li>
<li>Low Latency: This describes a computer network that is optimized to process a very high volume of data messages with minimal delay.
Flexible Trust: Where users have the freedom to trust any combinations of parties they see fit.</li>
</ul>
<p>Important characteristics of each protocol are summarized in the table below.</p>
<table><thead><tr><th> Protocol                   </th><th align="center"> Permissionless Protocol </th><th align="center">  Timing Assumptions   </th><th align="center"> Decentralized Control </th><th align="center"> Low Latency </th><th align="center"> Flexible Trust </th><th align="center"> Asymptotic Security </th></tr></thead><tbody>
<tr><td> Hyperledger Fabric (HLF)   </td><td align="center">                           </td><td align="center"> Partially synchronous </td><td align="center">           ✓           </td><td align="center">             </td><td align="center">       ✓        </td><td align="center">                     </td></tr>
<tr><td> Tendermint                 </td><td align="center">                           </td><td align="center"> Partially synchronous </td><td align="center">                       </td><td align="center">      ✓      </td><td align="center">       ✓        </td><td align="center">          ✓          </td></tr>
<tr><td> Paxos                      </td><td align="center">             ✓             </td><td align="center"> Partially synchronous </td><td align="center">           ✓           </td><td align="center">      ✓      </td><td align="center">       ✓        </td><td align="center">                     </td></tr>
<tr><td> Chandra-Toureg             </td><td align="center">             ✓             </td><td align="center"> Partially synchronous </td><td align="center">           ✓           </td><td align="center">             </td><td align="center">       ✓        </td><td align="center">                     </td></tr>
<tr><td> Raft                       </td><td align="center">             ✓             </td><td align="center">  Weakly synchronous   </td><td align="center">           ✓           </td><td align="center">      ✓      </td><td align="center">       ✓        </td><td align="center">                     </td></tr>
<tr><td> HashGraph                  </td><td align="center">             ✓             </td><td align="center">     Asynchronous      </td><td align="center">           ✓           </td><td align="center">      ✓      </td><td align="center">       ✓        </td><td align="center">                     </td></tr>
<tr><td> SINTRA                     </td><td align="center">             ✓             </td><td align="center">     Asynchronous      </td><td align="center">           ✓           </td><td align="center">             </td><td align="center">       ✓        </td><td align="center">                     </td></tr>
<tr><td> HoneyBadgerBFT             </td><td align="center">             ✓             </td><td align="center">     Asynchronous      </td><td align="center">           ✓           </td><td align="center">      ✓      </td><td align="center">       ✓        </td><td align="center">          ✓          </td></tr>
<tr><td> Stellar Consensus Protocol </td><td align="center">             ✓             </td><td align="center">     Asynchronous      </td><td align="center">           ✓           </td><td align="center">      ✓      </td><td align="center">       ✓        </td><td align="center">          ✓          </td></tr>
<tr><td> LinBFT                     </td><td align="center">             ✓             </td><td align="center"> Partially synchronous </td><td align="center">           ✓           </td><td align="center">             </td><td align="center">       ✓        </td><td align="center">                     </td></tr>
<tr><td> Algorand                   </td><td align="center">             ✓             </td><td align="center">      Synchronous      </td><td align="center">           ✓           </td><td align="center">      ✓      </td><td align="center">       ✓        </td><td align="center">                     </td></tr>
<tr><td> Thunderella                </td><td align="center">             ✓             </td><td align="center">      Synchronous      </td><td align="center">           ✓           </td><td align="center">      ✓      </td><td align="center">       ✓        </td><td align="center">                     </td></tr>
<tr><td> Avalanche                  </td><td align="center">             ✓             </td><td align="center">      Synchronous      </td><td align="center">           ✓           </td><td align="center">      ✓      </td><td align="center">       ✓        </td><td align="center">                     </td></tr>
<tr><td> PARSEC                     </td><td align="center">             ✓             </td><td align="center">  Weakly synchronous   </td><td align="center">           ✓           </td><td align="center">             </td><td align="center">       ✓        </td><td align="center">                     </td></tr>
<tr><td> Democratic BFT             </td><td align="center">             ✓             </td><td align="center"> Partially synchronous </td><td align="center">           ✓           </td><td align="center">      ✓      </td><td align="center">       ✓        </td><td align="center">                     </td></tr>
</tbody></table>
<p>BFT consensus protocols have been considered as a means to diseminate and validate information, can schnorr multisignatures perform the same function in validating information through the action of signing. This will form part of the next review.</p>
<a class="header" href="#references-5" id="references-5"><h1>References</h1></a>
<p>[<a href="http://docs.maidsafe.net/Whitepapers/pdf/PARSEC.pdf" title="Protocol for Asynchronous, Reliable, 
Secure and Efficient Consensus (PARSEC) 
WhitePaper, Chevalier et al.">1</a>] Protocol for Asynchronous, Reliable, Secure and Efficient Consensus (PARSEC) WhitePaper, Chevalier et al., http://docs.maidsafe.net/Whitepapers/pdf/PARSEC.pdf, Date accessed: 2018-08-30</p>
<p>[<a href="https://hal.inria.fr/hal-00944019v2/document" title="Signature-Free Asynchronous Byzantine Consensus 
with t&lt;n/3 and O(n2) Messages,
Mostefaoui et al.">2</a>] Signature-Free Asynchronous Byzantine Consensus with t&lt;n/3 and O(n2) Messages, Mostefaoui et al., https://hal.inria.fr/hal-00944019v2/document, Date accessed: 2018-08-30</p>
<p>[<a href="https://people.csail.mit.edu/silvio/Selected%20Scientific%20Papers/Distributed%20Computation/BYZANTYNE%20AGREEMENT%20MADE%20TRIVIAL.pdf" title="Byzantine Agreement Made Trivial
Micali">3</a>] Byzantine Agreement Made Trivial, Micali.,https://people.csail.mit.edu/silvio/Selected%20Scientific%20Papers/Distributed%20Computation/BYZANTYNE%20AGREEMENT%20MADE%20TRIVIAL.pdf, Date accessed: 2018-08-30</p>
<p>[<a href="https://en.wikipedia.org/wiki/Gossip_protocol" title="Gossip Protocol, Wikipedia">4</a>] Gossip Protocol. Wikipedia https://en.wikipedia.org/wiki/Gossip_protocol, Date accessed: 2018-09-07</p>
<p>[<a href="https://medium.com/@flatoutcrypto/project-spotlight-maidsafe-and-parsec-part-1-4830cec8d9e3" title="Project Spotlight: Maidsafe and PARSEC Part 1">5</a>] Project Spotlight: Maidsafe and PARSEC Part 1, https://medium.com/@flatoutcrypto/project-spotlight-maidsafe-and-parsec-part-1-4830cec8d9e3, Date accessed: 2018-08-30</p>
<p>[<a href="https://eprint.iacr.org/2016/199.pdf" title="The Honey Badger of BFT Protocols WhitePaper,
Miller  et al.">6</a>] The Honey Badger of BFT Protocols WhitePaper, Miller et al.,  https://eprint.iacr.org/2016/199.pdf, Date accessed: 2018-08-30</p>
<p>[<a href="https://cachin.com/cc/talks/20170622-blockchain-ice.pdf" title="Blockchain, cryptography and consensus 2017, Cachin">7</a>] Blockchain, cryptography and consensus, Cachin,  https://cachin.com/cc/talks/20170622-blockchain-ice.pdf, Date accessed: 2018-09-04</p>
<p>[<a href="https://medium.com/@shelby_78386/i-dont-see-how-it-s-plausible-for-parallel-forks-of-the-hash-chain-to-be-finalized-concurrently-cb57afe9dd0a" title="Comments from Medium: 
I don't see hope it's plausible
for parallel forks of the hash chain
to be finalized concurrently">8</a>] Comments from Medium: I don't see how it's plausible for parallel forks of the hash chain to be finalized concurrently, https://medium.com/@shelby_78386/i-dont-see-how-it-s-plausible-for-parallel-forks-of-the-hash-chain-to-be-finalized-concurrently-cb57afe9dd0a, Date accessed: 2018-09-14</p>
<p>[<a href="http://conferences.inf.ed.ac.uk/EuroDW2018/papers/eurodw18-Rusch.pdf" title="High-Performance Consensus Mechanisms for Blockchains,
Rusch">9</a>] High-Performance Consensus Mechanisms for Blockchains, Rusch,  http://conferences.inf.ed.ac.uk/EuroDW2018/papers/eurodw18-Rusch.pdf, Date accessed: 2018-08-30</p>
<p>[<a href="https://arxiv.org/pdf/1708.05665.pdf" title="Untangling Blockchain: A Data Processing View of Blockchain Systems">10</a>] Untangling Blockchain: A Data Processing View of Blockchain Systems, Dinh et al., https://arxiv.org/pdf/1708.05665.pdf, Date accessed: 2018-08-30</p>
<p>[<a href="https://ieeexplore.ieee.org/document/8014672/" title="Survey of Consensus Protocols of Blockchain Applications,
4th International Conference on Advanced Computing 
and Communication Systems, Sankar et al.">11</a>] Survey of Consensus Protocols of Blockchain Applications, Sankar et al., https://ieeexplore.ieee.org/document/8014672/, Date accessed: 2018-08-30</p>
<p>[<a href="https://www.stellar.org/papers/stellar-consensus-protocol.pdf" title="The Stellar Consensus Protocol: 
A Federated Model for Internet- level
Consensus, Mazières">12</a>] The Stellar Consensus Protocol: A Federated Model for Internet-level Consensus, Mazières, https://www.stellar.org/papers/stellar-consensus-protocol.pdf, Date accessed: 2018-08-30</p>
<p>[<a href="https://www.zurich.ibm.com/dccl/papers/cachin_dccl.pdf" title="Architecture of the Hyperledger 
Blockchain Fabric, Cachin">13</a>] Architecture of the Hyperledger Blockchain Fabric, Cachin, https://www.zurich.ibm.com/dccl/papers/cachin_dccl.pdf, Date accessed: 2018-09-16</p>
<p>[<a href="https://ripple.com/files/ripple_consensus_whitepaper.pdf" title="The Ripple Protocol Consensus 
Algorithm, Schwartz et al.">14</a>] The Ripple Protocol Consensus Algorithm, Schwartz et al.,  https://ripple.com/files/ripple_consensus_whitepaper.pdf, Date accessed: 2018-09-13</p>
<p>[<a href="https://tendermint.com/static/docs/tendermint.pdf" title="Tendermint: Consensus without Mining, Kwon">15</a>] Tendermint: Consensus without Mining, Kwon,  https://tendermint.com/static/docs/tendermint.pdf, Date accessed: 2018-09-20</p>
<p>[<a href="https://arxiv.org/pdf/1807.01829.pdf" title="LinBFT: Linear-Communication Byzantine 
Fault Tolerance for Public Blockchains, Yang">16</a>] LinBFT: Linear-Communication Byzantine Fault Tolerance for Public Blockchains,  Yang, https://arxiv.org/pdf/1807.01829.pdf, Date accessed: 2018-09-20</p>
<p>[<a href="http://gramoli.redbellyblockchain.io/web/doc/pubs/DBFT-preprint.pdf" title="DBFT: Efficient Byzantine Consensus 
with a Weak Coordinator and its Application 
to Consortium Blockchains, Crain et al.">17</a>] DBFT: Efficient Byzantine Consensus with a Weak Coordinator and its Application to Consortium Blockchains, Crain et al., http://gramoli.redbellyblockchain.io/web/doc/pubs/DBFT-preprint.pdf, Date accessed: 2018-09-30</p>
<p>[<a href="https://flatoutcrypto.com/home/avalancheprotocol" title="Protocol Spotlight: Avalanche Part 1">18</a>] Protocol Spotlight: Avalanche Part 1, https://flatoutcrypto.com/home/avalancheprotocol, Date Accessed: 2018-09-09</p>
<p>[<a href="https://bitcoinist.com/breaking-down-the-scalability-trilemma/" title="Breaking down the Blockchain 
Scalability Trilemma, Asolo,">19</a>] Breaking down the Blockchain Scalability Trilemma, Asolo, https://bitcoinist.com/breaking-down-the-scalability-trilemma/, Date accessed: 2018-10-01</p>
<p>[<a href="https://blog.cdemi.io/byzantine-fault-tolerance/" title="Byzantine Fault Tolerance, Demicoli">20</a>] Byzantine Fault Tolerance, Demicoli, https://blog.cdemi.io/byzantine-fault-tolerance/, Date accessed: 2018-10-01</p>
<p>[<a href="https://en.wikipedia.org/wiki/Consensus_(computer_science)" title="Consensus Mechanisms, Wikipedia">21</a>] Consensus Mechanisms, Wikipedia,  https://en.wikipedia.org/wiki/Consensus_(computer_science), Date accessed: 2018-10-01</p>
<p>[<a href="https://groups.csail.mit.edu/tds/papers/Lynch/jacm85.pdf" title="Impossibility of Distributed Consensus 
with One Faulty Process, Fischer et al.">22</a>]  Impossibility of Distributed Consensus with One Faulty Process, Fischer et al., https://groups.csail.mit.edu/tds/papers/Lynch/jacm85.pdf, Date accessed: 2018-09-30</p>
<p>[<a href="https://www.the-paper-trail.org/post/2008-08-13-a-brief-tour-of-flp-impossibility/" title="A brief Tour of FLP Impossibility">23</a>] A brief Tour of FLP Impossibility,  https://www.the-paper-trail.org/post/2008-08-13-a-brief-tour-of-flp-impossibility/, Date accessed: 2018-09-30</p>
<p>[<a href="https://hackernoon.com/demystifying-hashgraph-benefits-and-challenges-d605e5c0cee5" title="Demystifying HashGraph, Jia">24</a>] Demystifying HashGraph: Benefits and Challenges,  Jia, . https://hackernoon.com/demystifying-hashgraph-benefits-and-challenges-d605e5c0cee5, Date accessed: 2018-09-09</p>
<p>[<a href="https://arxiv.org/pdf/1607.01341.pdf" title="Algorand WhitePaper 
Chen and Micali">25</a>] Algorand WhitePaper, Chen and Micali, https://arxiv.org/pdf/1607.01341.pdf , Date accessed: 2018-09-13</p>
<p>[<a href="https://eprint.iacr.org/2017/913.pdf" title="Thunderella WhitePaper, Pass and Shi">26</a>] Thunderella: Blockchains with Optimistic Instant Confirmation, Pass and Shi, https://eprint.iacr.org/2017/913.pdf, Date accessed: 2018-09-13</p>
<p>[<a href="https://en.wikipedia.org/wiki/Chandra%E2%80%93Toueg_consensus_algorithm" title="Chandra-Toueg Consensus Algorithm, Wikipedia">27</a>] Chandra-Toueg Consensus Algorithm, Wikipedia, https://en.wikipedia.org/wiki/Chandra%E2%80%93Toueg_consensus_algorithm, Date accessed: 2018-09-13</p>
<p>[<a href="https://en.wikipedia.org/wiki/Raft_(computer_science)" title="Raft, Wikipedia">28</a>] Raft, Wikipedia, https://en.wikipedia.org/wiki/Raft_(computer_science), Date accessed: 2018-09-13</p>
<p>[<a href="https://en.wikipedia.org/wiki/Paxos_(computer_science)" title="Paxos, Wikipedia">29</a>] Paxos, Wikipedia, https://en.wikipedia.org/wiki/Paxos_(computer_science), Date accessed: 2018-10-01</p>
<p>[<a href="https://www.swirlds.com/downloads/SWIRLDS-TR-2016-01.pdf" title="Hashgraph WhitePaper, Baird">30</a>] The Swirlds Hashgraph consensus algorithm: Fair, fast, byzantine fault tolerance, Baird, https://www.swirlds.com/downloads/SWIRLDS-TR-2016-01.pdf, Date accessed: 2018-09-30</p>
<p>[<a href="http://www.swirlds.com/downloads/Swirlds-and-Sybil-Attacks.pdf" title="Swirlds and Sybil Attacks, Baird">31</a>] Swirlds and Sybil Attacks, Baird, http://www.swirlds.com/downloads/Swirlds-and-Sybil-Attacks.pdf, Date accessed: 2018-09-30</p>
<p>[<a href="https://hackernoon.com/demystifying-hashgraph-benefits-and-challenges-d605e5c0cee5" title="Demystifying HashGraph">32</a>] Demystifying HashGraph: Benefits and Challenges, Jia, https://hackernoon.com/demystifying-hashgraph-benefits-and-challenges-d605e5c0cee5, Date accessed: 2018-09-30</p>
<p>[<a href="https://medium.com/opentoken/hashgraph-a-whitepaper-review-f7dfe2b24647" title="HashGraph: A WhitePaper Review">33</a>] HashGraph: A WhitePaper Review, Graczyk, https://medium.com/opentoken/hashgraph-a-whitepaper-review-f7dfe2b24647, Date accessed: 2018-09-30</p>
<p>[<a href="https://blog.cosmos.network/tendermint-explained-bringing-bft-based-pos-to-the-public-blockchain-domain-f22e274a0fdb" title="Tendermint Explained- Bringing BFT-based
PoS to the Public Blockchain Domain">34</a>] Tendermint Explained- Bringing BFT-based PoS to the Public Blockchain Domain, https://blog.cosmos.network/tendermint-explained-bringing-bft-based-pos-to-the-public-blockchain-domain-f22e274a0fdb, Date accessed: 2018-09-30</p>
<p>[<a href="https://flatoutcrypto.com/home/maidsafeparsecexplanationpt2" title="Project Spotlight: Maidsafe and PARSEC Part 2">35</a>] Project Spotlight: Maidsafe and PARSEC Part 2, https://flatoutcrypto.com/home/maidsafeparsecexplanationpt2, Date accessed: 2018-09-18</p>
<p>[<a href="https://www.ccn.com/tag/red-belly-blockchain/" title="Red Belly Blockchain">36</a>] Red Belly Blockchain, https://www.ccn.com/tag/red-belly-blockchain/, Date accessed: 2018-10-10</p>
<p>[<a href="https://github.com/maidsafe/parsec" title="GitHub repository: Protocol for Asynchronous,
Reliable, Secure and Efficient Consensus">37</a>] Procotol for Asynchronous, Reliable, Secure and Efficent Consensus, https://github.com/maidsafe/parsec, Date accessed 2018-10-22</p>
<p>[<a href="https://hal.inria.fr/hal-00944019v2/document" title="Signature-Free Asynchronous Byzantine 
Consensus with $t&lt;n/3$ and 
*O*(n&lt;sup&gt;2&lt;/sup&gt;) Messages, 
Mostefaoui et al.">38</a>] Signature-Free Asynchronous Byzantine Consensus with $t&lt;n/3$ and <em>O</em>(n<sup>2</sup>) Messages, https://hal.inria.fr/hal-00944019v2/document, Date accessed 2018-10-22</p>
<p>[<a href="https://en.wikipedia.org/wiki/Byzantine_fault_tolerance" title="Byzantine Fault Tolerance, Wikipedia">39</a>] Byzantine Fault Tolerance. Wikipedia https://en.wikipedia.org/wiki/Byzantine_fault_tolerance, Date accessed: 2018-10-22</p>
<p>[<a href="https://www.usenix.org/legacy/event/nsdi09/tech/full_papers/clement/clement.pdf" title="Making Byzantine fault Tolerant Systems Tolerate Byzantine Faults , 
Clement et al.">40</a>] Making Byzantine Fault Tolerant Systems Tolerate Byzantine Faults, Clement et al., https://www.usenix.org/legacy/event/nsdi09/tech/full_papers/clement/clement.pdf, Date accessed 2018-10-22</p>
<p>[<a href="https://www.shoup.net/papers/ckps.pdf" title="Secure and Efficent Asynchronous Broadcast Protocols, 
Cachin et al.">41</a>] Secure and Efficent Asynchronous Broadcast Protocols, Cachin et al., https://www.shoup.net/papers/ckps.pdf, Date accessed 2018-10-22</p>
<p>[<a href="https://dl.acm.org/citation.cfm?id=198088" title="Asynchronous secure computations with 
optimal resilience, Ben-Or et al.">42</a>] Asynchronous secure computations with optimal resilience, Ben-Or et al., https://dl.acm.org/citation.cfm?id=198088, Date accessed 2018-10-22</p>
<p>[<a href="https://dl.acm.org/citation.cfm?id=198088" title="Asynchronous secure computations with 
optimal resilience, Ben-Or et al.">43</a>] Asynchronous secure computations with optimal resilience, Ben-Or et al., https://dl.acm.org/citation.cfm?id=198088, Date accessed 2018-10-22</p>
<p>[<a href="https://github.com/tendermint/tendermint/blob/master/docs/spec/p2p/node.md" title="Tendermint Peer Discovery
GitHub repository">44</a>] Tendermint Peer Discovery, https://github.com/tendermint/tendermint/blob/master/docs/spec/p2p/node.md, Date accessed 2018-10-22</p>
<p>[<a href="https://managementfromscratch.wordpress.com/2016/04/01/introduction-to-gossip/" title="Introduction to Gossip">45</a>] Just My Thoughts: Introduction to Gossip, https://managementfromscratch.wordpress.com/2016/04/01/introduction-to-gossip/, Date accessed 2018-10-22</p>
<p>[<a href="https://en.wikipedia.org/wiki/Atomic_broadcast" title="Atomic Broadcast, Wikipedia">46</a>] Atomic Broadcast. Wikipedia, https://en.wikipedia.org/wiki/Atomic_broadcast, Date accessed: 2018-10-22</p>
<p>[<a href="https://en.wikipedia.org/wiki/Liveness" title="Liveness, Wikipedia">47</a>] Liveness. Wikipedia, https://en.wikipedia.org/wiki/Liveness, Date accessed: 2018-10-22</p>
<p>[<a href="https://www.stellar.org/developers/guides/concepts/scp.html" title="Stellar Consensus Protocol">48</a>] Stellar Consensus Protocol Developer Guides, https://www.stellar.org/developers/guides/concepts/scp.html, Date accessed: 2018-10-22</p>
<p>[<a href="https://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/" title="A beginner's guide to Big O notation">49</a>] A beginner's guide to Big O notation, https://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/, Date accessed: 2018-10-22</p>
<p>[<a href="http://www.cs.yale.edu/homes/aspnes/papers/jalg90.pdf" title="Fast Randomized Consensus using Shared Memory,
Aspnes et al.">50</a>] Fast Randomized Consensus using Shared Memory, Aspnes et al., http://www.cs.yale.edu/homes/aspnes/papers/jalg90.pdf, Date accessed: 2018-10-22</p>
<p>[<a href="https://cachin.com/cc/papers/sintra.pdf" title="Secure Intrusion-tolerant Replication 
on the Internet, Cachin et al.">51</a>] Secure Intrusion-tolerant Replication on the Internet, Cachin et al., https://cachin.com/cc/papers/sintra.pdf, Date accessed: 2018-10-22</p>
<a class="header" href="#appendix" id="appendix"><h1>Appendix</h1></a>
<ul>
<li><a href="#terminology">Terminology</a>
<ul>
<li><a href="#consensus">Consensus</a></li>
<li><a href="#binary-consensus">Binary Consensus</a></li>
<li><a href="#byzantine-fault-tolerance">Byzantine Fault Tolerance</a></li>
<li><a href="#practical-byzantine-fault-tolerant-variants">Practical Byzantine Fault Tolerant Variants</a></li>
<li><a href="#deterministic-and-non-deterministic-protocols">Deterministic and Non-Deterministic Protocols</a></li>
<li><a href="#scalability-performance-trade-off">Scalability-performance trade off</a></li>
<li><a href="#many-forms-of-timing-assumptions-degrees-of-synchrony">Many Forms of Timing Assumptions (Degrees of Synchrony)</a>
<ul>
<li><a href="#synchrony">Synchrony</a></li>
<li><a href="#partial-synchrony">Partial Synchrony</a>
<ul>
<li><a href="#unknown-t-model">Unknown-△T Model</a></li>
<li><a href="#eventually-synchronous">Eventually Synchronous</a></li>
</ul>
</li>
<li><a href="#weak-synchrony">Weak Synchrony</a></li>
<li><a href="#random-synchrony">Random Synchrony</a></li>
<li><a href="#asynchrony">Asynchrony</a>
<ul>
<li><a href="#counting-rounds-in-asynchronous-networks">Counting rounds in asynchronous networks</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#the-problem-with-timing-assumptions">The Problem with Timing Assumptions</a>
<ul>
<li><a href="#denial-of-service-attack">Denial of Service Attack</a></li>
</ul>
</li>
<li><a href="#the-flp-impossibility">The FLP Impossibility</a></li>
<li><a href="#randomized-agreement">Randomized Agreement</a></li>
</ul>
</li>
</ul>
<a class="header" href="#terminology" id="terminology"><h2>Terminology</h2></a>
<p>In order to gain a full understanding of the field of consensus mechanism, specifically BFT consensus mechanisms, certain terms and concepts need to be defined and fleshed out.</p>
<a class="header" href="#consensus" id="consensus"><h3>Consensus</h3></a>
<p>Distributed agents (these could be computers, generals co-ordinating an attack, or sensors in a nuclear plant)
that communicate via a network (be it digital, courier or mechanical) need to agree on facts in order to act
as a coordinated whole.</p>
<p>When all non-faulty agents agree on a given fact, then we say that the network is in consensus.</p>
<p>Consensus is achieved when all non-faulty agents, agree on a prescribed fact.</p>
<p>There are a host of formal requirements which a consensus protocol may adhere to; these include:</p>
<ul>
<li><strong>Agreement:</strong> Where all correct processes agree on the same fact</li>
<li><strong>Weak Validity:</strong> Where for all correct processes, the output must be the input for some correct process</li>
<li><strong>Strong Validity:</strong> Where if all correct processes receive the same input value, they must all output that value</li>
<li><strong>Termination:</strong> All processes must eventually decide on an output value [<a href="https://en.wikipedia.org/wiki/Consensus_(computer_science)" title="Consensus Mechanisms, Wikipedia">21</a>]</li>
</ul>
<a class="header" href="#binary-consensus" id="binary-consensus"><h3>Binary Consensus</h3></a>
<p>There is a unique case of the consensus problem, referred to as the binary consensus restricts the input and hence the output domain to a single binary digit {0,1}.</p>
<p>When the input domain is large; relative to the number of processes, for instance an input set of all the natural numbers, it can be shown that consensus is impossible in a synchronous message passing model. [<a href="https://en.wikipedia.org/wiki/Consensus_(computer_science)" title="Consensus Mechanisms, Wikipedia">21</a>]</p>
<a class="header" href="#byzantine-fault-tolerance" id="byzantine-fault-tolerance"><h3>Byzantine Fault Tolerance</h3></a>
<p>Byzantine failures are considered the most general and most difficult class of failures among the failure modes. The so-called fail-stop failure mode occupies the simplest end of the spectrum. Whereas fail-stop failure mode simply means that the only way to fail is a node crash, detected by other nodes, Byzantine failures imply no restrictions, which means that the failed node can generate arbitrary data, pretending to be a correct one. Thus, Byzantine failures can confuse failure detection systems, which makes fault tolerance difficult. [<a href="https://en.wikipedia.org/wiki/Byzantine_fault_tolerance" title="Byzantine Fault Tolerance, Wikipedia">39</a>]</p>
<p>Several papers in the literature contextualize the problem using generals at different camps, situated outside the enemy castle, needing to decide whether or not to attack. A consensus algorithm that would fail, would perhaps see one general attack while all the others stay back, resulting in the vulnerability of first general</p>
<p>One key property of a block chain system is that the nodes do not trust each other, meaning that some may behave in Byzantine manners. The consensus protocol must therefore tolerate Byzantine failures.</p>
<p>A network is Byzantine Fault Tolerant when it can provide service and reach a consensus despite faults or failures of the system. The processes use a protocol for consensus or atomic broadcast (a broadcast where all correct processes in a system of multiple processes receive the same set of messages in the same order; that is, the same sequence of messages [<a href="https://en.wikipedia.org/wiki/Atomic_broadcast" title="Atomic Broadcast, Wikipedia">46</a>]) to agree on a common sequence of operations to execute. [[20]]</p>
<p>The literature on distributed consensus is vast, and there are many variants of previously proposed protocols being developed for block chains. They can be largely classified along a spectrum. One extreme consists of purely computation based protocols which use proof of computation to randomly select a node which single-handedly decides the next operation. The other extreme is purely communication based protocols in which nodes have equal votes and go through multiple rounds of communication to reach consensus, Practical Byzantine Fault Tolerance (PBFT) being the prime example, which is a replication algorithm designed to be BFT.  [<a href="https://arxiv.org/pdf/1708.05665.pdf" title="Untangling Blockchain: A Data Processing View of Blockchain Systems">10</a>]</p>
<p>For systems with <em>n</em> nodes, of which <em>f</em> are Byzantine, it has been shown that <em>no algorithm exists</em> that solves the consensus problem for <em>f &gt; n/3</em>.[<a href="https://en.wikipedia.org/wiki/Consensus_(computer_science)" title="Consensus Mechanisms, Wikipedia">21</a>]</p>
<p>So how then does the Bitcoin protocol get away with only needing 51% honest nodes to reach consensus?</p>
<p>Well, strictly speaking, Bitcoin is NOT a BFT-CM because there is never absolute finality in bitcoin ledgers; there is always a
chance (however small) that someone can 51% attack the network and rewrite the entire history. Bitcoin is a probabilistic consensus, rather than deterministic.</p>
<a class="header" href="#practical-byzantine-fault-tolerant-variants" id="practical-byzantine-fault-tolerant-variants"><h3>Practical Byzantine Fault Tolerant Variants</h3></a>
<p>PoW suffers from non-finality, that is a block appended to a block chain is not confirmed until it is extended by many other blocks. Even then, its existence in the block chain is only probabilistic. For example, eclipse attacks on Bitcoin exploit this probabilistic guarantee to allow double spending. In contrast, the original PBFT protocol is deterministic. [<a href="https://arxiv.org/pdf/1708.05665.pdf" title="Untangling Blockchain: A Data Processing View of Blockchain Systems">10</a>]</p>
<a class="header" href="#deterministic-and-non-deterministic-protocols" id="deterministic-and-non-deterministic-protocols"><h3>Deterministic and Non-Deterministic Protocols</h3></a>
<p>Deterministic, bounded Byzantine agreement relies on consensus being finalized for each epoch before moving to the next one ensuring that there is some safety about a consensus reference point prior to continuing. If instead you allow an unbounded number of consensus agreements within the same epoch, then there is no overall consensus reference point with which to declare finality and thus safety is compromised. [<a href="https://medium.com/@shelby_78386/i-dont-see-how-it-s-plausible-for-parallel-forks-of-the-hash-chain-to-be-finalized-concurrently-cb57afe9dd0a" title="Comments from Medium: 
I don't see hope it's plausible
for parallel forks of the hash chain
to be finalized concurrently">8</a>]</p>
<p>For non-deterministic or probabilistic protocols, the probability that an honest node is undecided after <em>r</em> rounds approaches zero as r approaches infinity.</p>
<p>Non-deterministic protocols which solve consensus under the purely asynchronous case potentially rely on random oracles and generally incur high message complexity overhead, as they depend on reliable broadcasting for all communication.</p>
<p>Protocols like HoneyBadger BFT fall into this class of nondeterministic protocols under asynchrony. Normally, they require three instances of reliable broadcast for a single round of communication. [<a href="https://blog.cosmos.network/tendermint-explained-bringing-bft-based-pos-to-the-public-blockchain-domain-f22e274a0fdb" title="Tendermint Explained- Bringing BFT-based
PoS to the Public Blockchain Domain">34</a>]</p>
<a class="header" href="#scalability-performance-trade-off" id="scalability-performance-trade-off"><h3>Scalability-performance trade off</h3></a>
<p>As briefly mentioned in the <a href="#introduction">Introduction</a>, the scalability of BFT protocols considering the number of participants is highly limited and the performance of most protocols deteriorates as the number of involved replicas increases. This effect is especially problematic for BFT deployment in permissionless block chains. [<a href="https://cachin.com/cc/talks/20170622-blockchain-ice.pdf" title="Blockchain, cryptography and consensus 2017, Cachin">7</a>]</p>
<p>The problem of BFT scalability is twofold: a high throughput as well as a large consensus group with good reconfigurability that can tolerate a high number of failures are both desirable properties in BFT protocols, but are often in direct conflict.</p>
<p>Bitcoin mining, for example supports thousands of participants, offers good reconfigurability, i.e. nodes can join or leave the network at any time, and can tolerate a high number of failures, however they are only able to process a severely limited number of transactions per second. Most BFT protocols achieve a significantly higher throughput, but are limited to small groups of participants of less than 20 nodes and the group reconfiguration is not easily achievable.</p>
<p>Several approaches have been employed to remedy these problems, e.g. threshold cryptography, creating new consensus groups for every round, or limiting the number of necessary messages to reach consensus. [<a href="http://conferences.inf.ed.ac.uk/EuroDW2018/papers/eurodw18-Rusch.pdf" title="High-Performance Consensus Mechanisms for Blockchains,
Rusch">9</a>]</p>
<a class="header" href="#many-forms-of-timing-assumptions-degrees-of-synchrony" id="many-forms-of-timing-assumptions-degrees-of-synchrony"><h3>Many Forms of Timing Assumptions (Degrees of Synchrony)</h3></a>
<a class="header" href="#synchrony" id="synchrony"><h4>Synchrony</h4></a>
<p>Here, the time for nodes to wait and receive information is predefined. If a node has not received an input within the redefined time structure,  there is a problem. [<a href="https://medium.com/@flatoutcrypto/project-spotlight-maidsafe-and-parsec-part-1-4830cec8d9e3" title="Project Spotlight: Maidsafe and PARSEC Part 1">5</a>]</p>
<p>In synchronous systems it is assumed that all communications proceed in rounds. In one round a process may send all the messages it requires while receiving all messages from other processes. In this manner no message from one round may influence any messages sent within the same round [<a href="https://en.wikipedia.org/wiki/Consensus_(computer_science)" title="Consensus Mechanisms, Wikipedia">21</a>]</p>
<p>A △T-synchronous network guarantees that every message sent is delivered after at most a delay of △T (where △T is a measure of real time) [<a href="https://eprint.iacr.org/2016/199.pdf" title="The Honey Badger of BFT Protocols WhitePaper,
Miller  et al.">6</a>] Synchronous protocols come to a consensus after △T. [<a href="https://medium.com/@flatoutcrypto/project-spotlight-maidsafe-and-parsec-part-1-4830cec8d9e3" title="Project Spotlight: Maidsafe and PARSEC Part 1">5</a>]</p>
<a class="header" href="#partial-synchrony" id="partial-synchrony"><h4>Partial Synchrony</h4></a>
<p>Here, the network retains some form of a predefined timing structure, however it can operate without knowing said assumption of how fast nodes can exchange messages over the network. Instead of pushing out a block every x seconds, in a partially synchronous block chain would gauge the limit, with messages always being sent and received within the unknown deadline.</p>
<p>Partially synchronous protocols come to a consensus in an unknown, but finite period. [<a href="https://medium.com/@flatoutcrypto/project-spotlight-maidsafe-and-parsec-part-1-4830cec8d9e3" title="Project Spotlight: Maidsafe and PARSEC Part 1">5</a>]</p>
<a class="header" href="#unknown-t-model" id="unknown-t-model"><h5>Unknown-△T Model</h5></a>
<p>The protocol is unable to use the delay bound as a parameter. [<a href="https://eprint.iacr.org/2016/199.pdf" title="The Honey Badger of BFT Protocols WhitePaper,
Miller  et al.">6</a>]</p>
<a class="header" href="#eventually-synchronous" id="eventually-synchronous"><h5>Eventually Synchronous</h5></a>
<p>The message delay bound △ is only guaranteed to hold after some (unknown instant, called the &quot;Global Stabilization Time&quot;. [<a href="https://eprint.iacr.org/2016/199.pdf" title="The Honey Badger of BFT Protocols WhitePaper,
Miller  et al.">6</a>]</p>
<a class="header" href="#weak-synchrony" id="weak-synchrony"><h4>Weak Synchrony</h4></a>
<p>Most existing Byzantine fault tolerant systems, even those called 'robust' assume some variation of <em>weak synchrony</em>, where messages are guaranteed to be delivered after a certain bound △T, but △T may be time-varying or unknown to the protocol designer.</p>
<p>However, the liveness properties of weakly synchronous protocols can fail completely when the expected timing assumptions are violated (e.g., due to a malicious network adversary). In general, liveness refers to a set of properties of concurrent systems, that require a system to make progress despite the fact that its concurrently executing components may have to &quot;take turns&quot; in critical sections, parts of the program that cannot be simultaneously run by multiple components.[<a href="https://en.wikipedia.org/wiki/Liveness" title="Liveness, Wikipedia">47</a>]</p>
<p>Even when the weak synchrony assumptions are satisfied in practice, weakly synchronous protocols degrade significantly in throughput when the underlying network is unpredictable. Unfortunately, weakly asynchronous protocols require timeout parameters that are difficult to tune, especially in cryptocurrency application settings; and when the chosen timeout values are either too long to too short, throughput can be hampered.</p>
<p>In terms of feasibility, both weak and partially synchronous protocols are equivalent- a protocol that succeeds in one setting can be systematically adapted for another. In terms of concrete performance, however, adjusting for weak synchrony means gradually increasing the timeout parameter over time (e.g. by an exponential back-off policy). This results in delays when recovering from transient network partition. Protocols typically manifest these assumptions in the form of a timeout event. For example, if parties detect that no progress has been made within a certain interval, then they take a corrective action such as electing a new leader. Asynchronous protocols do not rely on timers, and make progress whenever messages are delivered, regardless of actual clock time. [<a href="https://eprint.iacr.org/2016/199.pdf" title="The Honey Badger of BFT Protocols WhitePaper,
Miller  et al.">6</a>]</p>
<a class="header" href="#random-synchrony" id="random-synchrony"><h4>Random Synchrony</h4></a>
<p>Messages are delivered with random delays, such that the average delay is finite. There may be periods of arbitrarily long days (this is a weaker assumption than weak synchrony, and only a bit stronger than full asynchrony, where the only guarantee is that messages are eventually delivered). It is impossible to tell whether an instance has failed by completely stopping or if there is just a delay in message delivery. [<a href="http://docs.maidsafe.net/Whitepapers/pdf/PARSEC.pdf" title="Protocol for Asynchronous, Reliable, 
Secure and Efficient Consensus (PARSEC) 
WhitePaper, Chevalier et al.">1</a>]</p>
<a class="header" href="#asynchrony" id="asynchrony"><h4>Asynchrony</h4></a>
<p>In an asynchronous network, the adversary can deliver messages in any order and at any time, however the message must eventually be delivered between correct nodes. Nodes in an asynchronous network effectively have no use for real time clocks, and can only take actions based on the ordering of messages they receive. [<a href="https://eprint.iacr.org/2016/199.pdf" title="The Honey Badger of BFT Protocols WhitePaper,
Miller  et al.">6</a>]. The speed is determined by the speed at which the network communicates-instead of a fixed limit of x seconds.</p>
<p>An asynchronous protocol requires a different means to decide when all nodes are able to come to a consensus.</p>
<p>As will be discussed in <a href="#the-flp-impossibility">The FLP Impossibility</a>, FLP result rules out the possibility of the deterministic asynchronous protocols for atomic broadcast and many other tasks. A deterministic protocol must therefore make some stronger timing assumptions. [<a href="https://eprint.iacr.org/2016/199.pdf" title="The Honey Badger of BFT Protocols WhitePaper,
Miller  et al.">6</a>]</p>
<a class="header" href="#counting-rounds-in-asynchronous-networks" id="counting-rounds-in-asynchronous-networks"><h5>Counting rounds in asynchronous networks</h5></a>
<p>Although the guarantee of eventual delivery is decoupled from notions of 'real time', it is nonetheless desirable to characterize the running time of asynchronous protocols. The standard approach is for the adversary to assign each message a virtual round number, subject to the condition that every (<em>r</em>-1) message between correct nodes must be delivered before any (<em>r</em>+1) message is sent.</p>
<a class="header" href="#the-problem-with-timing-assumptions" id="the-problem-with-timing-assumptions"><h3>The Problem with Timing Assumptions</h3></a>
<p>The problem with both synchronous and partially synchronous assumptions is that &quot;the protocols based on timing assumptions are unsuitable for decentralized, cryptocurrency settings, where network links can be unreliable, network speeds change rapidly, and network delays may even be adversarially induced.&quot;[<a href="https://eprint.iacr.org/2016/199.pdf" title="The Honey Badger of BFT Protocols WhitePaper,
Miller  et al.">6</a>]</p>
<a class="header" href="#denial-of-service-attack" id="denial-of-service-attack"><h4>Denial of Service Attack</h4></a>
<p>Basing a protocol on timings, exposes the network to Denial of Service (DoS) attacks. A synchronous protocol will be deemed unsafe if a DoS slows down the network sufficiently. Even though a partially synchronous protocol would be safe, it would be unable to operate, as the messages would be exposed to interference.</p>
<p>An asynchronous protocol would be able to function under a DoS attack, however it is difficult to reach consensus, as it is impossible to know if the network is under attack, or if a particular message is delayed by the protocol itself.</p>
<a class="header" href="#the-flp-impossibility" id="the-flp-impossibility"><h3>The FLP Impossibility</h3></a>
<p>The paper, 'Impossibility of Distributed Consensus with One Faulty Process' by Fischer et al. [<a href="https://groups.csail.mit.edu/tds/papers/Lynch/jacm85.pdf" title="Impossibility of Distributed Consensus 
with One Faulty Process, Fischer et al.">22</a>], mapped out what is possible to achieve with distributed processes in an asynchronous environment.</p>
<p>The result, referred to as the FLP result, which raised the problem of consensus, that is, getting a distributed network of processors to agree on a common value. This problem was known to be solvable in a synchronous setting, where processes could proceed in simultaneous steps. The synchronous solution was seen as resilient to faults, where processors crash and take no further part in the computation. Synchronous models allow failures to be detected by waiting one entire step length for a reply from a processor, and presuming that it has crashed if no reply is received.</p>
<p>This kind of failure detection is not possible in an asynchronous setting, as there are no bounds on the amount of time a processor might take to complete its work and then respond. The FLP result shows that in an asynchronous setting, where only one processor might crash, there is no distributed algorithm that solves the consensus problem. [<a href="https://www.the-paper-trail.org/post/2008-08-13-a-brief-tour-of-flp-impossibility/" title="A brief Tour of FLP Impossibility">23</a>]</p>
<a class="header" href="#randomized-agreement" id="randomized-agreement"><h3>Randomized Agreement</h3></a>
<p>The consensus problem involves an asynchronous system of processes, some of which may be unreliable. The problem is for the reliable processes to agree on a binary value. Every protocol for this problem has the possibility of nontermination. [<a href="https://groups.csail.mit.edu/tds/papers/Lynch/jacm85.pdf" title="Impossibility of Distributed Consensus 
with One Faulty Process, Fischer et al.">22</a>] While the vast majority of PBFT protocols steer clear of this impossibility result by making timing assumptions, randomness (and, in particular, cryptography) provides an alternative route. Asynchronous BFT protocols have been used for a variety of tasks such as binary agreement (ABA), reliable broadcast (RBC) and more. [<a href="https://eprint.iacr.org/2016/199.pdf" title="The Honey Badger of BFT Protocols WhitePaper,
Miller  et al.">6</a>]</p>
<a class="header" href="#layer-2-scaling" id="layer-2-scaling"><h1>Layer 2 Scaling</h1></a>
<p>From <a href="https://github.com/tari-labs/tari-university/blob/master/src/layer2scaling/layer2scaling-landscape/layer2scaling-survey.md"><u><strong>Tari Labs</strong></u></a></p>
<p>Analogous to the OSI layers for communication, in block chain technology decentralized Layer 2 protocols, also commonly referred to as Layer 2 scaling, refers to transaction throughput scaling solutions. Decentralized Layer 2 protocols run on top of the main block chain (off-chain), while preserving the attributes of the main block chain (e.g. crypto economic consensus). Instead of each transaction only the resultant of a number of transactions are embedded on-chain.</p>
<p>From <a href="https://cryptodigestnews.com/the-logic-of-layer-2-scaling-fe51a8879e13"><u><strong>CryptoDigest</strong></u></a></p>
<p>Layer 2 scaling solutions utilize an interesting approach to scale block chains while keeping them decentralized. Layer 2 solutions are protocols built “on top” of block chains and sacrifice some security in order to potentially match VISA transaction levels. Layer 2 solutions are built with the intention of keeping  the user in control at all times.</p>
<a class="header" href="#layer-2-scaling-survey" id="layer-2-scaling-survey"><h1>Layer 2 Scaling Survey</h1></a>
<a class="header" href="#what-is-layer-2-scaling" id="what-is-layer-2-scaling"><h2>What is Layer 2 scaling?</h2></a>
<p>In the block chain and cryptocurrency world, transaction processing scaling is a tough problem to solve. This is limited by the average block creation time, the block size limit and number of newer blocks needed to confirm a transaction (confirmation time). These factors make '<em>over the counter</em>' type transactions similar to Master Card or Visa nearly impossible if done on the main block chain (on-chain).</p>
<p><img src="./sources/waiting.png" alt="waiting" /></p>
<p>Let's postulate that block chain and cryptocurrency &quot;takes over the world&quot; and are responsible for all global non-cash transactions performed, i.e. 433.1 billion in 2014-2015 <a href="https://www.worldpaymentsreport.com/download">[25]</a>. This means 13,734 transactions per second (tx/s) on average! <em>(To put this into perspective, VisaNet currently processes 160 billion transactions per year <a href="https://usa.visa.com/visa-everywhere/innovation/contactless-payments-around-the-globe.html">[26]</a> and is capable of handling more than 65,000 transaction messages per second <a href="https://usa.visa.com/dam/VCOM/download/corporate/media/visanet-technology/visa-net-fact-sheet.pdf">[27]</a>.)</em> This means that if all of those were simple single-input-single-output non-cash transactions and performed on...</p>
<ul>
<li>
<p>Segwit enabled Bitcoin 'like' block chains that can theoretically handle ~21.31 tx/s, we would need ~644 parallel versions and with a segwit transaction size of 190 bytes <a href="https://bitcoin.stackexchange.com/questions/59408/with-100-segwit-transactions-what-would-be-the-max-number-of-transaction-confi">[28]</a> the combined block chain growth would be <em>~210 GB per day</em>!</p>
</li>
<li>
<p>Ethereum 'like' block chains, and taking current gas prices into account Ethereum can theoretically process ~25.4 tx/s, then ~541 parallel versions would be needed and with a transaction size of 109 bytes (<a href="https://bitsonblocks.net/2016/10/02/a-gentle-introduction-to-ethereum/">[29]</a>, <a href="https://ethereum.stackexchange.com/questions/30175/what-is-the-size-bytes-of-a-simple-ethereum-transaction-versus-a-bitcoin-trans?rq=1">[30]</a>) the combined block chain growth would be <em>~120 GB per day</em>!</p>
</li>
</ul>
<p>This is why we need a proper scaling solution that would not bloat the block chain.</p>
<p>The Open Systems Interconnection (OSI) model defines 7 layers for communication functions of a computing system. Layer 1 refers to the physical layer and Layer 2 to the data link layer. Layer 1 is never concerned with functions of Layer 2 and up, it just delivers transmission and reception of raw data. In turn Layer 2 only knows about Layer 1 and defines the protocols that deliver node-to-node data transfer. <a href="https://en.wikipedia.org/wiki/OSI_model/">[1]</a></p>
<p><img src="./sources/OSI_Model.png" alt="OSI_Model" /></p>
<p>Analogous to the OSI layers for communication, in block chain technology decentralized Layer 2 protocols, also commonly referred to as Layer 2 scaling, refers to transaction throughput scaling solutions. Decentralized Layer 2 protocols run on top of the main block chain (off-chain), while preserving the attributes of the main block chain (e.g. crypto economic consensus). Instead of each transaction only the resultant of a number of transactions are embedded on-chain. [[2]](https://cloudblogs.microsoft.com/enterprisemobility/2018/02/12/decentralized-digital-identities-and-block chain-the-future-as-we-see-it)</p>
<p><img src="./sources/layer2scaling.png" alt="layer2scaling" /></p>
<p>Also:</p>
<ul>
<li>Does every transaction need every parent block chain node in the world to verify it?</li>
<li>Would I be willing to have (temporary) lower security guarantees for most of my day-to-day transactions if I could get them validated (whatever we take that to mean) near-instantly?</li>
</ul>
<p>If you can answer 'no' and 'yes', then you're looking for a Layer 2 scaling solution.</p>
<a class="header" href="#how-will-this-be-applicable-to-tari" id="how-will-this-be-applicable-to-tari"><h2>How will this be applicable to Tari?</h2></a>
<p>Tari is a high-throughput protocol that will need to handle real world transaction volumes. For example, Big Neon, the initial business application to be built on top of the Tari block chain requires high volume transactions in a short time, especially when tickets sales open and when tickets will be redeemed at an event. Imagine filling an 85,000 seat stadium with 72 entrance queues on match days. Serialized real world scanning boils down to ~500 tickets in 4 minutes, or ~2 spectators allowed access per second per queue.</p>
<p>This will be impossible to do with parent block chain scaling solutions.</p>
<a class="header" href="#layer-2-scaling-current-initiatives" id="layer-2-scaling-current-initiatives"><h2>Layer 2 scaling current initiatives</h2></a>
<a class="header" href="#a1-micropayment-channels" id="a1-micropayment-channels"><h3>#1 Micropayment Channels</h3></a>
<a class="header" href="#what-is-it" id="what-is-it"><h4>What is it?</h4></a>
<p>A Micropayment Channel is a class of techniques designed to allow users to make multiple Bitcoin transactions without committing all of the transactions to the Bitcoin block chain. In a typical payment channel, only two transactions are added to the block chain but an unlimited or nearly unlimited number of payments can be made between the participants. <a href="https://en.bitcoin.it/wiki/Payment_channels">[11]</a></p>
<p>Several channel designs have been proposed or implemented over the years- these include:</p>
<ul>
<li>Nakamoto high-frequency transactions</li>
<li>Spillman-style payment channels</li>
<li>CLTV-style payment channels</li>
<li>Poon-Dryja payment channels</li>
<li>Decker-Wattenhofer duplex payment channels</li>
<li>Decker-Russell-Osuntokun eltoo Channels</li>
<li>Hashed Time-Locked Contracts (HTLCs)</li>
</ul>
<p>With specific focus on Hashed Time-Locked Contracts:
A technique that can allow payments to be securely routed across multiple payment channels. HTlCs are integral to the design of more advanced payment channels such as those used by the <a href="https://gitpitch.com/tari-labs/tari-university/master?p=LightningNetworkForDummies#/">Lightning Network</a>.</p>
<p>The Lightning Network is a second layer payment protocol that operates on top of a block chain. It enables instant transactions between participating nodes. It features a peer-to-peer system for making micro payments of digital cryptocurrency through a network of bidirectional payment channels without delegating custody of funds and minimising trust of third parties. <a href="https://en.wikipedia.org/wiki/Lightning_Network">[12]</a></p>
<p>Normal use of the Lightning Network consists of opening a payment channel by committing a funding transaction to the relevant block chain, followed by making any number of Lightning transactions that update the tentative distribution of the channel's funds without broadcasting to the block chain, optionally followed by closing the payment channel by broadcasting the final version of the transaction to distribute the channel's funds.</p>
<p><img src="./sources/bitcoin-lightning-network-basic.png" alt="lightningnetwork" /></p>
<a class="header" href="#who-does-it" id="who-does-it"><h4>Who does it?</h4></a>
<p>Lightning is spreading across the cryptocurrency landscape. It was originally designed for Bitcoin, however Litecoin, Zcash, Ethereum and Ripple are just a few of the many cryptocurrencies planning to implement or test some form of the network. <a href="https://www.coindesk.com/bitcoin-isnt-crypto-adding-lightning-tech-now/">[13]</a></p>
<a class="header" href="#strengths" id="strengths"><h4>Strengths</h4></a>
<ul>
<li>It is one of the leading solutions that has been presented to scale Bitcoin, which does not require a change to the underlying protocol;</li>
<li>Transactions are processed instantly, the account balances of the nodes are updated and the money is immediately accessible to the new owner;</li>
<li>Transaction fees are a fraction of the transaction cost. <a href="https://cryptoverze.com/what-is-bitcoin-lightning-network/">[14]</a></li>
</ul>
<a class="header" href="#weaknesses" id="weaknesses"><h4>Weaknesses</h4></a>
<ul>
<li>It is not suitable for making bulk payment, as the intermediate nodes in the multichannel payment network may not be loaded with money to move the funds along;</li>
<li>Recipients cannot receive money unless their node is connected and online at the time of the transaction;</li>
<li>Currently channels are only bilateral</li>
</ul>
<a class="header" href="#opportunities-for-tari" id="opportunities-for-tari"><h4>Opportunities for Tari</h4></a>
<p>Less than expected as Tari's ticketing use case requires many fast transactions with many parties, not many fast transactions with a single party. Non-fungible assets must be &quot;broadcasted&quot;, but state channels are private between 2 parties.</p>
<a class="header" href="#threats-to-tari" id="threats-to-tari"><h4>Threats to Tari</h4></a>
<p>None.</p>
<a class="header" href="#a2-state-channels" id="a2-state-channels"><h3>#2 State Channels</h3></a>
<a class="header" href="#what-is-it-1" id="what-is-it-1"><h4>What is it?</h4></a>
<p>State channels are the more general form of micropayment channels — they can be used not only for payments, but for any arbitrary “state update” on a block chain — like changes inside a smart contract. <a href="https://medium.com/l4-media/making-sense-of-ethereums-layer-2-scaling-solutions-state-channels-plasma-and-truebit-22cb40dcc2f4">[17]</a></p>
<p>State channels allow multiple transactions to be made within off-chain agreements with very fast processing and the final settlement on-chain. It keeps the operation mode of block chain protocol but changes the way it is used so as to deal with the challenge of scalability.</p>
<p>Any change of state within a state channel requires explicit cryptographic consent from all parties designated as “interested” in that part of the state. <a href="https://l4.ventures/papers/statechannels.pdf">[20]</a></p>
<a class="header" href="#who-does-it-1" id="who-does-it-1"><h4>Who does it?</h4></a>
<p><u>On Ethereum:</u></p>
<ul>
<li>Raiden Network (<a href="https://medium.com/l4-media/making-sense-of-ethereums-layer-2-scaling-solutions-state-channels-plasma-and-truebit-22cb40dcc2f4">[17]</a>, <a href="https://raiden.network/">[21]</a>, <a href="https://raiden.network/101.html">[22]</a>)
<ul>
<li>Research state channel technology, define protocols and develop reference implementations;</li>
<li>Works with any ERC20 compatible token.</li>
<li>State updates between two parties are done via digitally signed and hash-locked transfers as the consensus mechanism, called balance proofs, which are also secured by a time-out. These can be settled on the Ethereum block chain at any time. Raiden Network uses HTLCs in exactly the same manner as the Lightning Network.</li>
</ul>
</li>
</ul>
<p><img src="./sources/Raiden.PNG" alt="Raiden" /></p>
<ul>
<li>Counterfactual (<a href="https://medium.com/l4-media/making-sense-of-ethereums-layer-2-scaling-solutions-state-channels-plasma-and-truebit-22cb40dcc2f4">[17]</a>, <a href="https://l4.ventures/papers/statechannels.pdf">[20]</a>, <a href="https://medium.com/statechannels/counterfactual-generalized-state-channels-on-ethereum-d38a36d25fc6">[32]</a>)
<ul>
<li>A generalized framework for native state channels integration in Ethereum-based decentralized applications;</li>
<li>A generalized state channel generalized framework is one where state is deposited once and then be used by any application or set of applications afterwards;</li>
<li>Counterfactual instantiation means to instantiate a contract without actually deploying it on-chain and is achieved by making users sign and share commitments to the multisig wallet;</li>
<li>When a contract is counterfactually instantiated, all parties in the channel act as though it has been deployed, even though it has not;</li>
<li>A global registry is introduced, an on-chain contract that maps unique deterministic addresses for any counterfactual contract to actual on-chain deployed addresses. The hashing function used to produce the deterministic address can be any function that takes into account the bytecode, its owner (i.e. the multi-signature wallet address), and a unique identifier;</li>
<li>A typical Counterfactual state-channel is composed of counterfactually instantiated objects.</li>
</ul>
</li>
</ul>
<p><img src="./sources/Counterfactual.PNG" alt="Counterfactual" /></p>
<ul>
<li>Funfair (<a href="https://medium.com/l4-media/making-sense-of-ethereums-layer-2-scaling-solutions-state-channels-plasma-and-truebit-22cb40dcc2f4">[17]</a>, <a href="https://funfair.io/state-channels-in-disguise">[24]</a>, <a href="https://funfair.io/wp-content/uploads/FunFair-Technical-White-Paper.pdf">[33]</a>)
<ul>
<li>Decentralized slot machine gambling platform, but still using centralized server based random number generation;</li>
<li>Instantiates normal 'Raiden like' state channel (called <em>fate channel</em>) between the player and the casino, final states submitted to block chain after betting game is concluded;</li>
<li>Investigating use of threshold cryptography like Boneh–Lynn–Shacham (BLS) signature schemes to enable truly secure random number generation by a group of participants.</li>
</ul>
</li>
</ul>
<p><u>On NEO:</u></p>
<ul>
<li>Trinity ([[3]](https://www.investinblock chain.com/trinity-protocol), <a href="https://trinity.tech">[18]</a>, <a href="https://trinity.tech/file/WhitePaperDraft1.pdf">[19]</a>)
<ul>
<li>Trinity is an open-source network protocol based on NEP-5 smart contracts;</li>
<li>Trinity for NEO is the same as the Raiden Network for Ethereum;</li>
<li>Trinity uses the same consensus mechanism as the Raiden network;</li>
<li>A new token, TNC, is introduced to fund the Trinity network, but NEO, NEP-5 and TNC tokens are supported.</li>
</ul>
</li>
</ul>
<a class="header" href="#strengths-1" id="strengths-1"><h4>Strengths</h4></a>
<ul>
<li>Allows payments and changes to smart contracts;</li>
<li>State channels have strong privacy properties, everything is happening “inside” a channel between participants;</li>
<li>State channels have instant finality, as soon as both parties sign a state update, it can be considered final.</li>
</ul>
<a class="header" href="#weaknesses-1" id="weaknesses-1"><h4>Weaknesses</h4></a>
<ul>
<li>State channels rely on availability, both parties must be on-line</li>
</ul>
<a class="header" href="#opportunities-for-tari-1" id="opportunities-for-tari-1"><h4>Opportunities for Tari</h4></a>
<p>Less than expected as Tari's ticketing use case requires many fast transactions with many parties, not many fast transactions with a single party. Non-fungible assets must be &quot;broadcasted&quot;, but state channels are private between 2 parties.</p>
<a class="header" href="#threats-for-tari" id="threats-for-tari"><h4>Threats for Tari</h4></a>
<p>None.</p>
<a class="header" href="#a3-off-chain-matching-engines" id="a3-off-chain-matching-engines"><h3>#3 Off-chain matching engines</h3></a>
<a class="header" href="#what-is-it-2" id="what-is-it-2"><h4>What is it?</h4></a>
<p>Orders are matched off-chain in matching engine and fulfilled on-chain, allows complex orders, support cross-chain transfers, maintains public record of orders and a deterministic specification of behaviour. Makes use of token representation smart contract, that converts global assets into smart contract tokens and vice versa. <a href="https://neonexchange.org/pdfs/whitepaper_v2.pdf">[5]</a></p>
<a class="header" href="#who-does-it-2" id="who-does-it-2"><h4>Who does it?</h4></a>
<ul>
<li>
<p>Neon Exchange (NEX) ( <a href="https://neonexchange.org/pdfs/whitepaper_v2.pdf">[5]</a>, <a href="https://neonexchange.org/">[36]</a>)</p>
<ul>
<li>A NEO decentralized application (dApp) with tokens;</li>
<li>Initial support planned for NEO, ETH, NEP5, and ERC20 tokens;</li>
<li>Cross-chain support planned for trading BTC, LTC, and RPX on NEX;</li>
<li>The NEX off-chain matching engine will be scalable, distributed, fault-tolerant, function continuously and without downtime;</li>
<li>Consensus is achieved using cryptographically signed requests, publicly specified deterministic off-chain matching engine algorithm, public ledgers of transactions and reward for foul play. The trade method of the exchange smart contract will only accept orders signed by a private key held by the matching engine;</li>
<li>The matching engine matches the orders and submits them to the respective block chain smart contract for execution;</li>
<li>A single invocation transaction on NEO can contain many smart contract calls; batch commit of matched orders in one on-chain transaction possible.</li>
</ul>
<p><img src="./sources/NEX-matching-engine.png" alt="NEX-matching-engine" /></p>
</li>
<li>
<p>0x (<a href="https://0xproject.com/">[34]</a>, <a href="https://0xproject.com/pdfs/0x_white_paper.pdf">[35]</a>)</p>
<ul>
<li>An Ethereum ERC20 based smart contract token (ZRX)</li>
<li>Provides an open source protocol to exchange ERC20 compliant tokens on the Ethereum block chain using off-chain matching engines in the form of dApps (<em>Relayers</em>) that facilitate transactions between <em>Makers</em> and <em>Takers</em>;</li>
<li>Off-chain order relay + on-chain settlement;</li>
<li><em>Maker</em> chooses <em>Relayer</em>, specifies token exchange rate, expiration time, fees to satisfy <em>Relayer’s</em> fee schedule and signs order with private key;</li>
<li>Consensus are governed with the publically available DEX smart contract; addresses, token balances, token exchange, fees, signatures, order status and final transfer.</li>
</ul>
<p><img src="./sources/0xSequence.png" alt="0xSequence" /></p>
</li>
</ul>
<a class="header" href="#strengths-2" id="strengths-2"><h4>Strengths</h4></a>
<ul>
<li>Performance {<em>NEX</em>, <em>0x</em>}:
<ul>
<li>Off-chain request/order;</li>
<li>Off-chain matching.</li>
</ul>
</li>
<li>NEX specific:
<ul>
<li>Batched on-chain commits;</li>
<li>Cross-chain transfers;</li>
<li>Support of national currencies;</li>
<li>Public JavaScript Object Notation (JSON) Application Programmers Interface (API) &amp; web extension API for third-party applications to trade tokens;</li>
<li>Development environment: <strong><em>Elixir on top of Erlang</em></strong> to enable scalable, distributed, and fault-tolerant matching engine;</li>
<li>Cure53 full security audit on web extension, NEX tokens will be regulated as registered European securities.</li>
</ul>
</li>
<li>0x specific:
<ul>
<li>Open source protocol to enable creation of independent off-chain dApp matching engines (<em>Relayers</em>);</li>
<li>Totally transparent matching of orders with no single point of control:
<ul>
<li>Maker's order only enters a Relayer's order book if fee schedule is adhered to;</li>
<li>Exchange can only happen if a Taker is willing to accept.</li>
</ul>
</li>
<li>Consensus and settlement governed by the publically available DEX smart contract.</li>
</ul>
</li>
</ul>
<a class="header" href="#weaknesses-2" id="weaknesses-2"><h4>Weaknesses</h4></a>
<ul>
<li>Still in development.</li>
<li>NEX specific:
<ul>
<li>A certain level of trust is required, similar to a traditional exchange;</li>
<li>Closed liquidity pool.</li>
</ul>
</li>
<li>0x specific:
<ul>
<li>A trusted Token Registry will be required to verify ERC20 token addresses and exchange rates;</li>
<li>Front running transactions and transaction collisions possible, more development needed (<a href="https://blog.0xproject.com/front-running-griefing-and-the-perils-of-virtual-settlement-part-1-8554ab283e97">[37]</a>,  <a href="https://blog.0xproject.com/front-running-griefing-and-the-perils-of-virtual-settlement-part-2-921b00109e21">[38]</a>);</li>
<li>Batch processing ability unknown.</li>
</ul>
</li>
</ul>
<a class="header" href="#opportunities-for-tari-2" id="opportunities-for-tari-2"><h4>Opportunities for Tari</h4></a>
<ul>
<li>Matching engines in general have opportunity for Tari; the specific scheme to be investigated further</li>
</ul>
<a class="header" href="#threats-for-tari-1" id="threats-for-tari-1"><h4>Threats for Tari</h4></a>
<ul>
<li>None.</li>
</ul>
<a class="header" href="#a4-masternodes" id="a4-masternodes"><h3>#4 Masternodes</h3></a>
<a class="header" href="#what-is-it-3" id="what-is-it-3"><h4>What is it?</h4></a>
<p>A masternode is a server on a decentralized network. It is utilized to complete unique functions in ways ordinary mining nodes cannot, for example features like direct send, instant transactions and private transactions. Because of their increased capabilities, masternodes typically require an investment in order to run. Masternode operators are incentivized and are rewarded by earning portions of block rewards in the cryptocurrency they are facilitating. Masternodes will get the standard return on their stakes, but will also be entitled to a portion of the transaction fees, allowing for a greater ROI. (<a href="https://cointelegraph.com/news/the-rise-of-masternodes-might-soon-be-followed-by-the-creation-of-servicenodes">[8]</a>, <a href="https://cointelegraph.com/news/the-rise-of-masternodes-might-soon-be-followed-by-the-creation-of-servicenodes">[10]</a>)</p>
<p><u>Dash Example</u> <a href="https://res.tuoluocaijing.cn/20180517155941-ojog.pdf">[31]</a>
Dash was the first cryptocurrency to implement the masternode model into its protocol. Under what Dash calls its proof of service algorithm, a second tier network of masternodes exists alongside a first tier network of miners to achieve distributed consensus on the block chain. This two tiered system ensures that proof of service and proof of work perform symbiotic maintenance of Dash’s network. Dash masternodes also enable a decentralized governance system that allows node operators to vote on important developments within the block chain. A masternode for Dash requires a stake of 1,000 DASH and share an equally 45% of block rewards with the miners. The other 10% goes to the block chain’s treasury fund, and operators are in charge of voting on proposals for how these funds will be allocated to improve the network.</p>
<p><em>Dash Deterministic Ordering</em></p>
<p>A special deterministic algorithm is used to create a pseudo-random ordering of the masternodes. By using the hash from the proof-of-work for each block, security of this functionality is provided by the mining network.</p>
<p><em>Dash Trustless Quorums</em></p>
<p>The Dash masternode network is trustless where no single entity can control the outcome. N pseudo random masternodes (Quorum A) are selected from the total pool to act as an oracle for N pseudo random masternodes (Quorum B) that are selected to perform the actual task. Quorum A are the closest nodes mathematically to the current block hash, while Quorum B are the furthest. This process is repeated for each new block in the block chain.</p>
<p><em>Dash Proof of Service</em></p>
<p>Bad actors could also run masternodes. To reduce the possibility of bad acting, nodes must ping the rest of the network to ensure they remain active. All masternode verification is done randomly via the Quorum system by the masternode network itself, approximately 1% of the network verified each block. This results in the entire masternode network being verified about six times per day. Six consecutive violations result in the deactivation of a masternode.</p>
<a class="header" href="#who-does-it-a-hrefhttpsblockonomicommasternode-guide9a" id="who-does-it-a-hrefhttpsblockonomicommasternode-guide9a"><h4>Who does it? <a href="https://blockonomi.com/masternode-guide/">[9]</a></h4></a>
<ul>
<li>Block, Bata, Crown, Chaincoin, Dash, Diamond, ION, Monetary Unit, Neutron, PIVX, Vcash, XtraBytes</li>
</ul>
<a class="header" href="#strengths-3" id="strengths-3"><h4>Strengths</h4></a>
<ul>
<li>
<p>Masternodes help to sustain and take care of the ecosystem and can protect block chains from network attacks;</p>
</li>
<li>
<p>Masternodes can perform decentralized governance of miners by having the power to reject or orphan blocks if required (<a href="https://coincentral.com/what-are-masternodes-an-introduction-and-guide/">[23]</a>, <a href="http://dashmasternode.org/what-is-a-masternode">[31]</a>)</p>
</li>
<li>
<p>Masternodes can support decentralized exchanges by overseeing transactions and offering fiat currency gateways;</p>
</li>
<li>
<p>Masternodes can be used to facilitate smart contracts, like instant transactions, anonymous transactions and decentralized payment processor;</p>
</li>
<li>
<p>Masternode can facilitate a decentralized marketplace like the block chain equivalent of peer-run commerce sites like eBay; <a href="https://coincentral.com/what-are-masternodes-an-introduction-and-guide/">[23]</a> </p>
</li>
<li>
<p>Masternodes compensates for Proof of Work’s limitations; it avoids mining centralization and consumes less energy; <a href="https://coincentral.com/what-are-masternodes-an-introduction-and-guide/">[23]</a></p>
</li>
<li>
<p>Masternodes promise enhanced stability and network loyalty, as larger dividends and high initial investment costs make it less likely that operators will abandon their position in the network.  <a href="https://coincentral.com/what-are-masternodes-an-introduction-and-guide/">[23]</a></p>
</li>
</ul>
<a class="header" href="#weaknesses-3" id="weaknesses-3"><h4>Weaknesses</h4></a>
<ul>
<li>Maintaining masternodes can be a long and arduous.</li>
<li>ROI is not guaranteed and is inconsistent. In some applications Masternodes only gets rewarded if they mine a block and if they are randomly chosen to get paid.</li>
<li>In general a masternode's IP address is publicized and thus open to attacks.</li>
</ul>
<a class="header" href="#opportunities-for-tari-3" id="opportunities-for-tari-3"><h4>Opportunities for Tari</h4></a>
<p>Masternodes does not have a specific standard or protocol, many different implementations exist. If the Tari protocol employs Masternodes they can be used to facilitate smart contracts off-chain and to enhance the security of the primary block chain.</p>
<p>Increases incentives for people to be involved with Tari.</p>
<a class="header" href="#threats-to-tari-1" id="threats-to-tari-1"><h4>Threats to Tari</h4></a>
<p>None</p>
<a class="header" href="#a5-plasma" id="a5-plasma"><h3>#5 Plasma</h3></a>
<a class="header" href="#what-is-it-4" id="what-is-it-4"><h4>What is it?</h4></a>
<p>Plasma block chains are a chain within a block chain, with state transitions enforced by bonded (time to exit) fraud proofs (block header hashes) submitted on the root chain. It enables management of a tiered block chain without a full persistent record of the ledger on the root block chain and without giving custodial trust to any 3rd party. The fraud proofs enforce an interactive protocol of rapid fund withdrawals in case of foul play like block withholding, in cases where bad actors in a lower level tier want to commit blocks to the root chain without broadcasting it to the higher level tiers. <a href="http://plasma.io/plasma.pdf">[4]</a></p>
<p><img src="./sources/Plasma-example-01.png" alt="Plasma-example-01" /></p>
<p>Plasma is a framework for incentivized and enforced execution of smart contracts, scalable to a significant amount of state updates per second, enabling the root block chain to be able to represent a significant amount of dApps, each employing its own block chain in a tree format. <a href="http://plasma.io/plasma.pdf">[4]</a></p>
<p>Plasma relies on two key parts, namely reframing all block chain computations into a set of MapReduce functions, and an optional method to do Proof-of-Stake token bonding on top of existing block chains (enforced in an on-chain smart contract). Nakamoto Consensus incentives discourage block withholding or other Byzantine behavior. If a chain is Byzantine, it has the option of going to any of its parents (including the root block chain) to continue operation or exit with the current committed state. <a href="http://plasma.io/plasma.pdf">[4]</a></p>
<p><img src="./sources/Plasma-example.png" alt="Plasma example" /></p>
<p>MapReduce is a programming model and an associated implementation for processing and generating large data sets. Users specify a map function that processes a key/value pair to generate a set of intermediate key/value pairs, and a reduce function that merges all intermediate values associated with the same intermediate key. <a href="https://storage.googleapis.com/pub-tools-public-publication-data/pdf/16cb30b4b92fd4989b8619a61752a2387c6dd474.pdf">[39]</a> The Plasma MapReduce  includes commitments on data to computation as input in the map phase and includes a merkleized proof of state transition in the reduce step when returning the result.  <a href="http://plasma.io/plasma.pdf">[4]</a></p>
<a class="header" href="#who-does-it-3" id="who-does-it-3"><h4>Who does it?</h4></a>
<p>Loom Network, using Delegated Proof of Stake (DPoS) consensus and validation, enabling scalable Application Specific Side Chains (DAppChains), running on top of Ethereum. (<a href="http://plasma.io/plasma.pdf">[4]</a>, <a href="https://medium.com/loom-network/everything-you-need-to-know-about-loom-network-all-in-one-place-updated-regularly-64742bd839fe">[16]</a>)</p>
<p>OMG Network (OmiseGO), using Proof of Stake (PoS) consensus and validation, a Plasma block chain scaling solution for finance running on top of Ethereum. (<a href="https://cdn.omise.co/omg/whitepaper.pdf">[6]</a>, <a href="https://omisego.network/">[15]</a>)</p>
<a class="header" href="#strengths-4" id="strengths-4"><h4>Strengths</h4></a>
<ul>
<li>Not all participants need to be online to update state;</li>
<li>Participants do not need a record of entry on the parent block chain to enable their participation in a Plasma block chain;</li>
<li>Minimal data needed on the parent block chain to confirm transactions when constructing Plasma block chains in a tree format;</li>
<li>Private block chain networks can be constructed, enforced by the root block chain. Transactions may occur on a local private block chain and have financial activity bonded by a public parent block chain;</li>
<li>Rapid exit strategies in case of foul play.</li>
</ul>
<a class="header" href="#weaknesses-4" id="weaknesses-4"><h4>Weaknesses</h4></a>
<p>Must still be proven on other networks apart from Ethereum.</p>
<a class="header" href="#opportunities-for-tari-4" id="opportunities-for-tari-4"><h4>Opportunities for Tari</h4></a>
<ul>
<li>Has opportunities for Tari as a L2 scaling solution.</li>
<li><em>Possibility to create a Tari ticketing Plasma dAppChain running of Monero without creating a Tari specific root block chain?</em> [<strong>Note:</strong> This will make the Tari block chain dependent on another block chain.]</li>
</ul>
<a class="header" href="#threats-for-tari-2" id="threats-for-tari-2"><h4>Threats for Tari</h4></a>
<p>The Loom Network's Software Development Kit (SDK) makes it extremely easy for anyone to create a new Plasma block chain. In less than a year a number of successful and diverse dAppChains have launched. <em>The next one can easily be for ticket sales...</em></p>
<a class="header" href="#a6-truebit" id="a6-truebit"><h3>#6 TrueBit</h3></a>
<a class="header" href="#what-is-it-5" id="what-is-it-5"><h4>What is it?</h4></a>
<p>TrueBit is a protocol that provides security and scalability by enabling trustless smart contracts to perform and offloading complex computation. This makes it different from state channels and Plasma, which are more useful for increasing the total transaction throughput of the Ethereum block chain. TrueBit relies on solvers (akin to miners), who have to stake their deposits in a smart contract, solve computation and if correct get their deposit back. If the computation is incorrect, the solver looses their deposit. TrueBit uses an economic mechanism called the “verification game” where an incentive is created for other parties, called <em>challengers,</em> to check the solvers’ work. (<a href="https://medium.com/l4-media/making-sense-of-ethereums-layer-2-scaling-solutions-state-channels-plasma-and-truebit-22cb40dcc2f4">[17]</a>, <a href="http://people.cs.uchicago.edu/%7Eteutsch/papers/truebit.pdf">[41]</a>, <a href="https://truebit.io">[44]</a>)</p>
<p><img src="./sources/TrueBit_Diagram.PNG" alt="TrueBit_Diagram" /></p>
<a class="header" href="#who-does-it-4" id="who-does-it-4"><h4>Who does it?</h4></a>
<p>Golem cites TrueBit as a verification mechanism for their forthcoming outsourced computation network LivePeer, a video streaming platform. ( <a href="https://golem.network/crowdfunding/Golemwhitepaper.pdf">[40]</a>, <a href="https://medium.com/livepeer-blog/livepeers-path-to-decentralization-a9267fd16532">[42]</a>, <a href="https://golem.network">[43]</a>)</p>
<a class="header" href="#strengths-5" id="strengths-5"><h4>Strengths</h4></a>
<ul>
<li>Outsourced computation - anyone in the world can post a computational task, and anyone else can receive a reward for completing it. <a href="http://people.cs.uchicago.edu/%7Eteutsch/papers/truebit.pdf">[41]</a></li>
<li>Scalable - by decoupling verification for miners into a separate protocol, TrueBit can achieve high transaction throughput without facing a Verifier’s Dilemma. <a href="http://people.cs.uchicago.edu/%7Eteutsch/papers/truebit.pdf">[41]</a></li>
</ul>
<a class="header" href="#weaknesses-5" id="weaknesses-5"><h4>Weaknesses</h4></a>
<p>TrueBit is yet to be fully tested.</p>
<a class="header" href="#opportunities-for-tari-5" id="opportunities-for-tari-5"><h4>Opportunities for Tari</h4></a>
<p>Nothing at the moment as Tari wouldn't be doing heavy/complex computation, at least not in the short term.</p>
<a class="header" href="#threats-for-tari-3" id="threats-for-tari-3"><h4>Threats for Tari</h4></a>
<p>None</p>
<a class="header" href="#observations" id="observations"><h2>Observations</h2></a>
<ul>
<li>Further investigation into the more promising layer 2 scaling solutions and technologies is required to verify alignment, applicability and use-ability.</li>
<li>An overview of Counterparty, Rootstock, Drivechains and Scriptless scripts must still be added.</li>
</ul>
<a class="header" href="#references-6" id="references-6"><h2>References</h2></a>
<p>[1] OSI mode, https://en.wikipedia.org/wiki/OSI_model, Date accessed: 2018-06-07.</p>
<p>[2] Decentralized Digital Identities and block chain – The Future as We See It, https://cloudblogs.microsoft.com/enterprisemobility/2018/02/12/decentralized-digital-identities-and-block chain-the-future-as-we-see-it, Date accessed: 2018-06-07.</p>
<p>[3] Trinity Protocol: The Scaling Solution of the Future?, https://www.investinblock chain.com/trinity-protocol, Date accessed: 2018-06-08.</p>
<p>[4] Plasma: Scalable Autonomous Smart Contracts, Poon J and Buterin V, http://plasma.io/plasma.pdf, Date accessed: 2018-06-14.</p>
<p>[5] NEX: A High Performance Decentralized Trade and Payment Platform, https://neonexchange.org/pdfs/whitepaper_v2.pdf, Date accessed: 2018-06-11.</p>
<p>[6] OmiseGO: Decentralized Exchange and Payments Platform, Poon J et. al., https://cdn.omise.co/omg/whitepaper.pdf, Date accessed: 2018-06-14.</p>
<p>[8] The Rise of Masternodes Might Soon be Followed by the Creation of Servicenodes, https://cointelegraph.com/news/the-rise-of-masternodes-might-soon-be-followed-by-the-creation-of-servicenodes, Date accessed: 2018-06-13.</p>
<p>[9] What are Masternodes?- Beginner's Guide, https://blockonomi.com/masternode-guide/, Date accessed: 2018-06-14.</p>
<p>[10] What the Heck is a DASH Masternode and How Do I get One, https://medium.com/dash-for-newbies/what-the-heck-is-a-dash-masternode-and-how-do-i-get-one-56e24121417e, Date accessed: 2018-06-14.</p>
<p>[11] Payment channels, https://en.bitcoin.it/wiki/Payment_channels , Date accessed: 2018-06-14.</p>
<p>[12] Lightning Network, https://en.wikipedia.org/wiki/Lightning_Network, Date accessed: 2018-06-14.</p>
<p>[13] Bitcoin Isn't the Only Crypto Adding Lightning Tech Now, https://www.coindesk.com/bitcoin-isnt-crypto-adding-lightning-tech-now/, Date accessed: 2018-06-14.</p>
<p>[14] What is Bitcoin Lighning Network? And How Does it Work?, https://cryptoverze.com/what-is-bitcoin-lightning-network/, Date accessed: 2018-06-14.</p>
<p>[15] OmiseGO, https://omisego.network/, Date accessed: 2018-06-14.</p>
<p>[16] Everything You Need to Know About Loom Network, All In One Place (Updated Regularly), https://medium.com/loom-network/everything-you-need-to-know-about-loom-network-all-in-one-place-updated-regularly-64742bd839fe, Date accessed: 2018-06-14.</p>
<p>[17] Making Sense of Ethereum’s Layer 2 Scaling Solutions: State Channels, Plasma, and Truebit, https://medium.com/l4-media/making-sense-of-ethereums-layer-2-scaling-solutions-state-channels-plasma-and-truebit-22cb40dcc2f4, Date accessed: 2018-06-14.</p>
<p>[18] Trinity: Universal Off-chain Scaling Solution, https://trinity.tech, Date accessed: 2018-06-14.</p>
<p>[19] Trinity White Paper: An Off--chain Scaling Solution for Neo, https://trinity.tech/file/WhitePaperDraft1.pdf, Date accessed: 2018-06-14.</p>
<p>[20] Counterfactual: Generalized State Channels, Coleman J et. al., https://counterfactual.com/statechannels &amp; https://l4.ventures/papers/statechannels.pdf, Date accessed: 2018-06-15.</p>
<p>[21] The Raiden Network, https://raiden.network/, Date accessed: 2018-06-15.</p>
<p>[22] What is the Raiden Network?, https://raiden.network/101.html, Date accessed: 2018-06-15.</p>
<p>[23] What are Masternodes?  An Introduction and Guide, https://coincentral.com/what-are-masternodes-an-introduction-and-guide/, Date accessed: 2018-06-15.</p>
<p>[24] State Channels in disguise?, https://funfair.io/state-channels-in-disguise, Date accessed: 2018-06-15.</p>
<p>[25] World Payments Report 2017, © 2017 Capgemini and BNP Paribas, https://www.worldpaymentsreport.com/download, Date accessed: 2018-06-20.</p>
<p>[26] VISA, https://usa.visa.com/visa-everywhere/innovation/contactless-payments-around-the-globe.html, Date accessed: 2018-06-20.</p>
<p>[27] VisaNet Fact Sheet 2017 Q4, https://usa.visa.com/dam/VCOM/download/corporate/media/visanet-technology/visa-net-fact-sheet.pdf, Date accessed: 2018-06-20.</p>
<p>[28] With 100% segwit transactions, what would be the max number of transaction confirmation possible on a block?, https://bitcoin.stackexchange.com/questions/59408/with-100-segwit-transactions-what-would-be-the-max-number-of-transaction-confi, Date accessed: 2018-06-21.</p>
<p>[29] A gentle introduction to Ethereum, https://bitsonblocks.net/2016/10/02/a-gentle-introduction-to-ethereum/, Date accessed: 2018-06-21.</p>
<p>[30] What is the size (bytes) of a simple Ethereum transaction versus a Bitcoin transaction?, https://ethereum.stackexchange.com/questions/30175/what-is-the-size-bytes-of-a-simple-ethereum-transaction-versus-a-bitcoin-trans?rq=1, Date accessed: 2018-06-21.</p>
<p>[31] WHAT IS A MASTERNODE?, http://dashmasternode.org/what-is-a-masternode, Date accessed: 2018-06-14.</p>
<p>[32] Counterfactual: Generalized State Channels on Ethereum, https://medium.com/statechannels/counterfactual-generalized-state-channels-on-ethereum-d38a36d25fc6, Date accessed: 2018-06-26.</p>
<p>[33] FunFair Technology Roadmap and Discussion, Longley J et. al., https://funfair.io/wp-content/uploads/FunFair-Technical-White-Paper.pdf, Date accessed: 2018-06-27.</p>
<p>[34] 0x protocol website, https://0xproject.com/, Date accessed: 2018-06-28.</p>
<p>[35] 0x:  An open protocol for decentralized exchange on the Ethereum block chain, https://0xproject.com/pdfs/0x_white_paper.pdf, Date accessed: 2018-06-28.</p>
<p>[36] NEX website, https://neonexchange.org/, Date accessed: 2018-06-28.</p>
<p>[37] Front-running, Griefing and the Perils of Virtual Settlement (Part 1), https://blog.0xproject.com/front-running-griefing-and-the-perils-of-virtual-settlement-part-1-8554ab283e97, Date accessed: 2018-06-29.</p>
<p>[38] Front-running, Griefing and the Perils of Virtual Settlement (Part 2), https://blog.0xproject.com/front-running-griefing-and-the-perils-of-virtual-settlement-part-2-921b00109e21, Date accessed: 2018-06-29.</p>
<p>[39] MapReduce: Simplied Data Processing on Large Clusters, https://storage.googleapis.com/pub-tools-public-publication-data/pdf/16cb30b4b92fd4989b8619a61752a2387c6dd474.pdf, Date accessed: 2018-07-02.</p>
<p>[40] The Golem WhitePaper (Future integrations), https://golem.network/crowdfunding/Golemwhitepaper.pdf, Date accessed: 2018-06-22.</p>
<p>[41] A scalable verification solution for block chains, Teutsch J. et. al., http://people.cs.uchicago.edu/~teutsch/papers/truebit.pdf, Date accessed: 2018-06-22.</p>
<p>[42] Livepeer’s Path To Decentralization, https://medium.com/livepeer-blog/livepeers-path-to-decentralization-a9267fd16532, Date accessed: 2018-06-22.</p>
<p>[43] Golem website, https://golem.network, Date accessed: 2018-06-22.</p>
<p>[44] TruBit website, https://truebit.io, Date accessed: 2018-06-22.</p>
<a class="header" href="#contributors-2" id="contributors-2"><h2>Contributors</h2></a>
<ul>
<li><a href="https://github.com/hansieodendaal">https://github.com/hansieodendaal</a></li>
<li><a href="https://github.com/Kevoulee">https://github.com/Kevoulee</a></li>
<li><a href="https://github.com/ksloven">https://github.com/ksloven</a></li>
</ul>
<a class="header" href="#layer-2-scaling-survey-part-2" id="layer-2-scaling-survey-part-2"><h1>Layer 2 Scaling Survey (part 2)</h1></a>
<p>This report provides a survey of TumbleBit , Counterparty, 2-Way Pegged Secondary Block Chains, Lumino, Scriptless scripts and Directed Acyclic Graph (DAG) Derivative Protocols as layer 2 scaling alternatives, building on <a href="../layer2scaling-landscape/layer2scaling-survey.html">Layer 2 Scaling Survey (part 1)</a>.</p>
<a class="header" href="#layer-2-scaling-current-initiatives-updated" id="layer-2-scaling-current-initiatives-updated"><h2>Layer 2 scaling current initiatives (updated)</h2></a>
<a class="header" href="#a1-tumblebit" id="a1-tumblebit"><h3>#1 TumbleBit</h3></a>
<a class="header" href="#what-is-it-6" id="what-is-it-6"><h4>What is it?</h4></a>
<p>The TumbleBit protocol was invented at the Boston University. It is a unidirectional, unlinkable payment hub that is fully compatible with the Bitcoin protocol. TumbleBit allows parties to make fast, anonymous, off-chain payments through an untrusted intermediary called the Tumbler. No-one, not even the Tumbler, can tell which payer paid which payee during a TumbleBit epoch (<em>i.e. time period of significance</em>). Two modes of operation are supported; a classic mixing/tumbling/washing mode or as a fully fledged payment hub. TumbleBit consists of two interleaved fair-exchange protocols - <em>RSA-Puzzle-Solver Protocol</em> and <em>Puzzle-Promise Protocol</em> - that relies on the  Rivest–Shamir–Adleman (RSA) cryptosystem's blinding properties to prevent bad acting from either users or Tumblers and to ensure anonymity. TumbleBit also supports anonymizing through Tor to ensure that the Tumbler server can operate as a hidden service. (<a href="http://cs-people.bu.edu/heilman/tumblebit/">[1]</a>, <a href="https://eprint.iacr.org/2016/575.pdf">[2]</a>, <a href="https://eprint.iacr.org/2016/056.pdf">[8]</a>, <a href="https://www.youtube.com/watch?v=8BLWUUPfh2Q&amp;feature=youtu.be&amp;t=1h3m10s">[9]</a>, <a href="https://bitcoinmagazine.com/articles/better-bitcoin-privacy-scalability-developers-are-making-tumblebit-reality">[10]</a>)</p>
<p><img src="./sources/TumbleBitOverview.PNG" alt="TumbleBitOverview" /></p>
<p>TumbleBit combines off-chain cryptographic computations with standard on-chain Bitcoin scripting functionalities to realize smart contracts (<a href="https://en.bitcoin.it/wiki/Contract">[11]</a>) that is not dependent on Segwit. The most important Bitcoin functionality used here are hashing conditions, signing conditions, conditional execution, 2-of-2 multi signatures and timelocking. <a href="https://eprint.iacr.org/2016/575.pdf">[2]</a></p>
<a class="header" href="#who-does-it-5" id="who-does-it-5"><h4>Who does it?</h4></a>
<p>The Boston University provided a proof-of-concept and reference implementation alongside the white paper <a href="https://github.com/BUSEC/TumbleBit">[4]</a>. NTumbleBit <a href="https://github.com/nTumbleBit/nTumbleBit">[5]</a> is being developed as a C# production implementation of the TumbleBit protocol that is currently being deployed by Stratis with their Breeze implementation (<a href="https://stratisplatform.com/2017/07/17/breeze-tumblebit-server-experimental-release">[6]</a>, <a href="https://stratisplatform.com/2017/09/20/breeze-wallet-with-breeze-privacy-protocol-dev-update/">[7]</a>), currently at alpha/experimental release level in testnet.</p>
<p><em>&quot;NTumbleBit will be a cross-platform framework, server and client for the TumbleBit payment scheme. TumbleBit is separated into two modes, tumbler mode and payment hub mode. The tumbler mode improves transaction fungibility and offers risk free unlinkable transactions. Payment hub mode is a way of making off-chain payments possible without requiring implementations like Segwit or the Lightning Network.&quot;</em> <a href="https://medium.com/@Stratisplatform/anonymous-transactions-coming-to-stratis-fced3f5abc2e">[3]</a></p>
<a class="header" href="#strengths-6" id="strengths-6"><h4>Strengths</h4></a>
<p><u>Anonymity properties</u> - TumbleBit provides unlinkability without the need to trust the Tumbler service (i.e. untrusted intermediary). <a href="https://eprint.iacr.org/2016/575.pdf">[2]</a></p>
<p><u>Denial of Service (DoS) and Sybil protection</u> - &quot;<em>TumbleBit uses transaction fees to resist DoS and Sybil attacks.</em>&quot; <a href="https://eprint.iacr.org/2016/575.pdf">[2]</a></p>
<p><u>Balance</u> - &quot;<em>The system should not be exploited to print new money or steal money, even when parties collude.</em>&quot;  <a href="https://eprint.iacr.org/2016/575.pdf">[2]</a></p>
<p><u>As a classic tumbler</u> - TumbleBit can also be used as a classic Bitcoin tumbler. <a href="https://eprint.iacr.org/2016/575.pdf">[2]</a></p>
<p><u>Bitcoin compatibility</u> - TumbleBit is fully compatible with the Bitcoin protocol. <a href="https://eprint.iacr.org/2016/575.pdf">[2]</a></p>
<p><u>Scale ability</u> - Each TumbleBit user only need to interact with the Tumbler and the corresponding transaction party; this lack of coordination between all TumbleBit users makes scale ability possible for the tumbler mode. <a href="https://eprint.iacr.org/2016/575.pdf">[2]</a></p>
<p><u>Batch processing</u> - TumbleBit  supports one-to-one, many-to-one, one-to-many and many-to-many transactions in payment hub mode. <a href="https://eprint.iacr.org/2016/575.pdf">[2]</a></p>
<p><u>Masternode compatibility</u> - The TumbleBit protocol can be fully implemented as a service in a Masternode. &quot;<em>The Breeze Wallet is now fully capable of providing enhanced privacy to bitcoin transactions through a secure connection. Utilizing Breeze Servers that are pre registered on the network using a secure, trustless registration mechanism that is resistant to manipulation and censorship.</em>&quot; (<a href="https://stratisplatform.com/2017/07/17/breeze-tumblebit-server-experimental-release">[6]</a>, <a href="https://stratisplatform.com/2017/09/20/breeze-wallet-with-breeze-privacy-protocol-dev-update">[7]</a>, <a href="https://stratisplatform.com/2017/08/10/bitcoin-privacy-tumblebit-integrated-into-breeze">[12]</a>)</p>
<p><u>Nearly production ready</u> - The NTumbleBit and Breeze implementations have gained testnet status.</p>
<a class="header" href="#weaknesses-6" id="weaknesses-6"><h4>Weaknesses</h4></a>
<p><u>Privacy not 100% proven</u> - Payees have better privacy than the payers, and theoretically collusion involving payees and the Tumbler can exist to discover the identity of the payer. <a href="https://www.bitcoinmarketinsider.com/tumblebit-wallet-reaches-one-step-forward">[13]</a></p>
<p><u>Tumbler service not distributed</u> - More work needs to be done to ensure persistent transaction state in case a Tumbler server goes down.</p>
<p><u>Equal denominations required</u> - The TumbleBit protocol can only support a common denominator unit value. <a href="https://eprint.iacr.org/2016/575.pdf">[2]</a></p>
<a class="header" href="#opportunities-for-tari-6" id="opportunities-for-tari-6"><h4>Opportunities for Tari</h4></a>
<p>Has benefits to Tari as a trustless Masternode matching/batch processing engine with strong privacy features.</p>
<a class="header" href="#threats-for-tari-4" id="threats-for-tari-4"><h4>Threats for Tari</h4></a>
<p>None</p>
<a class="header" href="#a2-counterparty" id="a2-counterparty"><h3>#2 Counterparty</h3></a>
<a class="header" href="#what-is-it-7" id="what-is-it-7"><h4>What is it?</h4></a>
<p>Counterparty is NOT a block chain. Counterparty is a token protocol released in January 2014 that operates on Bitcoin. It has a fully functional Decentralized Exchange (DEX), as well as several hardcoded smart contracts defined that include contracts for difference and binary options (&quot;bets&quot;). To operate, Counterparty utilizes &quot;embedded consensus&quot;, which means that a Counterparty transaction is created and embedded into a Bitcoin transaction, using encoding such as 1-of-3 multi-signature (multisig), Pay to Script Hash (P2SH) or Pay To Public Key Hash (P2PKH). Counterparty nodes, i.e. nodes that run both <code>bitcoind</code> and the <code>counterparty-server</code> applications, will receive Bitcoin transactions as normal (from <code>bitcoind</code>), and then <code>counterparty-server</code> will scan each, and decode and parse any embedded Counterparty transactions it finds. In effect, Counterparty is a ledger within the larger Bitcoin ledger, and the functioning of embedded consensus can be thought of similar to the fitting of one Russian stacking doll inside another.  <a href="https://github.com/CounterpartyXCP/Documentation/blob/master/Basics/FAQ-SmartContracts.md">([30]</a>, <a href="https://medium.com/@droplister/counterparty-development-101-2f4d9b0c8df3">[31]</a>, <a href="https://counterparty.io">[32]</a>)</p>
<p>Embedded consensus also means that the nodes maintain identical ledgers without using a separate peer-to-peer network, solely using the Bitcoin block chain for all communication (i.e. timestamping, transaction ordering and transaction propagation). Unlike Bitcoin, which has the concept of both a soft fork and a hard fork, a change to the protocol or &quot;consensus&quot; code of Counterparty always has the potential to create a hard fork. In practice, this means that each Counterparty node must run the same version of <code>counterparty-server</code> (or at least the same minor version, e.g. the &quot;3&quot; in 2.3.0) so that the protocol code matches up across all nodes. (<a href="https://counterparty.io/docs/faq/">[56]</a>, <a href="https://counterparty.io/docs/protocol_specification/">[57]</a>)</p>
<p>Unlike Bitcoin's UTXO model, the Counterparty token protocol utilizes an accounts system where each Bitcoin address is an account, and Counterparty credit and debit transactions for a specific token type affect account balances of that token for that given address. The decentralized exchange allows for low-friction exchanging of different tokens between addresses, utilizing the concept of &quot;orders&quot;, which are individual transactions made by Counterparty clients, and &quot;order matches&quot;, which the Counterparty protocol itself will generate as it parses new orders which overlap existing active orders in the system. It is the Counterparty protocol code itself which manages the escrow of tokens when an order is created, the exchange of tokens between two addresses that have overlapping orders, and the release of those assets from escrow post-exchange.</p>
<p>Counterparty uses its own token, XCP, which was created through a &quot;proof of burn&quot;  process during January 2014 <a href="https://counterparty.io/news/why-proof-of-burn/">[58]</a>. In that month, over 2,000 bitcoins were destroyed by various individuals sending them to an unspendable address on the Bitcoin network (<code>1CounterpartyXXXXXXXXXXXXXXXUWLpVr</code>), which caused the Counterparty protocol to award the sending address with a corresponding amount of XCP. XCP is used for payment of asset creation fees, collateral for contracts for difference/binary options, and often used as a base token in decentralized exchange transactions (largely due to the complexities of using BTC in such trades).</p>
<p><img src="./sources/CounterpartyStack.png" alt="CounterpartyStack" /></p>
<p>Support for the Ethereum Virtual Machine (EVM) was implemented, but never included on the mainnet version (<a href="https://github.com/CounterpartyXCP/Documentation/blob/master/Basics/FAQ-SmartContracts.md">[30]</a>. With the Counterparty EVM implementation, all published Counterparty smart contracts “live” at Bitcoin addresses that start with a <code>C</code>. Counterparty is used to broadcast an <code>execute</code> transaction to call a specific function or method in the smart contract code. Once an execution transaction is confirmed by a Bitcoin miner, the Counterparty federated nodes will receive the request and execute that method. The contract state is modified as the smart contract code executes and stored in the Counterparty database. <a href="https://counterparty.io/docs/faq/">[56]</a></p>
<p>General consensus has it that a <em>federated network</em> is a <em>distributed network of centralized networks</em>. The Ripple blockchain implements a Federated Byzantine Agreement (FBA) consensus mechanism. Federated sidechains implements a security protocol using a trusted federation of mutually distrusting functionaries/notaries. Counterparty utilizes a &quot;full stack&quot; packaging system for its components and all dependencies called the &quot;federated node&quot; system,  but this meaning refers to federated in the general definition (i.e. &quot;set up as a single centralized unit within which each state or division keeps some internal autonomy&quot;). (<a href="http://networkcultures.org/unlikeus/resources/articles/what-is-a-federated-network">[54]</a>, <a href="https://towardsdatascience.com/federated-byzantine-agreement-24ec57bf36e0">[55]</a>, <a href="https://blockstream.com/technology/sidechains.pdf">[28]</a>)</p>
<a class="header" href="#who-uses-it" id="who-uses-it"><h4>Who uses it?</h4></a>
<p>The most notable projects built on top of Counterparty are <a href="https://www.ageofchains.com">Age of Chains</a>, <a href="http://spacepirate.io">Age of Rust</a>, <a href="https://www.augmentorsgame.com/">Augmentors</a>, <a href="http://authparty.io/">Authparty</a>, <a href="https://bitcorns.com/">Bitcorns</a>, <a href="http://blockfreight.com/">Blockfreight™</a>, <a href="http://www.blocksafefoundation.com">Blocksafe</a>, <a href="http://btcpaymarket.com">BTCpaymarket.com</a>, <a href="http://coindaddy.io">CoinDaddy</a>, <a href="https://coval.readme.io">COVAL</a>, <a href="http://foldingcoin.net/">FoldingCoin</a>, <a href="https://www.footballcoin.io/">FootballCoin</a>, <a href="http://getgems.org/#/">GetGems</a>, <a href="https://indiesquare.me/">IndieBoard</a>, <a href="https://letstalkbitcoin.com/">LTBCoin - Letstalkbitcoin.com</a>, <a href="https://mafiawars.io/">Mafia Wars</a>, <a href="https://nvo.io/">NVO</a>, <a href="https://proofofvisit.com/">Proof of Visit</a>, <a href="http://rarepepe.party">Rarepepe.party</a>, <a href="http://mandelduck.com/sarutobiisland/">SaruTobi Island</a>, <a href="http://www.spellsofgenesis.com">Spells of Genesis</a>, <a href="https://mandelduck.com/#portfolio">Takara</a>, <a href="https://www.thescarabexperiment.org/">The Scarab Experiment</a>, <a href="https://token.fm/">Token.FM</a>, <a href="http://tokenly.com/">Tokenly</a>, <a href="https://topcoin.com/">TopCoin</a> and <a href="https://XCPDEX.COM">XCP DEX</a>. <a href="https://counterparty.io">[32]</a></p>
<p>In the past, projects like <a href="https://storj.io/">Storj</a> and <a href="https://counterparty.io/news/swarm-crowdfunding/">SWARM</a> also built on Counterparty.</p>
<p>COVAL is being developed with a primary purpose of moving value using “off-chain” methods. They use their own set of node runners to manage various &quot;off-chain&quot; distributed ledgers and ledger assigned wallets to implement an extended transaction value system, whereby tokens as well as containers of tokens can be securely transacted. Scaling within the COVAL eco system is thus achievable because they are not only reliant on the Counterparty federated nodes to execute smart contracts. <a href="https://coval.readme.io/docs">[33]</a></p>
<a class="header" href="#strengths-7" id="strengths-7"><h4>Strengths</h4></a>
<ul>
<li>Counterparty provides a simple way to add &quot;layer 2&quot; functionality (i.e. hard coded smart contracts) to an already existing blockchain implementation that supports basic data embedding</li>
<li>Counterparty's embedded consensus model utilizes &quot;permissionless innovation&quot;, meaning that even the Bitcoin core developers could not stop the use of the protocol layer without seriously crippling the network.</li>
</ul>
<a class="header" href="#weaknesses-7" id="weaknesses-7"><h4>Weaknesses</h4></a>
<ul>
<li>Embedded consensus requires lockstep upgrades from network nodes to avoid forks.</li>
<li>Embedded consensus imposes limitations on the ability of the secondary layer to interact with the primary layer's token. Counterparty was not able to manipulate BTC balances or otherwise utilize BTC directly.</li>
<li>With embedded consensus, nodes maintain identical ledgers without using a peer-to-peer network. One could make the claim that this hampers the flexibility of the protocol, and it limits the speed of the protocol to the speed of the underlying blockchain.</li>
</ul>
<a class="header" href="#opportunities-for-tari-7" id="opportunities-for-tari-7"><h4>Opportunities for Tari</h4></a>
<ul>
<li>Nodes can implement improved consensus models like Federated Byzantine Agreement <a href="https://towardsdatascience.com/federated-byzantine-agreement-24ec57bf36e0">[55]</a></li>
<li>See '<em>Scriptless scripts</em>'</li>
</ul>
<a class="header" href="#threats-for-tari-5" id="threats-for-tari-5"><h4>Threats for Tari</h4></a>
<p>None</p>
<a class="header" href="#a3-2-way-pegged-secondary-block-chains-sidechains-drivechains-federated-pegs" id="a3-2-way-pegged-secondary-block-chains-sidechains-drivechains-federated-pegs"><h3>#3 2-Way Pegged Secondary Block Chains (<em>Sidechains, Drivechains, Federated Pegs</em>)</h3></a>
<a class="header" href="#what-is-it-8" id="what-is-it-8"><h4>What is it?</h4></a>
<p>A 2-way peg (2WP) allows the &quot;transfer&quot; of BTC from the main Bitcoin block chain to a secondary block chain and vice-versa at a fixed rate by making use of an appropriate security protocol. The &quot;transfer&quot; actually involves BTC to be locked on the main Bitcoin block chain and unlocked/made available on the secondary block chain. The 2WP promise is concluded when an equivalent amount of tokens on the secondary block chain are locked (in the secondary block chain) so that the original bitcoins can be unlocked. (<a href="https://www.rsk.co/blog/sidechains-drivechains-and-rsk-2-way-peg-design">[22]</a>, <a href="https://blockstream.com/technology/sidechains.pdf">[28]</a>)</p>
<p><em><u>Sidechain:</u> When the security protocol is implemented using Simplified Payment Verification (SPV) proofs - block chain transaction verification without downloading the entire block chain - the secondary block chain are referred to as a Sidechain.</em> <a href="https://www.rsk.co/blog/sidechains-drivechains-and-rsk-2-way-peg-design">[22]</a></p>
<p><em><u>Drivechain:</u> When the security protocol is implemented by giving custody of the BTC to miners - where miners vote when to unlock BTC and where to send them - the secondary block chain are referred to as a Drivechain. In this scheme the miners will sign the block header using a Dynamic Membership Multi-party Signature (DMMS).</em> (<a href="https://www.rsk.co/blog/sidechains-drivechains-and-rsk-2-way-peg-design">[22]</a>, <a href="https://blockstream.com/technology/sidechains.pdf">[28]</a>)</p>
<p><em><u>Federated Peg/Sidechain:</u> When the security protocol is implemented by having a trusted federation of mutually distrusting functionaries/notaries - the secondary block chain are referred to as a Federated Peg/Sidechain. In this scheme the DMMS is replaced with a traditional multi-signature scheme.</em> (<a href="https://www.rsk.co/blog/sidechains-drivechains-and-rsk-2-way-peg-design">[22]</a>, <a href="https://blockstream.com/technology/sidechains.pdf">[28]</a>)</p>
<p><em><u>Hybrid Sidechain-Drivechain-Federated Peg:</u> When the security protocol is implemented by SPV proofs going to the secondary block chain and dynamic mixture of miner DMMS and functionaries/notaries multi-signatures going back to the main Bitcoin block chain  - the secondary block chain are referred to as a Hybrid Sidechain-Drivechain-Federated Peg.</em> (<a href="https://www.rsk.co/blog/sidechains-drivechains-and-rsk-2-way-peg-design">[22]</a>, <a href="https://blockstream.com/technology/sidechains.pdf">[28]</a>, <a href="https://blockstream.com/strong-federations.pdf">[29]</a>)</p>
<p>Example of a 2WP Bitcoin secondary block chain using a Hybrid Sidechain-Drivechain-Federated Peg security protocol below <a href="https://www.rsk.co/blog/sidechains-drivechains-and-rsk-2-way-peg-design">[22]</a>:</p>
<p><img src="./sources/RSK_HybridSideDriveChain.png" alt="RSK_HybridSideDriveChain" /></p>
<p>The locking of BTC on the main Bitcoin block chain is done by using a P2SH transaction where BTC can be sent to a script hash instead of a public key hash. To unlock the BTC in the P2SH transaction, the recipient must provide a script matching the script hash and data which makes the script evaluate to true. <a href="https://en.bitcoin.it/wiki/Pay_to_script_hash">[23]</a></p>
<a class="header" href="#who-does-it-6" id="who-does-it-6"><h4>Who does it?</h4></a>
<p>RSK (<em>formerly Rootstock</em>) is a 2WP Bitcoin secondary block chain using a hybrid sidechain-drivechain security protocol. RSK is scale-able up to 100 transactions per second (Tx/s) and provides a second layer scaling solution for Bitcoin as it can relieve on-chain Bitcoin transactions. (<a href="https://www.ethnews.com/a-survey-of-second-layer-solutions-for-blockchain-scaling-part-1">[14]</a>,  <a href="https://lunyr.com/article/Second-Layer_Scaling">[15]</a>, <a href="https://www.rsk.co">[16]</a>)</p>
<p>Hivemind (formerly Truthcoin) is implementing a Peer-to-Peer Oracle Protocol which absorbs accurate data into a block chain so that Bitcoin users can speculate in Prediction Markets. <a href="http://bitcoinhivemind.com">[24]</a></p>
<p>Blockstream is implementing a Federated Sidechain called Liquid, with the functionaries/notaries being made up of participating exchanges and Bitcoin businesses. <a href="https://blockstream.com/strong-federations.pdf">[29]</a></p>
<p><img src="./sources/Blockstream-Federated-Sidechain.PNG" alt="Blockstream-Federated-Sidechain" /></p>
<a class="header" href="#strengths-8" id="strengths-8"><h4>Strengths</h4></a>
<ul>
<li><u>Permissionless Innovation:</u> Anyone can create a new block chain project that uses the underlying strengths of the main Bitcoin block chain using real BTC as the currency <a href="http://www.drivechain.info">[20]</a></li>
<li><u>New Features:</u> Sidechains/Drivecahains can be used to test or implement new features without risk to the main Bitcoin block chain or without having to change its protocol, like Schnorr signatures and zero-knowledge proofs. (<a href="http://www.drivechain.info">[20]</a>, <a href="http://drivechains.org/what-are-drivechains/what-does-it-enable">[25]</a>)</li>
<li><u>Chains-as-a-Service (CaaS) :</u> It is possible to create a CaaS with data storage 2WP secondary block chains. <a href="http://drivechains.org/what-are-drivechains/what-does-it-enable">[25]</a></li>
<li><u>Smart Contracts:</u> 2WP secondary block chains make it easier to implement smart contracts. <a href="http://drivechains.org/what-are-drivechains/what-does-it-enable">[25]</a></li>
<li><u>Scalability:</u> 2WP secondary block chains can support larger block sizes and more transactions per second, thus scaling the Bitcoin main block chain. <a href="http://drivechains.org/what-are-drivechains/what-does-it-enable">[25]</a></li>
</ul>
<a class="header" href="#weaknesses-8" id="weaknesses-8"><h4>Weaknesses</h4></a>
<ul>
<li><u>Security:</u> Transferring BTC back into the main Bitcoin block chain is not secure enough and can be manipulated because Bitcoin does not support SPV from 2WP secondary block chains. <a href="http://www.truthcoin.info/blog/drivechain">[21]</a></li>
<li><u>51% attacks:</u> 2WP secondary block chains are hugely dependent on merged mining. As such, mining power centralization and 51% attacks are a real threat, as demonstrated for Namecoin and Huntercoin (See <a href="https://github.com/tari-labs/tari-university/blob/master/merged-mining/merged-mining-scene/MergedMiningIntroduction.md">Merged Mining Introduction</a>).</li>
<li>The DMMS provided by mining is not very secure for small systems, while the trust of the federation/notaries is riskier for large systems. <a href="https://blockstream.com/technology/sidechains.pdf">[28]</a></li>
</ul>
<a class="header" href="#opportunities-for-tari-8" id="opportunities-for-tari-8"><h4>Opportunities for Tari</h4></a>
<p>None, if enough functionality will be built into the main Tari block chain.</p>
<a class="header" href="#threats-for-tari-6" id="threats-for-tari-6"><h4>Threats for Tari</h4></a>
<p>None</p>
<a class="header" href="#a4-lumino" id="a4-lumino"><h3>#4 Lumino</h3></a>
<a class="header" href="#what-is-it-9" id="what-is-it-9"><h4>What is it?</h4></a>
<p>Lumino Transaction Compression Protocol (LTCP) is a technique for transaction compression that allows processing a higher volume of transactions but storing much less information. The Lumino network is a lightning-like extension of the RSK platform that uses LTCP. Delta (difference) compression of selected fields of transactions from the same owner are done by using aggregate signing of previous transactions so previous signatures can be disposed. <a href="https://uploads.strikinglycdn.com/files/ec5278f8-218c-407a-af3c-ab71a910246d/LuminoTransactionCompressionProtocolLTCP.pdf">[17]</a></p>
<p>Each transaction contains a set of persistent fields called the Persistent Transaction Information (PTI) and a compound record of user transaction data called the SigRec. A Lumino block stores two Merkle trees - one containing all PTIs and the other all transaction IDs (hash of the signed SigRec). This second Merkle tree is conceptually similar to the Segwit witness tree, thus forming the witness part. Docking is the process where SicRec and signature data can be pruned from the block chain if valid linked PTI information exist. <a href="https://uploads.strikinglycdn.com/files/ec5278f8-218c-407a-af3c-ab71a910246d/LuminoTransactionCompressionProtocolLTCP.pdf">[17]</a></p>
<p><img src="./sources/LuminoDataPruning.PNG" alt="LuminoDataPruning" /></p>
<a class="header" href="#who-does-it-7" id="who-does-it-7"><h4>Who does it?</h4></a>
<p>RSK, which has been newly launched on main net in January 2018. The Lumino Network must still be launched in test net. (<a href="https://cryptonewsmonitor.com/2017/11/11/bitcoin-based-ethereum-rival-rsk-set-to-launch-next-month">[18]</a>, <a href="%5B18%5D">[19]</a>)</p>
<a class="header" href="#strengths-9" id="strengths-9"><h4>Strengths</h4></a>
<ul>
<li>The Lumino Network promises high efficiency in pruning the RSK block chain</li>
</ul>
<a class="header" href="#weaknesses-9" id="weaknesses-9"><h4>Weaknesses</h4></a>
<ul>
<li>The Lumino Network has not been released yet</li>
<li>Details about how the Lumino Network will handle payment channels were not decisive in the white paper <a href="https://uploads.strikinglycdn.com/files/ec5278f8-218c-407a-af3c-ab71a910246d/LuminoTransactionCompressionProtocolLTCP.pdf">[17]</a></li>
</ul>
<a class="header" href="#opportunities-for-tari-9" id="opportunities-for-tari-9"><h4>Opportunities for Tari</h4></a>
<p>LTCP pruning may be beneficial to Tari</p>
<a class="header" href="#threats-for-tari-7" id="threats-for-tari-7"><h4>Threats for Tari</h4></a>
<p>None</p>
<a class="header" href="#a5-scriptless-scripts" id="a5-scriptless-scripts"><h3>#5 Scriptless scripts</h3></a>
<a class="header" href="#what-is-it-10" id="what-is-it-10"><h4>What is it?</h4></a>
<p><em>Scriptless Scripts</em> was coined and invented by mathematician Andrew Poelstra whereby scripting functionality is offered without actual scripts on the block chain to implement smart contracts. Currently it can only work on the Mimblewimble block chain and makes use of a specific Schnorr signature scheme <a href="https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki">[38]</a> that allows for signature aggregation, mathematically combining several signatures into a single signature, without having to prove Knowledge of Secret Keys (KOSK). This is known as the <em>plain public-key model</em> where the only requirement is that each potential signer has a public key. The KOSK scheme requires that users prove knowledge (or possession) of the secret key during public key registration with a certification authority, and is one way to generically prevent rogue-key attacks. (<a href="https://blockstream.com/2018/01/23/musig-key-aggregation-schnorr-signatures.html">[35]</a>, <a href="https://eprint.iacr.org/2018/068.pdf">[36]</a>)</p>
<p>Signature aggregation properties sought here are (<a href="https://blockstream.com/2018/01/23/musig-key-aggregation-schnorr-signatures.html">[35]</a>, <a href="https://eprint.iacr.org/2018/068.pdf">[36]</a>):</p>
<ul>
<li>Must be provably secure in the <em>plain public-key model</em>;</li>
<li>Must satisfy the normal Schnorr equation, whereby the resulting signature can be written as a function of a combination of the public keys;</li>
<li>Must allow for Interactive Aggregate Signatures (IAS) where the signers are required to cooperate;</li>
<li>Must allow for Non-interactive Aggregate Signatures (NAS) where the aggregation can be done by anyone;</li>
<li>Must allow each signer to sign the same message;</li>
<li>Must allow each signer to sign their own message.</li>
</ul>
<p>This is different to a normal multi-signature scheme where one message is signed by all.</p>
<p>Let's say Alice and Bob each needs to provide half a Schnorr signature for a transaction whereby Alice promises to reveal a secret to Bob in exchange for 1 crypto coin. Alice can calculate the difference between her half Schnorr signature and the Schnorr signature of the secret (adaptor signature) and hand it over to Bob. Bob then has the ability to verify the correctness of the adaptor signature without knowing the original signatures. Bob can then provide his half Schnorr signature to Alice so she can broadcast the full Schnorr signature to claim the crypto coin. By broadcasting the full Schnorr signature Bob has access to Alice's half Schnorr signature and he can then calculate the Schnorr signature of the secret because he already knows the adaptor signature, thereby claiming his prize. This is also known as Zero-Knowledge Contingent payments. (<a href="https://bitcoinmagazine.com/articles/scriptless-scripts-how-bitcoin-can-support-smart-contracts-without-smart-contracts">[34]</a>, <a href="https://download.wpsoftware.net/bitcoin/wizardry/mw-slides/2017-03-mit-bitcoin-expo/slides.pdf">[37]</a>)</p>
<a class="header" href="#who-does-it-8" id="who-does-it-8"><h4>Who does it?</h4></a>
<p><a href="https://grin-tech.org/">grin-tech.org</a></p>
<p>Mimblewimble is being sited by Andrew Poelstra as being the ultimate <em>Scriptless Script</em>. <a href="https://download.wpsoftware.net/bitcoin/wizardry/mw-slides/2017-03-mit-bitcoin-expo/slides.pdf">[37]</a></p>
<p><img src="./sources/Mimblewimble.PNG" alt="Mimblewimble" /></p>
<a class="header" href="#strengths-10" id="strengths-10"><h4>Strengths</h4></a>
<ul>
<li><u>Data savings:</u> Signature aggregation provides data compression on the block chain</li>
<li><u>Privacy:</u> Nothing about the <em>Scriptless Script</em> smart contract, other than the settlement transaction,  is ever recorded on the block chain. No one will ever know that an underlying smart contract was executed.</li>
<li><u>Multiplicity:</u> Multiple digital assets can be transferred between two parties in a single settlement transaction.</li>
<li><u>Implicit scalability:</u> Scalability on the block chain is achieved by virtue of compressing multiple transactions into a single settlement transaction. Transactions are only broadcasted to the block chain once all preconditions are met.</li>
</ul>
<a class="header" href="#weaknesses-10" id="weaknesses-10"><h4>Weaknesses</h4></a>
<p>In a recent work Maxwell et al. (<a href="https://blockstream.com/2018/01/23/musig-key-aggregation-schnorr-signatures.html">[35]</a>, <a href="https://eprint.iacr.org/2018/068.pdf">[36]</a>) showed that a naive implementation of Schnorr multi-signatures that satisfies key aggregation is not secure, and that the Bellare and Neven (BN) Schnorr signature scheme loses the key aggregation property in order to gain security in the plain public-key model. They proposed a new Schnorr-based multi-signature scheme with key aggregation called MuSig, which is provably secure in the <em>plain public-key model</em>. It has the same key and signature size as standard Schnorr signatures. The joint signature can be verified exactly the same as a standard Schnorr signature with respect to a single “aggregated” public-key, which can be computed from the individual public keys of the signers. Note that the case of interactive signature aggregation where each signer signs their own message must still be proven by a complete security analysis.</p>
<a class="header" href="#opportunities-for-tari-10" id="opportunities-for-tari-10"><h4>Opportunities for Tari</h4></a>
<p>Tari plans to implement the Mimblewimble block chain and should implement the <em>Scriptless Script</em>s together with the MuSig Schnorr signature scheme.</p>
<p>However, this in itself will not provide the Layer 2 scaling performance that will be required. Big Neon, the initial business application to be built on top of the Tari block chain, requires to &quot;facilitate 500 tickets in 4 minutes&quot;, that is ~2 spectators allowed access every second, with negligible latency.</p>
<p>The Mimblewimble <em>Scriptless Script</em>s could be combined with a federated node (or specialized masternode), similar to that being developed by Counterparty. The secrets that are revealed by virtue of the MuSig Schnorr signatures can instantiate normal smart contracts inside the federated node, with the final consolidated state update being written back to the block chain after the event.</p>
<a class="header" href="#threats-for-tari-8" id="threats-for-tari-8"><h4>Threats for Tari</h4></a>
<p>None</p>
<a class="header" href="#a6-directed-acyclic-graph-dag-derivative-protocols-greedy-heaviest-observed-sub-tree-ghost-braiding-jute-spectre" id="a6-directed-acyclic-graph-dag-derivative-protocols-greedy-heaviest-observed-sub-tree-ghost-braiding-jute-spectre"><h3>#6 Directed Acyclic Graph (DAG) Derivative Protocols: Greedy Heaviest Observed Sub-Tree (GHOST), Braiding, Jute, SPECTRE</h3></a>
<a class="header" href="#what-is-it-11" id="what-is-it-11"><h4>What is it?</h4></a>
<p>In mathematics and computer science, a Directed Acyclic Graph (DAG) is a finite directed graph with no directed cycles. A directed graph is acyclic if and only if it has a topological ordering, that is for every directed edge <em>uv</em> from vertex <em>u</em> to vertex <em>v</em>, <em>u</em> comes before <em>v</em> in the ordering (age). <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">[42]</a></p>
<p><img src="./sources/DAG.PNG" alt="DAG" /></p>
<p>DAGs in block chain were first proposed as the GHOST protocol (<a href="https://eprint.iacr.org/2013/881.pdf">[44]</a>, <a href="http://fc15.ifca.ai/preproceedings/paper_101.pdf">[45]</a>), a version of which is implemented in Ethereum as the Ethash PoW algorithm (based on Dagger-Hashimoto). Then Braiding (<a href="https://scalingbitcoin.org/hongkong2015/presentations/DAY2/2_breaking_the_chain_1_mcelrath.pdf">[40]</a>,  <a href="https://rawgit.com/mcelrath/braidcoin/master/Braid%2BExamples.html">[41]</a>), Jute <a href="https://scalingbitcoin.org/milan2016/presentations/D2%20-%209%20-%20David%20Vorick.pdf">[43]</a>, SPECTRE <a href="http://www.cs.huji.ac.il/%7Eyoni_sompo/pubs/16/SPECTRE_complete.pdf">[46]</a> and PHANTOM <a href="https://docs.wixstatic.com/ugd/242600_92372943016c47ecb2e94b2fc07876d6.pdf">[52]</a> was presented. The principle of DAG in block chain is to present a way to include traditional off-chain blocks into the ledger, which is governed by mathematical rules. A parent that is simultaneously an ancestor of another parent is disallowed</p>
<p><img src="./sources/DAGTopologicalOrdering.PNG" alt="DAGTopologicalOrdering" /></p>
<p>The main problems to be solved by the DAG derivative protocols are <strong>(a)</strong> inclusion of orphaned blocks (decrease the negative effect of slow propagation) and <strong>(b)</strong> mitigation against selfish mining attacks. The underlying concept is still in the research and exploration phase. <a href="https://bitcoinmagazine.com/articles/if-there-is-an-answer-to-selfish-mining-braiding-could-be-it-1482876153">[39]</a></p>
<p><img src="./sources/GHOST.PNG" alt="GHOST" /></p>
<p>In most DAG derivative protocols, blocks containing conflicting transactions (<em>i.e. conflicting blocks</em>) are not orphaned. A subsequent block is built on top of both of the conflicting blocks, but the conflicting transactions themselves are thrown out while processing the chain. SPECTRE, for one, provides a scheme whereby blocks vote to decide which transactions are robustly accepted, robustly rejected or stay in an indefinite “pending” state in case of conflicts. Both conflicting blocks become part of the shared history, and both conflicting blocks earn their respective miners a block reward. (<a href="https://bitcoinmagazine.com/articles/if-there-is-an-answer-to-selfish-mining-braiding-could-be-it-1482876153">[39]</a>, <a href="https://medium.com/@avivzohar/the-spectre-protocol-7dbbebb707b5">[50]</a>, <a href="https://eprint.iacr.org/2016/1159.pdf">[51]</a>)</p>
<p><em><u>Note:</u> Braiding requires that parents and siblings may not contain conflicting transactions.</em></p>
<p><img src="./sources/SPECTRE.PNG" alt="SPECTRE" /></p>
<p>Inclusive (DAG derivative) protocols that integrate the contents of traditional off-chain blocks into the ledger results in incentives for behavior changes by the nodes that lead to an increased throughput, and a better payoff for weak miners. <a href="http://fc15.ifca.ai/preproceedings/paper_101.pdf">[45]</a></p>
<p><img src="./sources/InclusiveProtocolDAG.PNG" alt="InclusiveProtocolDAG" /></p>
<p>DAG derivative protocols are not Layer 2 Scaling solutions, but offer significant scaling of the primary block chain.</p>
<a class="header" href="#who-does-it-9" id="who-does-it-9"><h4>Who does it?</h4></a>
<ul>
<li>The School of Engineering and Computer Science, The Hebrew University of Jerusalem (<a href="https://eprint.iacr.org/2013/881.pdf">[44]</a>, <a href="http://fc15.ifca.ai/preproceedings/paper_101.pdf">[45]</a>, <a href="http://www.cs.huji.ac.il/%7Eyoni_sompo/pubs/16/SPECTRE_complete.pdf">[46]</a>, <a href="https://medium.com/@avivzohar/the-spectre-protocol-7dbbebb707b5">[50]</a>, <a href="https://eprint.iacr.org/2016/1159.pdf">[51]</a>)
<ul>
<li>GHOST, SPECTRE, PHANTOM</li>
</ul>
</li>
<li>DAGlabs <a href="https://www.daglabs.com/">[53]</a>  (<em><u>Note:</u> This is the commercial development chapter.)</em>
<ul>
<li>SPECTRE, PHANTOM
<ul>
<li>SPECTRE provides high throughput and fast confirmation times. Its DAG structure represents an abstract vote regarding the order between each pair of blocks, but this pairwise ordering may not be extendable to a full linear ordering due to possible Condorcet cycles.</li>
<li>PHANTOM provides a linear ordering over the blocks of the DAG and can support consensus regarding any general computation (smart contracts), which SPECTRE cannot. In order for a computation or contract to be processed correctly and consistently, the full order of events in the ledger is required, particularly the order of inputs to the contract. However, PHANTOM’s confirmation times are mush slower than those in SPECTRE.</li>
</ul>
</li>
</ul>
</li>
<li>Ethereum as the Ethash PoW algorithm that has been adapted from GHOST</li>
<li><a href="http://bob.mcelrath.org/resume/">Dr. Bob McElrath</a> (<a href="https://scalingbitcoin.org/hongkong2015/presentations/DAY2/2_breaking_the_chain_1_mcelrath.pdf">[40]</a>, <a href="https://rawgit.com/mcelrath/braidcoin/master/Braid%2BExamples.html">[41]</a>)
<ul>
<li>Brading</li>
</ul>
</li>
<li>David Vorick <a href="https://scalingbitcoin.org/milan2016/presentations/D2%20-%209%20-%20David%20Vorick.pdf">[43]</a>
<ul>
<li>Jute</li>
</ul>
</li>
<li>Crypto currencies:
<ul>
<li>IOTA <a href="https://www.iota.org/">[47]</a></li>
<li>Nano <a href="https://nano.org/en">[48]</a></li>
<li>Byteball <a href="https://byteball.org/">[49]</a></li>
</ul>
</li>
</ul>
<a class="header" href="#strengths-11" id="strengths-11"><h4>Strengths</h4></a>
<ul>
<li><u>Layer 1 scaling:</u> Increased transaction throughput on the main block chain</li>
<li><u>Fairness:</u> Better payoff for weak miners</li>
<li><u>Decentralization mitigation:</u> Weaker miners also get profits</li>
<li><u>Transaction confirmation times:</u> Confirmation times of several seconds (SPECTRE)</li>
<li><u>Smart contracts:</u> Support smart contracts (PHANTOM)</li>
</ul>
<a class="header" href="#weaknesses-11" id="weaknesses-11"><h4>Weaknesses</h4></a>
<ul>
<li>
<p>Still not proven 100%, development continuing.</p>
</li>
<li>
<p>The DAG derivative protocols differ on important aspects like miner payment schemes, security models, support for smart contracts, confirmation times, etc. Thus, all DAG derivative protocols are not created equal, beware!</p>
</li>
</ul>
<a class="header" href="#opportunities-for-tari-11" id="opportunities-for-tari-11"><h4>Opportunities for Tari</h4></a>
<p>Opportunities exist for Tari in applying the basic DAG principles to make a 51% attack harder by virtue of fairness and miner decentralization resistance. Choosing the correct DAG derivative protocol can also significantly improve Layer 1 scaling.</p>
<a class="header" href="#threats-for-tari-9" id="threats-for-tari-9"><h4>Threats for Tari</h4></a>
<p>None</p>
<a class="header" href="#observations-1" id="observations-1"><h2>Observations</h2></a>
<ul>
<li>Although not all technologies covered here are Layer 2 Scaling solutions, the strengths should be considered as building blocks for the Tari protocol.</li>
</ul>
<a class="header" href="#references-7" id="references-7"><h2>References</h2></a>
<p>[1] TumbleBit: An Untrusted Bitcoin-Compatible Anonymous Payment Hub, http://cs-people.bu.edu/heilman/tumblebit, Date accessed: 2018-07-12.</p>
<p>[2] TumbleBit: An Untrusted Bitcoin-Compatible Anonymous Payment Hub, Heilman E. et. el., https://eprint.iacr.org/2016/575.pdf, Date accessed: 2018-07-08.</p>
<p>[3] Anonymous Transactions Coming to Stratis, <a href="https://medium.com/@Stratisplatform/anonymous-transactions-coming-to-stratis-fced3f5abc2e">https://medium.com/@Stratisplatform/anonymous-transactions-coming-to-stratis-fced3f5abc2e</a>, Date accessed: 2018-07-08.</p>
<p>[4] TumbleBit Proof of Concept GitHub Repository, https://github.com/BUSEC/TumbleBit, Date accessed: 2018-07-08.</p>
<p>[5] NTumbleBit GitHub Repository, https://github.com/nTumbleBit/nTumbleBit, Date accessed: 2018-07-12.</p>
<p>[6] Breeze Tumblebit Server Experimental Release, https://stratisplatform.com/2017/07/17/breeze-tumblebit-server-experimental-release, Date accessed: 2018-07-12.</p>
<p>[7] Breeze Wallet with Breeze Privacy Protocol (Dev. Update), https://stratisplatform.com/2017/09/20/breeze-wallet-with-breeze-privacy-protocol-dev-update, Date accessed: 2018-07-12.</p>
<p>[8] Blindly Signed Contracts - Anonymous On-chain and Off-chain Bitcoin Transactions, Heilman E. et. el., https://eprint.iacr.org/2016/056.pdf, Date accessed: 2018-07-12.</p>
<p>[9] Conference: Scaling Bitcoin 2016 Milan, TumbleBit: An Untrusted Bitcoin-Compatible Anonymous Payment Hub - Ethan Heilman &amp; Leen AlShenibr - 08 October 2016, https://www.youtube.com/watch?v=8BLWUUPfh2Q&amp;feature=youtu.be&amp;t=1h3m10s, Date accessed: 2018-07-13.</p>
<p>[10] Better Bitcoin Privacy, Scalability: Developers Making TumbleBit a Reality, https://bitcoinmagazine.com/articles/better-bitcoin-privacy-scalability-developers-are-making-tumblebit-reality, Date accessed: 2018-07-13.</p>
<p>[11] Bitcoinwiki: Contract, https://en.bitcoin.it/wiki/Contract, Date accessed: 2018-07-13.</p>
<p>[12] Bitcoin Privacy is a Breeze: TumbleBit Successfully Integrated Into Breeze, https://stratisplatform.com/2017/08/10/bitcoin-privacy-tumblebit-integrated-into-breeze, Date accessed: 2018-07-13.</p>
<p>[13] TumbleBit Wallet Reaches One Step Forward, https://www.bitcoinmarketinsider.com/tumblebit-wallet-reaches-one-step-forward, Date accessed: 2018-07-13.</p>
<p>[14] A Survey Of Second Layer Solutions For Blockchain Scaling  Part 1, https://www.ethnews.com/a-survey-of-second-layer-solutions-for-blockchain-scaling-part-1, https://www.ethnews.com/a-survey-of-second-layer-solutions-for-blockchain-scaling-part-1, Date accessed: 2018-07-16.</p>
<p>[15] Second-Layer Scaling, https://lunyr.com/article/Second-Layer_Scaling, Date accessed: 2018-07-16.</p>
<p>[16] RSK website, https://www.rsk.co, Date accessed: 2018-07-16.</p>
<p>[17] Lumino Transaction Compression Protocol (LTCP), Lerner S. D., https://uploads.strikinglycdn.com/files/ec5278f8-218c-407a-af3c-ab71a910246d/LuminoTransactionCompressionProtocolLTCP.pdf, Date accessed: 2018-07-16.</p>
<p>[18] Bitcoin-Based Ethereum Rival RSK Set to Launch Next Month, https://cryptonewsmonitor.com/2017/11/11/bitcoin-based-ethereum-rival-rsk-set-to-launch-next-month, Date accessed: 2018-07-16.</p>
<p>[19] RSK Blog website, https://media.rsk.co/, Date accessed: 2018-07-16.</p>
<p>[20] Drivechain: Enabling Bitcoin Sidechain, http://www.drivechain.info, Date accessed: 2018-07-17.</p>
<p>[21] Drivechain - The Simple Two Way Peg, http://www.truthcoin.info/blog/drivechain, Date accessed: 2018-07-17.</p>
<p>[22] Sidechains, Drivechains, and RSK 2-Way peg Design, https://www.rsk.co/blog/sidechains-drivechains-and-rsk-2-way-peg-design or https://uploads.strikinglycdn.com/files/27311e59-0832-49b5-ab0e-2b0a73899561/Drivechains_Sidechains_and_Hybrid_2-way_peg_Designs_R9.pdf, Date accessed: 2018-07-18.</p>
<p>[23] Pay to script hash, https://en.bitcoin.it/wiki/Pay_to_script_hash, Date accessed: 2018-07-18.</p>
<p>[24] Hivemind website, http://bitcoinhivemind.com, Date accessed: 2018-07-18.</p>
<p>[25] Drivechains: What do they enable? Cloud 3.0 Services Smart Contracts and Scalability, http://drivechains.org/what-are-drivechains/what-does-it-enable, Date accessed: 2018-07-19.</p>
<p>[26] Bloq’s Paul Sztorc on the 4 Main Benefits of Sidechains, https://bitcoinmagazine.com/articles/bloq-s-paul-sztorc-on-the-main-benefits-of-sidechains-1463417446, Date accessed: 2018-07-19.</p>
<p>[27] Blockstream website, https://blockstream.com/technology, Date accessed: 2018-07-19.</p>
<p>[28] Enabling Blockchain Innovations with Pegged Sidechains, Back A. et al., 2014-10-22, https://blockstream.com/technology/sidechains.pdf, Date accessed: 2018-07-19.</p>
<p>[29] Strong Federations: An Interoperable Blockchain Solution to Centralized Third Party Risks, Dilley J. et al., https://blockstream.com/strong-federations.pdf, Date accessed: 2018-07-19.</p>
<p>[30] CounterpartyXCP/Documentation/Smart Contracts/EVM FAQ, https://github.com/CounterpartyXCP/Documentation/blob/master/Basics/FAQ-SmartContracts.md, Date accessed: 2018-07-23.</p>
<p>[31] Counterparty Development 101, <a href="https://medium.com/@droplister/counterparty-development-101-2f4d9b0c8df3">[https://medium.com/@droplister/counterparty-development-101-2f4d9b0c8df3]</a>, Date accessed: 2018-07-23.</p>
<p>[32]  Counterparty website, https://counterparty.io, Date accessed: 2018-07-24.</p>
<p>[33] COVAL website, https://coval.readme.io/docs, Date accessed: 2018-07-24.</p>
<p>[34] Scriptless Scripts: How Bitcoin Can Support Smart Contracts Without Smart Contracts, https://bitcoinmagazine.com/articles/scriptless-scripts-how-bitcoin-can-support-smart-contracts-without-smart-contracts, Date accessed: 2018-07-24.</p>
<p>[35] Key Aggregation for Schnorr Signatures, https://blockstream.com/2018/01/23/musig-key-aggregation-schnorr-signatures.html, Date accessed: 2018-07-24.</p>
<p>[36] Simple Schnorr Multi-Signatures with Applications to Bitcoin, Maxwell G. et al., 20 May 2018, https://eprint.iacr.org/2018/068.pdf, Date accessed: 2018-07-24.</p>
<p>[37] Scriptless Scripts, Poelstra A., 4 March 2017  https://download.wpsoftware.net/bitcoin/wizardry/mw-slides/2017-03-mit-bitcoin-expo/slides.pdf, Date accessed: 2018-07-24.</p>
<p>[38] bip-schnorr.mediawiki, https://github.com/sipa/bips/blob/bip-schnorr/bip-schnorr.mediawiki, Date accessed: 2018-07-26.</p>
<p>[39] If There Is an Answer to Selfish Mining, Braiding Could Be It, https://bitcoinmagazine.com/articles/if-there-is-an-answer-to-selfish-mining-braiding-could-be-it-1482876153, Date accessed: 2018-07-27.</p>
<p>[40] Braiding the Blockchain, McElrath B., Scaling Bitcoin, Hong Kong, 7 Dec 2015,  https://scalingbitcoin.org/hongkong2015/presentations/DAY2/2_breaking_the_chain_1_mcelrath.pdf, Date accessed: 2018-07-27.</p>
<p>[41] Braid Examples, https://rawgit.com/mcelrath/braidcoin/master/Braid%2BExamples.html, Date accessed: 2018-07-27.</p>
<p>[42] Directed acyclic graph, https://en.wikipedia.org/wiki/Directed_acyclic_graph, Date accessed: 2018-07-30.</p>
<p>[43] Braiding Techniques to Improve Security and Scaling, https://scalingbitcoin.org/milan2016/presentations/D2%20-%209%20-%20David%20Vorick.pdf, Date accessed: 2018-07-30.</p>
<p>[44] GHOST: Secure High-Rate Transaction Processing in Bitcoin, Sompolinsky Y et al., https://eprint.iacr.org/2013/881.pdf, Date accessed: 2018-07-30.</p>
<p>[45] Inclusive Block Chain Protocols, Lewenberg Y et al., http://fc15.ifca.ai/preproceedings/paper_101.pdf, Date accessed: 2018-07-30.</p>
<p>[46] SPECTRE: A Fast and Scalable Cryptocurrency Protocol, Sompolinsky Y et al., http://www.cs.huji.ac.il/~yoni_sompo/pubs/16/SPECTRE_complete.pdf, Date accessed: 2018-07-30.</p>
<p>[47] IOTA website, https://www.iota.org/, Date accessed: 2018-07-30.</p>
<p>[48] NANO, https://nano.org/en, Date accessed: 2018-07-30.</p>
<p>[49] Byteball, https://byteball.org/, Date accessed: 2018-07-30.</p>
<p>[50] SPECTRE: Serialization of Proof-of-Work Events, Confirming Transactions via Recursive Elections, <a href="https://medium.com/@avivzohar/the-spectre-protocol-7dbbebb707b5">[https://medium.com/@avivzohar/the-spectre-protocol-7dbbebb707b5]</a>, Date accessed: 2018-07-30.</p>
<p>[51] SPECTRE: Serialization of Proof-of-work Events: Confirming Transactions via Recursive Elections, Sompolinsky  Y et al., https://eprint.iacr.org/2016/1159.pdf, Date accessed: 2018-07-30.</p>
<p>[52] PHANTOM: A Scalable BlockDAG protocol, Sompolinsky Y. et. al., https://docs.wixstatic.com/ugd/242600_92372943016c47ecb2e94b2fc07876d6.pdf, Date accessed: 2018-07-30.</p>
<p>[53] DAGLabs website, https://www.daglabs.com, Date accessed: 2018-07-30.</p>
<p>[54] Beyond distributed and decentralized: what is a federated network?, http://networkcultures.org/unlikeus/resources/articles/what-is-a-federated-network, Date accessed: 2018-08-13.</p>
<p>[55] Federated Byzantine Agreement, https://towardsdatascience.com/federated-byzantine-agreement-24ec57bf36e0, Date accessed: 2018-08-13.</p>
<p>[56] Counterparty Documentation: Frequently Asked Questions, https://counterparty.io/docs/faq, Date accessed: 2018-09-14.</p>
<p>[57] Counterparty Documentation: Protocol Specification, https://counterparty.io/docs/protocol_specification, Date accessed: 2018-09-14.</p>
<p>[58] Counterparty News:  Why Proof-of-Burn, March 23, 2014 , https://counterparty.io/news/why-proof-of-burn, Date accessed: 2018-09-14.</p>
<a class="header" href="#contributors-3" id="contributors-3"><h2>Contributors</h2></a>
<ul>
<li><a href="https://github.com/hansieodendaal">https://github.com/hansieodendaal</a></li>
<li><a href="https://github.com/ksloven">https://github.com/ksloven</a></li>
<li><a href="https://github.com/robby-dermody">https://github.com/robby-dermody</a></li>
</ul>
<a class="header" href="#layer-2-scaling---executive-summary" id="layer-2-scaling---executive-summary"><h1>Layer 2 Scaling - Executive Summary</h1></a>
<iframe width=750 height=600 src="https://gitpitch.com/tari-labs/tari-university/master?p=/src/layer2scaling/executive-summary#/"></iframe>
<a class="header" href="#having-trouble-viewing-this-presentation-2" id="having-trouble-viewing-this-presentation-2"><h3>Having trouble viewing this presentation?</h3></a>
<p>View it in a <a href="https://gitpitch.com/tari-labs/tari-university/master?p=/src/layer2scaling/executive-summary#/">separate window</a>.</p>
<a class="header" href="#merged-mining" id="merged-mining"><h1>Merged Mining</h1></a>
<p>From <a href="https://en.bitcoin.it/wiki/Merged_mining_specification"><u><strong>Bitcoin Wiki</strong></u></a></p>
<p>Merged mining is the act of using work done on another block chain (the Parent) on one or more Auxiliary block chains and to accept it as valid on its own chain, using Auxiliary Proof-of-Work (AuxPoW), which is the relationship between two block chains for one to trust the other's work as their own. The Parent block chain does not need to be aware of the AuxPoW logic as blocks submitted to it are still valid blocks.</p>
<p>From <a href="https://www.cryptocompare.com/mining/guides/what-is-merged-mining-bitcoin-namecoin-litecoin-dogecoin/"><u><strong>CryptoCompare</strong></u></a></p>
<p>Merged mining is the process of allowing two different crypto currencies based on the same algorithm to be mined simultaneously. This allows low hash powered crypto currencies to increase the hashing power behind their network by bootstrapping onto more popular crypto currencies.</p>
<a class="header" href="#merged-mining-introduction" id="merged-mining-introduction"><h1>Merged Mining Introduction</h1></a>
<a class="header" href="#what-is-merged-mining" id="what-is-merged-mining"><h2>What is merged mining?</h2></a>
<p>Merged mining is the act of using work done on another block chain (the Parent) on one or more Auxiliary block chains and to accept it as valid on its own chain, using Auxiliary Proof-of-Work (AuxPoW), which is the relationship between two block chains for one to trust the other's work as their own. The Parent block chain does not need to be aware of the AuxPoW logic as blocks submitted to it are still valid blocks. <a href="https://en.bitcoin.it/wiki/Merged_mining_specification">[1]</a></p>
<p>As an example the structure of merged mined blocks in Namecoin and Bitcoin is shown below. <a href="http://repositum.tuwien.ac.at/obvutwhs/download/pdf/2315652">[25]</a></p>
<p><img src="./sources/MergedMiningIntro01.png" alt="MergedMiningIntro01" /></p>
<p>A transaction set for both block chains are assembled. The hash of the AuxPoW block header is then inserted in the 'free' bytes region (coinbase field) of the coinbase transaction and submitted to the Parent block chain's Proof-of-Work (PoW). If the merge miner solves the block at the difficulty level of either or both block chains the respective block(s) are re-assembled with the completed PoW and submitted to the correct block chain. In case of the Auxiliary block chain the Parent's block hash, Merkle tree branch and coinbase transaction are inserted in the Auxiliary block's AuxPoW header. This is to prove that enough work was done on the Parent block chain that meets the difficulty level of the Auxiliary block chain. (<a href="https://en.bitcoin.it/wiki/Merged_mining_specification">[1]</a>, <a href="https://bitcoin.stackexchange.com/questions/273/how-does-merged-mining-work">[2]</a>, <a href="http://repositum.tuwien.ac.at/obvutwhs/download/pdf/2315652">[25]</a>)</p>
<p>The propagation of Parent and Auxiliary blocks are totally independent and only governed by each chain's difficulty level. As an example the diagram below shows how this can play out in practice with Namecoin and Bitcoin when the Parent difficulty (D<sub>BTC</sub>) is larger than the Auxiliary difficulty (D<sub>NMC</sub>) . Note that <em>BTC block 2'</em> did not become part of the Parent block chain propagation.</p>
<p><img src="./sources/MergedMiningIntro02.png" alt="MergedMiningIntro02" /></p>
<a class="header" href="#merged-mining-with-multiple-auxiliary-chains" id="merged-mining-with-multiple-auxiliary-chains"><h2>Merged mining with multiple Auxiliary chains</h2></a>
<p>A miner can use a single Parent to perform merged mining on multiple Auxiliary block chains. The Merkle tree root of a Merkle tree that contains the block hashes of the Auxiliary blocks as leaves must then be inserted in the Parent's coinbase field as shown below. To prevent double spending attacks each Auxiliary block chain must specify a unique ID that can be used to derive the leave of the Merkle tree where the respective block hash must be located. <a href="http://repositum.tuwien.ac.at/obvutwhs/download/pdf/2315652">[25]</a></p>
<p><img src="./sources/MergedMiningIntro03.png" alt="MergedMiningIntro03" /></p>
<a class="header" href="#merged-mining-interesting-facts-case-studies" id="merged-mining-interesting-facts-case-studies"><h2>Merged mining interesting facts, case studies</h2></a>
<a class="header" href="#namecoin-307-with-bitcoin-1" id="namecoin-307-with-bitcoin-1"><h3>Namecoin (#307) with Bitcoin (#1)</h3></a>
<ul>
<li>Namecoin, the first fork of Bitcoin, introduced merged mining with Bitcoin <a href="https://en.bitcoin.it/wiki/Merged_mining_specification">[1]</a> from block 19,200 onwards <a href="https://github.com/namecoin/wiki/blob/master/Merged-Mining.mediawiki">[3]</a>. Namecoin current block height is &gt;400,500 (@ 2018/05/28) <a href="https://bchain.info/NMC">[4]</a>.</li>
<li>Over the 5 day period of 23-27/05/2018 only 226 out of 752 blocks posted transaction values over and above the block reward of 25 NMC, with an average transaction value of 159.231 NMC including the block reward. <a href="https://bchain.info/NMC">[4]</a></li>
<li>Slush Pool merged mining Namecoin with Bitcoin rewards all miners with BTC equivalent to NMC via external exchange service. <a href="https://slushpool.com/help/first-aid/faq-merged-mining">[5]</a></li>
<li>P2pool, Multipool, Slush Pool, Eligius and F2pool are cited as top Namecoin merged mining pools. <a href="https://www.prooworld.com/namecoin/best-namecoin-mining-pools">[6]</a></li>
</ul>
<table><thead><tr><th> @ 2018-05-30          </th><th> Bitcoin <a href="https://bitinfocharts.com">[16]</a> </th><th> Namecoin <a href="https://bitinfocharts.com">[16]</a> </th><th> Ratio   </th></tr></thead><tbody>
<tr><td> Block time target (s) </td><td> 600                                       </td><td> 600                                        </td><td> 100.00% </td></tr>
<tr><td> Hashrate (Ehash/s)    </td><td> 31.705                                    </td><td> 21.814                                     </td><td> 68.80%  </td></tr>
<tr><td> Blocks count          </td><td> 525064                                    </td><td> 400794                                     </td><td> 76.33%  </td></tr>
</tbody></table>
<a class="header" href="#dogecoin-37-with-litecoin-6" id="dogecoin-37-with-litecoin-6"><h3>Dogecoin (#37) with Litecoin (#6)</h3></a>
<ul>
<li>Dogecoin introduced merged mining with Litecoin <a href="https://www.reddit.com/r/dogecoin/comments/22niq9/merged_mining_amafaq">[8]</a> from block 371,337 onwards <a href="https://www.reddit.com/r/dogecoin/comments/2fyxg1/the_forkening_is_happening_at_900am_est_a_couple">[9]</a>. Dogecoin current block height is &gt;2,240,000 (@ 2018/05/29) <a href="https://dogechain.info">[10]</a>.</li>
<li>Many in the Dogecoin user community believe merged mining with Litecoin saved Dogecoin from a 51% attack. <a href="https://www.reddit.com/r/dogecoin/comments/22niq9/merged_mining_amafaq">[8]</a></li>
</ul>
<table><thead><tr><th> @ 2018-05-30          </th><th> Litecoin <a href="https://bitinfocharts.com">[16]</a> </th><th> Dogecoin <a href="https://bitinfocharts.com">[16]</a> </th><th> Ratio   </th></tr></thead><tbody>
<tr><td> Block time target (s) </td><td> 150                                        </td><td> 60                                         </td><td> 40.00%  </td></tr>
<tr><td> Hashrate (Thash/s)    </td><td> 311.188                                    </td><td> 235.552                                    </td><td> 75.69%  </td></tr>
<tr><td> Blocks count          </td><td> 1430517                                    </td><td> 2241120                                    </td><td> 156.67% </td></tr>
</tbody></table>
<a class="header" href="#huntercoin-779-with-bitcoin-1-or-litecoin-6" id="huntercoin-779-with-bitcoin-1-or-litecoin-6"><h3>Huntercoin (#779) with Bitcoin (#1) or Litecoin (#6)</h3></a>
<ul>
<li>Huntercoin was released as a live experimental test to see how blockchain technology could handle full on game worlds. <a href="http://huntercoin.org/">[22]</a></li>
<li>Huntercoin was originally designed to be supported for only 1 year, but development and support will continue. <a href="http://huntercoin.org/">[22]</a></li>
<li>Players are awarded coins for gaming, thus world's first human mineable cryptocurrency.</li>
<li>Coin distribution: 10 coins per block, 9 for the game world and 1 for the miners. <a href="http://huntercoin.org/">[22]</a></li>
</ul>
<table><thead><tr><th> @ 2018-06-01                      </th><th> Huntercoin     </th></tr></thead><tbody>
<tr><td> Block time target (s)             </td><td> 120            </td></tr>
<tr><td> Block chain size (GB)             </td><td> 17             </td></tr>
<tr><td> Pruned block chain size (GB)      </td><td> 0.5            </td></tr>
<tr><td> Blocks count                      </td><td> 2291060        </td></tr>
<tr><td> PoW Algorithm (for merged mining) </td><td> SHA256, Scrypt </td></tr>
</tbody></table>
<a class="header" href="#myriad-510-with-bitcoin-1-or-litecoin-6" id="myriad-510-with-bitcoin-1-or-litecoin-6"><h3>Myriad (#510) with Bitcoin (#1) or Litecoin (#6)</h3></a>
<ul>
<li>Myriad is the first currency to support 5 PoW algorithms and claims their multi PoW algorithm approach offers exceptional 51% resistance. <a href="http://myriadcoin.org/">[23]</a></li>
<li>Myriad introduced merged mining from block 1,402,791 onwards. <a href="https://eprint.iacr.org/2017/791.pdf">[24]</a></li>
</ul>
<table><thead><tr><th> @ 2018-06-01                      </th><th> Myriad                       </th></tr></thead><tbody>
<tr><td> Block time target (s)             </td><td> 60                           </td></tr>
<tr><td> Block chain size (GB)             </td><td> 2.095                        </td></tr>
<tr><td> Blocks count                      </td><td> 2442829                      </td></tr>
<tr><td> PoW Algorithm (for merged mining) </td><td> SHA256d, Scrypt              </td></tr>
<tr><td> PoW Algorithm (others)            </td><td> Myr-Groestl, Skein, Yescrypt </td></tr>
</tbody></table>
<ul>
<li>
<p>Some solved multi-PoW block examples below:</p>
<ul>
<li><img src="./sources/Myriad-1.png" alt="Myriad-1" /></li>
<li><img src="./sources/Myriad-2.png" alt="Myriad-2" /></li>
<li><img src="./sources/Myriad-3.png" alt="Myriad-3" /></li>
</ul>
</li>
</ul>
<a class="header" href="#monero-12--digitalnote-166--fantomcoin-1068" id="monero-12--digitalnote-166--fantomcoin-1068"><h3>Monero (#12) / DigitalNote (#166) + FantomCoin (#1068)</h3></a>
<ul>
<li>
<p>FantamCoin was the 1st CryptoNote based coin to develop merged mining with Monero, but was abandoned until DigitalNote developers became interested in merged mining with Monero and revived FantamCoin in the October 2016 (<a href="https://minergate.com/blog/merged-mining-with-monero">[17]</a>, <a href="https://bitcointalk.org/index.php?topic=1082745.msg16615346#msg16615346">[18]</a>, <a href="https://github.com/xdn-project">[19]</a>).</p>
</li>
<li>
<pre><code class="language-text">FantamCoin Release notes 2.0.0
- Fantomcoin 2.0 by XDN-project, major FCN update to the latest
  cryptonotefoundation codebase 
- New FCN+XMR merged merged mining 
- Default block size - 100Kb

DigitalNote Release notes 4.0.0-beta
- EmPoWering XDN network security with merged mining with any CryptoNote 
  cryptocurrency
- Second step to the PoA with the new type of PoW merged mining blocks
</code></pre>
</li>
<li>
<p>DigitalNote and FantomCoin merged mining with Monero are now stuck with the recent CryptoNight based Monero forks like Monero Classic and Monero Original after Monero's recent hard fork to CryptoNight v7. (See Attack Vectors)</p>
</li>
</ul>
<table><thead><tr><th> @ 2018-05-31          </th><th> Monero <a href="https://bitinfocharts.com">[16]</a> </th><th> DigitalNote <a href="https://bitinfocharts.com">[16]</a> </th><th> Ratio   </th></tr></thead><tbody>
<tr><td> Block time target (s) </td><td> 120                                      </td><td> 240                                           </td><td> 200.00% </td></tr>
<tr><td> Hashrate (Mhash/s)    </td><td> 410.804                                  </td><td> 13.86                                         </td><td> 3.37%   </td></tr>
<tr><td> Blocks count          </td><td> 1583869                                  </td><td> 660075                                        </td><td> 41.67%  </td></tr>
</tbody></table>
<table><thead><tr><th> @ 2018-05-31          </th><th> Monero <a href="https://bitinfocharts.com">[16]</a> </th><th> FantomCoin <a href="https://bitinfocharts.com">[16]</a> </th><th> Ratio   </th></tr></thead><tbody>
<tr><td> Block time target (s) </td><td> 120                                      </td><td> 60                                           </td><td> 50.00%  </td></tr>
<tr><td> Hashrate (Mhash/s)    </td><td> 410.804                                  </td><td> 19.29                                        </td><td> 4.70%   </td></tr>
<tr><td> Blocks count          </td><td> 1583869                                  </td><td> 2126079                                      </td><td> 134.23% </td></tr>
</tbody></table>
<a class="header" href="#some-stats" id="some-stats"><h3>Some stats</h3></a>
<ul>
<li>
<p>Merge-mined blocks in some cryptocurrencies at 2017/06/18 <a href="https://eprint.iacr.org/2017/791.pdf">[24]</a>:</p>
<p><img src="./sources/MergedMiningStats-1.png" alt="MergedMiningStats-1" /></p>
</li>
</ul>
<a class="header" href="#observations-2" id="observations-2"><h3>Observations</h3></a>
<ul>
<li>The Auxiliary block chain's target block times can be smaller, equal or larger than the Parent block chain.</li>
<li>The Auxiliary block chain's hash rate is generally smaller but in the same order of magnitude as that of the Parent block chain.</li>
<li>A multi PoW algorithm approach may further enhance 51% resistance.</li>
</ul>
<a class="header" href="#attack-vectors" id="attack-vectors"><h2>Attack Vectors</h2></a>
<ul>
<li>
<a class="header" href="#a51-attacks" id="a51-attacks"><h3>51% attacks</h3></a>
<ul>
<li>51% attacks are real and relevant today. Bitcoin Gold (rank #28 @ 2018/05/29) and Verge (rank #33 @ 2018/05/29) suffered recent attacks with double spend transactions following. (<a href="https://www.ccn.com/bitcoin-gold-hit-by-double-spend-attack-exchanges-lose-millions">[11]</a>, <a href="https://www.ccn.com/privacy-coin-verge-succumbs-to-51-attack-again">[12]</a>)</li>
<li>In a conservative analysis, successful attacks on PoW cryptocurrencies are more likely when dishonest entities control more than 25% of the total mining power. <a href="https://eprint.iacr.org/2017/791.pdf">[24]</a></li>
<li>Tari tokens are envisaged to be merged mined with Monero <a href="https://www.tari.com">[13]</a>, as such the Monero block chain security is important to the Tari block chain.</li>
<li>Monero recently (2018-04-06) introduced a hard fork with upgraded PoW algorithm CryptoNight v7 at block height 1546000 to maintain their Application Specific Integrated Circuit (ASIC) resistance and hence guard against 51% attacks. The Monero team proposes changes to their PoW every scheduled fork (i.e. every 6 months) going forward. (<a href="https://www.ccn.com/monero-hard-forks-to-maintain-asic-resistance-but-classic-hopes-to-spoil-the-party">[14]</a>, <a href="https://getmonero.org/2018/02/11/pow-change-and-key-reuse.html">[15]</a>)</li>
<li>An interesting question arises what needs to happen to the Tari block chain if the Monero block chain is hard forked. Since the CryptoNight v7 hard fork the network hash rate for Monero hovers around ~500 MH/s, whereas in the two months immediately prior it was ~1,000 MH/s <a href="https://chainradar.com/xmr/chart">[20]</a>. Thus 50% of the hash power can be ascribed to ASICS and botnet miners.</li>
<li><img src="./sources/MoneroHashRate.png" alt="MoneroHashRate" /></li>
<li>NiceHash statistics for CryptoNight v7 <a href="https://www.nicehash.com/algorithm/cryptonightv7">[21]</a> shows a lag of 2 days for ~ 100,600 miners to get up to speed with providing the new hashing power after the Monero hard fork.</li>
<li><img src="./sources/CryptoNight-v7.png" alt="CryptoNight-v7" /></li>
<li>The Tari block chain will have to fork together with or just after a scheduled Monero fork. The Tari block chain will be vulnerable to ASIC miners until it has been forked.</li>
</ul>
</li>
<li>
<a class="header" href="#double-proof" id="double-proof"><h3>Double proof</h3></a>
<ul>
<li>A miner could cheat the PoW system by putting more than one Auxiliary block header into one Parent block <a href="https://en.bitcoin.it/wiki/Alternative_chain#Protecting_against_double_proof">[7]</a>.</li>
<li>Multiple Auxiliary blocks can be competing for the same PoW, and could subject your Auxiliary block chain to nothing-at-stake attacks if the chain is forked, maliciously or by accident, with consequent attempts to reverse transactions. (<a href="https://en.bitcoin.it/wiki/Alternative_chain#Protecting_against_double_proof">[7]</a>, <a href="https://github.com/ethereum/wiki/wiki/Problems">[26]</a>)</li>
<li>More than one Auxiliary block chain will be merged mined with Monero.</li>
</ul>
</li>
<li>
<a class="header" href="#analysis-of-mining-power-centralisation-issues-a-hrefhttpseprintiacrorg2017791pdf24a-a-hrefhttprepositumtuwienacatobvutwhsdownloadpdf231565225a" id="analysis-of-mining-power-centralisation-issues-a-hrefhttpseprintiacrorg2017791pdf24a-a-hrefhttprepositumtuwienacatobvutwhsdownloadpdf231565225a"><h3>Analysis of Mining Power Centralisation Issues (<a href="https://eprint.iacr.org/2017/791.pdf">[24]</a>, <a href="http://repositum.tuwien.ac.at/obvutwhs/download/pdf/2315652">[25]</a>)</h3></a>
<ul>
<li>In Namecoin F2Pool reached and maintained a majority of the mining power for prolonged periods.</li>
<li>Litecoin has experienced slight centralisation since mid-2014, among others caused by Clevermining and F2Pool.</li>
<li>In Dogecoin F2Pool was responsible for generating more than 33% of the blocks per day for significant periods, even exceeding the 50% threshold around the end of 2016.</li>
<li>Huntercoin was instantly dominated by F2Pool and remained in this state until mid-2016.</li>
<li>Myriadcoin appears to have experienced only a moderate impact.  Multi-merge-mined blockchains allow for more than one parent cryptocurrency and have a greater chance to acquire a higher difficulty per PoW algorithm, in comparison to the respective parent blockchain.</li>
<li>Distribution of overall percentage of days below/above the centralization indicator thresholds at 2017/06/18:
<img src="./sources/MergedMiningStats-2.png" alt="MergedMiningStats-2" /></li>
</ul>
</li>
<li>
<a class="header" href="#introduction-of-new-attack-vectors-a-hrefhttpseprintiacrorg2017791pdf24a-a-hrefhttprepositumtuwienacatobvutwhsdownloadpdf231565225a" id="introduction-of-new-attack-vectors-a-hrefhttpseprintiacrorg2017791pdf24a-a-hrefhttprepositumtuwienacatobvutwhsdownloadpdf231565225a"><h3>Introduction of New Attack Vectors (<a href="https://eprint.iacr.org/2017/791.pdf">[24]</a>, <a href="http://repositum.tuwien.ac.at/obvutwhs/download/pdf/2315652">[25]</a>)</h3></a>
<ul>
<li>Miners can generate blocks for the merge-mined child blockchains at almost no additional cost, enabling attacks without risking financial losses.</li>
<li>Merged mining as an attack vector works both ways as parent cryptocurrencies cannot easily prevent being mergemined by auxiliary block chains.</li>
<li>Merged mining can increase the hash rate of auxiliary blockchains, but it is not conclusively successful as a bootstrapping technique.</li>
<li>Empirical evidence suggests that only a small number of mining pools is involved in merged mining and those enjoy block shares beyond the desired security and decentralization goals.</li>
</ul>
</li>
</ul>
<a class="header" href="#references-8" id="references-8"><h2>References</h2></a>
<p>[1] Merged mining specification, https://en.bitcoin.it/wiki/Merged_mining_specification, Accessed: 2018-05-28.</p>
<p>[2] How does merged mining work?, https://bitcoin.stackexchange.com/questions/273/how-does-merged-mining-work, Accessed: 2018-05-28.</p>
<p>[3] Merged-Mining.mediawiki, https://github.com/namecoin/wiki/blob/master/Merged-Mining.mediawiki, Accessed: 2018-05-28.</p>
<p>[4] Bchain.info - Blockchain Explorer (NMC), https://bchain.info/NMC, Accessed: 2018-05-28.</p>
<p>[5] SlushPool merged mining, https://slushpool.com/help/first-aid/faq-merged-mining, Accessed: 2018-05-28.</p>
<p>[6] 5 Best Namecoin Mining Pools of 2018 (Comparison), https://www.prooworld.com/namecoin/best-namecoin-mining-pools, Accessed: 2018-05-28.</p>
<p>[7] Alternative chain, https://en.bitcoin.it/wiki/Alternative_chain#Protecting_against_double_proof, Accessed: 2018-05-28.</p>
<p>[8] Merged Mining AMA/FAQ, https://www.reddit.com/r/dogecoin/comments/22niq9/merged_mining_amafaq, Accessed: 2018-05-29.</p>
<p>[9] The Forkening is happening at ~9:00AM EST, https://www.reddit.com/r/dogecoin/comments/2fyxg1/the_forkening_is_happening_at_900am_est_a_couple, Accessed: 2018-05-29.</p>
<p>[10] Dogecoin blockchain explorer, https://dogechain.info,  Accessed: 2018-05-29.</p>
<p>[11] Bitcoin Gold Hit by Double Spend Attack, Exchanges Lose Millions, https://www.ccn.com/bitcoin-gold-hit-by-double-spend-attack-exchanges-lose-millions,  Accessed: 2018-05-29.</p>
<p>[12] Privacy Coin Verge Succumbs to 51% Attack [Again], https://www.ccn.com/privacy-coin-verge-succumbs-to-51-attack-again, Accessed: 2018-05-29.</p>
<p>[13] Tari official website, https://www.tari.com, Accessed: 2018-05-29.</p>
<p>[14] Monero Hard Forks to Maintain ASIC Resistance, But ‘Classic’ Hopes to Spoil the Party, https://www.ccn.com/monero-hard-forks-to-maintain-asic-resistance-but-classic-hopes-to-spoil-the-party, Accessed: 2018-05-29.</p>
<p>[15] PoW change and key reuse, https://getmonero.org/2018/02/11/pow-change-and-key-reuse.html, Accessed: 2018-05-29.</p>
<p>[16] BitInfoCharts, https://bitinfocharts.com, Accessed: 2018-05-30.</p>
<p>[17] Merged mining with Monero, https://minergate.com/blog/merged-mining-with-monero, Accessed: 2018-05-30.</p>
<p>[18] ANN DigitalNote |XDN| - ICCO Announce - NEWS, https://bitcointalk.org/index.php?topic=1082745.msg16615346#msg16615346, Accessed: 2018-05-31.</p>
<p>[19] DigitalNote xdn-project, https://github.com/xdn-project, Accessed: 2018-05-31.</p>
<p>[20] Monero charts, https://chainradar.com/xmr/chart, Accessed: 2018-05-31.</p>
<p>[21] Nicehash statistics for CryptoNight v7, https://www.nicehash.com/algorithm/cryptonightv7, Accessed: 2018-05-31.</p>
<p>[22] Huntercoin: A Blockchain based Game World, http://huntercoin.org, Accessed: 2018-06-01.</p>
<p>[23] Myriad: A Coin For Everyone, http://myriadcoin.org, Accessed: 2018-06-01.</p>
<p>[24] Merged Mining: Curse or Cure?,  https://eprint.iacr.org/2017/791.pdf, Judmayer et. al., Data Privacy Management, Cryptocurrencies and block chain Technology: ESORICS 2017 International Workshops, DPM 2017 and CBT 2017, Oslo, Norway, September 14-15, 2017, Proceedings (pp.316-333).</p>
<p>[25] Merged Mining: Analysis of Effects and Implications,  http://repositum.tuwien.ac.at/obvutwhs/download/pdf/2315652, Zamyatin Alexei, MSc Thesis, Faculty of Informatics at the Technische Universität Wien.</p>
<p>[26] Problems - Consensus - 8. Proof of Stake, https://github.com/ethereum/wiki/wiki/Problems, Accessed: 2018-06-05.</p>
<a class="header" href="#non-fungible-tokens" id="non-fungible-tokens"><h1>Non-fungible Tokens</h1></a>
<p>From <a href="https://en.wikipedia.org/wiki/Non-fungible_token"><u><strong>Wikipedia</strong></u></a></p>
<p>A non-fungible token (NFT) is a special type of cryptographic token which represents something unique; non-fungible tokens are thus not interchangeable. This is in contrast to cryptocurrencies like Bitcoin, and many network or utility tokens that are fungible in nature. NFTs are used to create verifiable digital scarcity, for example in several specific applications that require unique digital items like crypto-collectibles and crypto-gaming.</p>
<p>From <a href="https://btcmanager.com/non-fungible-tokens/"><u><strong>BTC Manager</strong></u></a></p>
<p>A non-fungible tokens (NFT) are blockchain tokens that are designed to be wholly and distinguishable from each other. Using unique metadata, avatars, individual token IDs, and custody chains, NFTs are created to ensure that no two NFT tokens are identical. This is because they exist to store information rather than value, unlike their fungible counterparts.</p>
<a class="header" href="#non-fungible-tokens-1" id="non-fungible-tokens-1"><h1>Non-Fungible Tokens</h1></a>
<iframe width=750 height=600 src="https://gitpitch.com/tari-labs/tari-university/master?p=/src/non-fungible-tokens/nft-landscape-1#/"></iframe>
<a class="header" href="#having-trouble-viewing-this-presentation-3" id="having-trouble-viewing-this-presentation-3"><h3>Having trouble viewing this presentation?</h3></a>
<p>View it in a <a href="https://gitpitch.com/tari-labs/tari-university/master?p=/src/non-fungible-tokens/nft-landscape-1#/">separate window</a>.</p>
<a class="header" href="#block-chain-related-protocols" id="block-chain-related-protocols"><h1>Block Chain Related Protocols</h1></a>
<p>From <a href="https://en.wikipedia.org/wiki/Blockchain"><u><strong>Wikipedia - 1</strong></u></a></p>
<p>A block chain is a growing list of records, called blocks, which are linked using cryptography. Each block contains a cryptographic hash of the previous block, a timestamp, and transaction data (generally represented as a merkle tree root hash).</p>
<p>From <a href="https://en.wikipedia.org/wiki/Cryptographic_protocol"><u><strong>Wikipedia - 2</strong></u></a></p>
<p>A security protocol (cryptographic protocol or encryption protocol) is an abstract or concrete protocol that performs a security-related function and applies cryptographic methods, often as sequences of cryptographic primitives. A protocol describes how the algorithms should be used. A sufficiently detailed protocol includes details about data structures and representations, at which point it can be used to implement multiple, interoperable versions of a program.</p>
<p>From <a href="https://medium.com/market-protocol/blockchain-crash-course-protocols-dapps-apis-and-dexs-4c324964f9c2"><u><strong>Market Protocol</strong></u></a></p>
<p>A protocol can be seen as a methodology agreed upon by two or more parties that establish a common set of rules that they can agree upon so as to enter into a binding agreement. Protocols are therefore the set of rules that govern the network. Block chain protocols usually include rules about consensus, transaction validation, and network participation.</p>
<p>From <a href="https://www.britannica.com/technology/protocol-computer-science"><u><strong>Encyclopaedia Britannica</strong></u></a></p>
<p>Protocol, in computer science, is a set of rules or procedures for transmitting data between electronic devices, such as computers. In order for computers to exchange information, there must be a preexisting agreement as to how the information will be structured and how each side will send and receive it. Without a protocol, a transmitting computer, for example, could be sending its data in 8-bit packets while the receiving computer might expect the data in 16-bit packets.</p>
<a class="header" href="#mimblewimble" id="mimblewimble"><h1>Mimblewimble</h1></a>
<iframe width=750 height=600 src="https://gitpitch.com/tari-labs/tari-university/master?p=/src/protocols/mimblewimble-1#/"></iframe>
<a class="header" href="#having-trouble-viewing-this-presentation-4" id="having-trouble-viewing-this-presentation-4"><h3>Having trouble viewing this presentation?</h3></a>
<p>View it in a <a href="https://gitpitch.com/tari-labs/tari-university/master?p=/src/protocols/mimblewimble-1#/">separate window</a>.</p>
<a class="header" href="#mimblewimble-grin-blockchain-protocol-overview" id="mimblewimble-grin-blockchain-protocol-overview"><h1>Mimblewimble-Grin Blockchain Protocol Overview</h1></a>
<a class="header" href="#introduction-5" id="introduction-5"><h2>Introduction</h2></a>
<p>Depending on who you ask, Mimblewimble is either a tongue-tying curse or blockchain protocol designed to be private and scalable. The transactions in Mimblewimble is derived from confidential transactions by Greg Maxwell [<a href="https://people.xiph.org/%7Egreg/confidential_values.txt" title="Original confidential transaction paper">1</a>], that is in turn based on the Pedersen commitment scheme. On 19 July 2016 someone with the name Tom Elvis Jedusor left a whitepaper on the tor network describing how Mimblewimble could work. As the potential for this was realized work was done to make this a reality. One of these projects is Grin, which is a minimalistic implementation of Mimblewimble.  Further information could be found on <a href="../grin-beam-comparison/MainReport.html">Grin at Grin vs. BEAM, a Comparison</a> [<a href="https://tari-labs.github.io/tari-university/protocols/grin-beam-comparison/MainReport.html#grin-vs-beam-a-comparison" title="Grin vs. BEAM a Comparison">2</a>] and <a href="../grin-design-choice-criticisms/MainReport.html">Grin design choice criticisms - Truth or Fiction</a> [<a href="https://tari-labs.github.io/tari-university/protocols/grin-design-choice-criticisms/MainReport.html" title="Grin design choice criticisms">3</a>].</p>
<a class="header" href="#contents-1" id="contents-1"><h2>Contents</h2></a>
<ul>
<li><a href="#mimblewimble-grin-blockchain-protocol-overview">Mimblewimble-Grin Blockchain Protocol Overview</a>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#contents">Contents</a></li>
<li><a href="#mimblewimble-protocol-overview">Mimblewimble protocol overview</a>
<ul>
<li><a href="#commitments">Commitments</a></li>
<li><a href="#cut-through-and-pruning">Cut-through and pruning</a></li>
<li><a href="#grin-blocks">Grin blocks</a></li>
</ul>
</li>
<li><a href="#trustless-transactions">Trustless transactions</a></li>
<li><a href="#contracts">Contracts</a>
<ul>
<li><a href="#time-locked">Time-locked</a></li>
<li><a href="#multisig">Multisig</a></li>
</ul>
</li>
<li><a href="#atomic-swaps">Atomic swaps</a></li>
<li><a href="#references">References</a></li>
<li><a href="#contributors">Contributors</a></li>
<li><a href="#appendices">Appendices</a>
<ul>
<li><a href="#appendix-a-example-of-grin-block">Appendix A: Example of Grin Block</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<a class="header" href="#mimblewimble-protocol-overview" id="mimblewimble-protocol-overview"><h2>Mimblewimble protocol overview</h2></a>
<a class="header" href="#commitments" id="commitments"><h3>Commitments</h3></a>
<p>Mimblewimble publishes all transaction as confidential transactions.  All inputs, outputs and change are expressed in the following form:</p>
<p>​   $ r \cdot G + v \cdot H ​$</p>
<p>where $ G $ and $ H $ are elliptic curves, $ r $ a private key used as a blinding factor, $ v $ the value and &quot;$ \cdot $&quot; being Elliptic-curve cryptography (ECC) multiplication.</p>
<p>An example transaction can be expressed as input = output + change.</p>
<p>​   $ (r_i \cdot G + v_i \cdot H) = (r_c \cdot G + v_c \cdot H) + (r_c \cdot G + v_c + \cdot H) $</p>
<p>But this requires that</p>
<p>​   $ r_i = r_o + r_c $</p>
<p>A more detail explanation of how Mimblewimble works can be found in the Grin GitHub documents [<a href="https://github.com/mimblewimble/grin/blob/master/doc/table_of_contents.md" title="Main Grin document structure">4</a>].</p>
<a class="header" href="#cut-through-and-pruning" id="cut-through-and-pruning"><h3>Cut-through and pruning</h3></a>
<a class="header" href="#cut-through" id="cut-through"><h4>Cut-through</h4></a>
<p>Grin includes something that is called cut-through in the transaction pool, and this removes outputs in the transaction pool that are already spent as new inputs. Using the fact that every transaction in a block should sum to zero. This is shown below:</p>
<p>​   $ output - inputs = kernel_-excess +(part \mspace{3mu} of)kernel_- offset $</p>
<p>The kernel offset is used to hide which kernel belongs to which transaction and we only have a summed kernel offset stored in the header of each block.</p>
<p>We don't have to record these transactions inside the block, although we still have to record the kernel as the kernel proof transfer of ownership to make sure that the whole block sums to zero, this is expressed in the formula below:</p>
<p>​   $ sum(ouputs) - sum(inputs) = sum(kernel_-excess) + kernel_-offset $</p>
<p>An example of cut-through can be seen below:</p>
<pre><code class="language-text"> I1(x1)    +---&gt; O1
           +---&gt; O2

 I2(x2,O2) +---&gt; O3

 I3(O3)    +---&gt; O4
           +---&gt; O5
</code></pre>
<p>After cut-through</p>
<pre><code class="language-text"> I1(x1)    +---&gt; O1
 I2(x2)    +---&gt; O4
           +---&gt; O5
</code></pre>
<p>In the diagrams: I are new inputs, X are inputs from previous blocks and O are outputs.</p>
<p>This causes that Mimblewimble blocks to be much smaller than normal bitcoin blocks as the cut-through transactions are not listed under inputs and outputs anymore. In practice after this we can still see there was a transaction because the kernel excess still remains, but the actual hidden values are not recorded.</p>
<a class="header" href="#pruning" id="pruning"><h4>Pruning</h4></a>
<p>Pruning takes this same concept but goes into past blocks. So, if an output in a previous block gets spent it will be removed from that block. Pruning removes the leaves from the Merkle Mountain Range (MMR) as well. Thus, it allows the ledger to be small and scalable. According to the Grin team [<a href="https://tari-labs.github.io/tari-university/protocols/grin-design-choice-criticisms/MainReport.html" title="Grin design choice criticisms">3</a>] assuming 10 million transactions with 100 000 unspent outputs the ledger will be roughly 130GB, this can be divided into the following parts:</p>
<ul>
<li>128GB of transaction data (inputs and outputs).</li>
<li>1 GB of transaction proof data.</li>
<li>250MB of block headers.</li>
</ul>
<p>The total storage requirements can be reduced if cut-through and pruning is applied, the ledger will shrink to approximately 1.8GB and will result in the following:</p>
<ul>
<li>1 GB of transaction proof data.</li>
<li>UTXO size of 520MB.</li>
<li>250MB of block headers.</li>
</ul>
<a class="header" href="#grin-blocks" id="grin-blocks"><h3>Grin blocks</h3></a>
<p>The grin block contains the following data:</p>
<ol>
<li>Transaction outputs, which include for each output:
<ol>
<li>A Pedersen commitment (33 bytes).</li>
<li>A range proof (over 5KB at this time).</li>
</ol>
</li>
<li>Transaction inputs, which are just output references (32 bytes).</li>
<li>Transaction fees, in clear text</li>
<li>Transaction &quot;proofs&quot;, which include for each transaction:
<ol>
<li>The excess commitment sum for the transaction (33 bytes).</li>
<li>A signature generated with the excess (71 bytes average).</li>
</ol>
</li>
<li>A block header that includes Merkle trees and proof of work (about 250 bytes).</li>
</ol>
<p>The Grin header:</p>
<table><thead><tr><th> Header field        </th><th>                                           </th></tr></thead><tbody>
<tr><td> Hash                </td><td> Unique hash of block                      </td></tr>
<tr><td> Version             </td><td> Grin version                              </td></tr>
<tr><td> Previous block      </td><td> Unique hash of previous block             </td></tr>
<tr><td> Age                 </td><td> Time the block was mined                  </td></tr>
<tr><td> Cuckoo solution     </td><td> The wining cuckoo solution                </td></tr>
<tr><td> Difficulty          </td><td> Difficulty of the solved cuckoo           </td></tr>
<tr><td> Target Difficulty   </td><td> Difficulty of this block                  </td></tr>
<tr><td> Total difficulty    </td><td> Total difficulty of mined chain up to age </td></tr>
<tr><td> Total kernal offset </td><td> Kernel offset                             </td></tr>
<tr><td> Nonce               </td><td> Random number for cuckoo                  </td></tr>
<tr><td> Block reward        </td><td> Coinbase + fee reward for block           </td></tr>
</tbody></table>
<p>The rest of the block contains a list of kernels, inputs and outputs. An example of a grin block is shown in the appendix.</p>
<a class="header" href="#trustless-transactions" id="trustless-transactions"><h2>Trustless transactions</h2></a>
<p>Schnorr signatures have been done in Tari Labs University (TLU), please have a look <a href="../../cryptography/digital_signatures/introduction.html">here</a> for a more detailed explanation [<a href="https://tari-labs.github.io/tari-university/" title="The Tari Labs university">7</a>].</p>
<p>Since Grin transactions are obscured by Pedersen Commitments, there is no prove that money was actually transferred. To solve this problem, we require the receiver to collaborate with the sender in building a transaction and more specifically the kernel signature [<a href="https://github.com/mimblewimble/grin/blob/master/doc/table_of_contents.md" title="Main Grin document structure">4</a>].</p>
<p>When Alice wants to pay Bob, the transaction will be performed using the following steps:</p>
<ol>
<li>
<p>Alice selects her inputs and her change. The sum of all blinding factors (change output minus inputs) is $ r_s $.</p>
</li>
<li>
<p>Alice picks a random nonce ks and sends her partial transaction, $ k_s\cdot G $ and $ r_s\cdot G $ to Bob.</p>
</li>
<li>
<p>Bob picks his own random nonce $ k_r $ and the blinding factor for his output $ r_r $. Using $ r_r $ Bob adds his output to the transaction.</p>
</li>
<li>
<p>Bob computes the message $ M= fee \Vert lock_-height $,</p>
<p>the Schnorr challenge $ e = SHA256(M \Vert K_r \cdot G + K_s\cdot  G \Vert r_r\cdot G + r_s\cdot G) $</p>
<p>and finally his side of the signature $ s_r = k_r + e\cdot G $</p>
</li>
<li>
<p>Bob sends: $ s_r $ and $ k_r\cdot G $ and $ r_r\cdot G $  to Alice.</p>
</li>
<li>
<p>Alice computes $ e $ just like Bob did and can check that $ s_r\cdot G = k_r\cdot G + e\cdot r_r \cdot G $</p>
</li>
<li>
<p>Alice sends her side of the signature $ s_s = k_s + e\cdot r_s $  to Bob.</p>
</li>
<li>
<p>Bob validates $ s_s\cdot G $  just like Alice did for $ s_r\cdot G $ in step 5 and can produce the final signature $ s = s_s + s_r , k_s\cdot G + k_s\cdot G$ as well as the final transaction kernel including $ s $ and the public key $ r_r\cdot G + r_s\cdot G$</p>
</li>
</ol>
<a class="header" href="#contracts" id="contracts"><h2>Contracts</h2></a>
<a class="header" href="#time-locked" id="time-locked"><h3>Time-locked</h3></a>
<a class="header" href="#absolute" id="absolute"><h4>Absolute</h4></a>
<p>In a normal Grin transaction the signature [<a href="https://github.com/mimblewimble/grin/blob/master/doc/table_of_contents.md" title="Main Grin document structure">4</a>] just the normal fee gets signed as the message. But to get an absolute time locked transaction the message can be modified taking the block height and appending the fee to that. A block with a kernel that includes a lock height greater than the current block height is then rejected.</p>
<p>​   $ M = fee \Vert h $</p>
<a class="header" href="#relative" id="relative"><h4>Relative</h4></a>
<p>Taking into account how an absolute time-locked transaction is constructed the same idea can be extended by taking the relative block height and not the absolute height, but also adding a specific kernel commitment. In this way the signature references a specific block as height. The same principle counts as with absolute time-locked transactions in that a block with a kernel containing a relative time-locked transaction that has not passed is rejected.</p>
<p>​   $ M = fee \Vert h \Vert c $</p>
<a class="header" href="#multisig" id="multisig"><h3>Multisig</h3></a>
<p>Multi-signatures (Multisigs) are also known as N-of-M signatures, and this means that N amount out of M amount of peers need to agree before a transaction can be spend.</p>
<p>When Bob and Alice [<a href="https://github.com/mimblewimble/grin/blob/master/doc/contracts.md" title="Grin contracts">6</a>] wants to do a 2-of-2 multisig contract, the contract can be done with the following steps:</p>
<ol>
<li>Bob picks a blinding factor $ r_b $ and sends $ r_b\cdot G $ to Alice.</li>
<li>Alice picks a blinding factor $ r_a $  and builds the commitment $ C= r_a\cdot G + r_b\cdot G + v\cdot H $, she sends the commitment to Bob.</li>
<li>Bob creates a range proof for $ v $  using $ C $  and $ r_b $  and sends it to Alice.</li>
<li>Alice generates her own range proof, aggregates it with Bob, finalizing the multiparty output $ O_{ab} $</li>
<li>The kernel is built following the same procedure as used with Trustless Transactions.</li>
</ol>
<p>We observe that the output $ O_{ab} $ , is unknown to both party because neither knows the whole blinding factor. To be able to build a transaction spending $ O_{ab} $, someone would need to know $ r_a + r_b $ to produce a kernel signature. To produce the original spending kernel, Alice and Bob need to collaborate.</p>
<a class="header" href="#atomic-swaps" id="atomic-swaps"><h2>Atomic swaps</h2></a>
<p>Atomic swaps can be used to exchange coins from different blockchains in a trustless environment. In the Grin documentation this is handled in length by the contracts documentation [<a href="https://github.com/mimblewimble/grin/blob/master/doc/contracts.md" title="Grin contracts">6</a>] and in the contracts ideas documentation [<a href="https://github.com/mimblewimble/grin/blob/master/doc/contract_ideas.md" title="Grin contract ideas discussion document">8</a>]. In practice there has already been an atomic swap between Grin and Ethereum [<a href="https://medium.com/grinswap/first-grin-atomic-swap-a16b4cc19196" title="First ever Grin atomic swap">9</a>], but this only used the Grin test-net with a modified Grin implementation as the release version of Grin did not yet support the required contracts. TLU has a section about <a href="../atomic-swaps/AtomicSwaps.html">Atomic swaps</a> [<a href="https://tari-labs.github.io/tari-university/" title="The Tari Labs university">7</a>].</p>
<p>Atomic swaps work with 2-of-2 multisig contracts, one public key being Alice's, the second being the hash of a preimage that Bob has to reveal. Consider public key derivation $ x\cdot G $ to be the hash function and by Bob revealing $ x $, Alice can then produce an adequate signature proving she knows $ x $  (in addition to her own private key).</p>
<p>Alice will swap Grin with Bob for Bitcoin. We assume Bob created an output on the Bitcoin blockchain that allows spending by Alice if she learns a hash pre-image $ x $, or by Bob after time $ T_b $ . Alice is ready to send her Grin to Bob if he reveals $ x $.</p>
<p>Alice will send her Grin to a multiparty timelock contract with a refund time $ T_a &lt; T_b $. To send the 2-of-2 output to Bob and execute the swap, Alice and Bob start as if they were building a normal trustless transaction.</p>
<ol>
<li>Alice picks a random nonce $ k_s $  and her blinding sum $ r_s $ and sends $ k_s\cdot G $ and $ r_s\cdot G $ to Bob.</li>
<li>Bob picks a random blinding factor $ r_r $ and a random nonce $ k_r $. However, this time, instead of simply sending $ s_r = k_r + e\cdot r_r $  with his $ r_r\cdot G $ and $ k_r\cdot G $, Bob sends $ s_r' = k_r + x + e\cdot r_r $ as well as $ x\cdot G $</li>
<li>Alice can validate that $ s_r'\cdot G = k_r\cdot G + x\cdot G + r_r\cdot G $. She can also check that Bob has money locked with $ x\cdot G $ on the other chain.</li>
<li>Alice sends back her $ s_s = k_s + e\cdot x_s $ as she normally would, now that she can also compute $ e = SHA256(M \Vert k_s\cdot G+k_r\cdot G) $</li>
<li>To complete the signature, Bob computes $ s_r = k_r + e\cdot r_r $ and the final signature is $ (s_r + s_s, k_r\cdot G + k_s\cdot G) $</li>
<li>As soon as Bob broadcasts the final transaction to get his Grin, Alice can compute $ s_r' - s_r $ to get $ x $.</li>
</ol>
<p>Prior to completing the atomic swap, Bob needs to know Alice's public key. Bob would then create an output on the Bitcoin blockchain with a 2-of-2 multisig similar to <code>alice_pubkey secret_pubkey 2 OP_CHECKMULTISIG</code>. This should be wrapped in an <code>OP_IF</code> so Bob can get his money back after an agreed-upon time. All of this can even be wrapped in a  Pays To Script Hash (P2SH). Here <code>secret_pubkey</code> is $x\cdot G$ from the previous section.</p>
<p>To verify the output, Alice would take $x\cdot G$, recreate the bitcoin script, hash it and check that her hash matches what's in theP2SH  (step 2 in previous section). Once she gets $x$ (step 6), she can build the 2 signatures necessary to spend the 2-of-2, having both private keys, and get her bitcoin.</p>
<a class="header" href="#references-9" id="references-9"><h2>References</h2></a>
<p>[<a href="https://people.xiph.org/%7Egreg/confidential_values.txt" title="Original confidential transaction paper">1</a>] <em>Confidential Transactions</em>. Maxwell, G. (2017)  Available at: https://people.xiph.org/~greg/confidential_values.txt (Accessed: 24 October 2018).</p>
<p>[<a href="https://tari-labs.github.io/tari-university/protocols/grin-beam-comparison/MainReport.html#grin-vs-beam-a-comparison" title="Grin vs. BEAM a Comparison">2</a>] <em>Grin vs. BEAM, a Comparison</em>. Robinson, P. and et al (2018)Available at: https://tari-labs.github.io/tari-university/protocols/grin-beam-comparison/MainReport.html#grin-vs-beam-a-comparison (Accessed: 8 October 2018).</p>
<p>[<a href="https://tari-labs.github.io/tari-university/protocols/grin-design-choice-criticisms/MainReport.html" title="Grin design choice criticisms">3</a>] <em>Grin Design Choice Criticisms - Truth or Fiction</em>. Roodt, Y. and et al (2018) Available at: https://tari-labs.github.io/tari-university/protocols/grin-design-choice-criticisms/MainReport.html (Accessed: 8 October 2018).</p>
<p>[<a href="https://github.com/mimblewimble/grin/blob/master/doc/table_of_contents.md" title="Main Grin document structure">4</a>] <em>Grin document structure</em>. Simon B and Et al (2018) Available at: https://github.com/mimblewimble/grin/blob/master/doc/table_of_contents.md (Accessed: 24 October 2018).</p>
<p>[<a href="https://github.com/mimblewimble/grin/blob/master/doc/pruning.md" title="Grin pruning">5</a>] <em>Pruning Blockchain Data</em>. Peverell, I. and et al (2016) Available at: https://github.com/mimblewimble/grin/blob/master/doc/pruning.md (Accessed: 26 October 2018).</p>
<p>[<a href="https://github.com/mimblewimble/grin/blob/master/doc/contracts.md" title="Grin contracts">6</a>] <em>Contracts</em>. Peverell, I. and Et al (2018) Available at: https://github.com/mimblewimble/grin/blob/master/doc/contracts.md (Accessed: 26 October 2018).</p>
<p>[<a href="https://tari-labs.github.io/tari-university/" title="The Tari Labs university">7</a>] <em>Tari Labs University</em>.  Tari Labs (2018) Available at: https://tari-labs.github.io/tari-university/ (Accessed: 27 October 2018).</p>
<p>[<a href="https://github.com/mimblewimble/grin/blob/master/doc/contract_ideas.md" title="Grin contract ideas discussion document">8</a>] <em>Contract ideas</em>. Sceller, Q. Le (2018) Available at: https://github.com/mimblewimble/grin/blob/master/doc/contract_ideas.md (Accessed: 27 October 2018).</p>
<p>[<a href="https://medium.com/grinswap/first-grin-atomic-swap-a16b4cc19196" title="First ever Grin atomic swap">9</a>] <em>First Grin atomic swap!</em> Jasper (2018) Available at: https://medium.com/grinswap/first-grin-atomic-swap-a16b4cc19196 (Accessed: 27 October 2018).</p>
<a class="header" href="#contributors-4" id="contributors-4"><h2>Contributors</h2></a>
<p>https://github.com/SWvheerden</p>
<p>https://github.com/neonknight64</p>
<p>https://github.com/hansieodendaal</p>
<a class="header" href="#appendices" id="appendices"><h2>Appendices</h2></a>
<a class="header" href="#appendix-a-example-of-grin-block" id="appendix-a-example-of-grin-block"><h3>Appendix A: Example of Grin Block</h3></a>
<table><thead><tr><th> Hash                </th><th> 02cb5e810857266609511699c8d222ed4e02883c6b6d3405c05a3caea9bb0f64 </th></tr></thead><tbody>
<tr><td> Version             </td><td> 1                                                            </td></tr>
<tr><td> Previous Block      </td><td> <a href="https://grinexplorer.net/block/0343597fe7c69f497177248913e6e485f3f23bb03b07a0b8a5b54f68187dbc1d">0343597fe7c69f497177248913e6e485f3f23bb03b07a0b8a5b54f68187dbc1d</a> </td></tr>
<tr><td> Age                 </td><td> 2018-10-23, 08:03:46 UTC                                     </td></tr>
<tr><td> Cuckoo Solution     </td><td> Size:                                                        </td></tr>
<tr><td> Difficulty          </td><td> 37,652                                                       </td></tr>
<tr><td> Target Difficulty   </td><td> 17,736                                                       </td></tr>
<tr><td> Total Difficulty    </td><td> 290,138,524                                                  </td></tr>
<tr><td> Total Kernel Offset </td><td> b52ccdf119fe18d7bd12bcdf0642fcb479c6093dca566e0aed33eb538f410fb5 </td></tr>
<tr><td> Nonce               </td><td> 7262225957146290317                                          </td></tr>
<tr><td> Block Reward        </td><td> 60 grin                                                      </td></tr>
<tr><td> Fees                </td><td> 14 mg                                                        </td></tr>
</tbody></table>
<p><details class="black" open="" style="box-sizing: border-box;"><summary style="box-sizing: border-box; touch-action: manipulation; display: list-item; background-color: rgb(153, 153, 153); color: rgb(255, 255, 255); font-weight: bold; line-height: 40px; padding-left: 8px;">Inputs (4)</summary><table class="table table-horizontal-bordered table-hover" style="box-sizing: border-box; border-collapse: collapse; width: 1110px; max-width: 100%; margin-bottom: 1rem; background-color: transparent;"><thead class="thead-light" style="box-sizing: border-box;"><tr style="box-sizing: border-box;"><th style="box-sizing: border-box; text-align: inherit; padding: 0.75rem; vertical-align: bottom; border-top: 1px solid rgb(233, 236, 239); border-bottom: 2px solid rgb(233, 236, 239); color: rgb(73, 80, 87); background-color: rgb(233, 236, 239); border-right-color: rgb(233, 236, 239); border-left-color: rgb(233, 236, 239);">Commit</th></tr></thead><tbody style="box-sizing: border-box;"><tr style="box-sizing: border-box;"><td style="box-sizing: border-box; padding: 0.75rem; vertical-align: top; border-top: 1px solid rgb(233, 236, 239); border-bottom: 1px solid rgb(221, 221, 221); font-family: monospace;">0898a4b53964ada66aa16de3d44ff02228c168a23c0bd71b162f4366ce0dae24b0</td></tr><tr style="box-sizing: border-box;"><td style="box-sizing: border-box; padding: 0.75rem; vertical-align: top; border-top: 1px solid rgb(233, 236, 239); border-bottom: 1px solid rgb(221, 221, 221); font-family: monospace;">09a173023e9c39c923e626317ffd384c7bce44109fea91a9c142723bfa700fce27</td></tr><tr style="box-sizing: border-box;"><td style="box-sizing: border-box; padding: 0.75rem; vertical-align: top; border-top: 1px solid rgb(233, 236, 239); border-bottom: 1px solid rgb(221, 221, 221); font-family: monospace;">086e0d164fe92d837b5365465a6b37af496a4f8520a2c1fccbb9f736521631ba96</td></tr><tr style="box-sizing: border-box;"><td style="box-sizing: border-box; padding: 0.75rem; vertical-align: top; border-top: 1px solid rgb(233, 236, 239); border-bottom: 1px solid rgb(221, 221, 221); font-family: monospace;">087a00d61f8ada399f170953c6cc7336c6a0b22518a8b02fd8dd3e28c01ee51fdb</td></tr></tbody></table></details></p>
<p><details class="black" open="" style="box-sizing: border-box;"><summary style="box-sizing: border-box; touch-action: manipulation; display: list-item; background-color: rgb(153, 153, 153); color: rgb(255, 255, 255); font-weight: bold; line-height: 40px; padding-left: 8px;">Outputs (5)</summary><table class="table table-horizontal-bordered table-hover" style="box-sizing: border-box; border-collapse: collapse; width: 1110px; max-width: 100%; margin-bottom: 1rem; background-color: transparent;"><thead class="thead-light" style="box-sizing: border-box;"><tr style="box-sizing: border-box;"><th style="box-sizing: border-box; text-align: inherit; padding: 0.75rem; vertical-align: bottom; border-top: 1px solid rgb(233, 236, 239); border-bottom: 2px solid rgb(233, 236, 239); color: rgb(73, 80, 87); background-color: rgb(233, 236, 239); border-right-color: rgb(233, 236, 239); border-left-color: rgb(233, 236, 239);">Output Type</th><th style="box-sizing: border-box; text-align: inherit; padding: 0.75rem; vertical-align: bottom; border-top: 1px solid rgb(233, 236, 239); border-bottom: 2px solid rgb(233, 236, 239); color: rgb(73, 80, 87); background-color: rgb(233, 236, 239); border-right-color: rgb(233, 236, 239); border-left-color: rgb(233, 236, 239);">Commit</th><th style="box-sizing: border-box; text-align: inherit; padding: 0.75rem; vertical-align: bottom; border-top: 1px solid rgb(233, 236, 239); border-bottom: 2px solid rgb(233, 236, 239); color: rgb(73, 80, 87); background-color: rgb(233, 236, 239); border-right-color: rgb(233, 236, 239); border-left-color: rgb(233, 236, 239);">Spent</th></tr></thead><tbody style="box-sizing: border-box;"><tr style="box-sizing: border-box;"><td style="box-sizing: border-box; padding: 0.75rem; vertical-align: top; border-top: 1px solid rgb(233, 236, 239); border-bottom: 1px solid rgb(221, 221, 221);">Transaction</td><td style="box-sizing: border-box; padding: 0.75rem; vertical-align: top; border-top: 1px solid rgb(233, 236, 239); border-bottom: 1px solid rgb(221, 221, 221);">09eac33dfdeb84da698c6c17329e4a06020238d9bb31435a4abd9d2ffc122f6879</td><td style="box-sizing: border-box; padding: 0.75rem; vertical-align: top; border-top: 1px solid rgb(233, 236, 239); border-bottom: 1px solid rgb(221, 221, 221);">False</td></tr><tr style="box-sizing: border-box;"><td style="box-sizing: border-box; padding: 0.75rem; vertical-align: top; border-top: 1px solid rgb(233, 236, 239); border-bottom: 1px solid rgb(221, 221, 221);">Transaction</td><td style="box-sizing: border-box; padding: 0.75rem; vertical-align: top; border-top: 1px solid rgb(233, 236, 239); border-bottom: 1px solid rgb(221, 221, 221);">0860e9cf37a94668c842738a5acc8abd628c122608f48a50bbb7728f46a3d50673</td><td style="box-sizing: border-box; padding: 0.75rem; vertical-align: top; border-top: 1px solid rgb(233, 236, 239); border-bottom: 1px solid rgb(221, 221, 221);">False</td></tr><tr style="box-sizing: border-box;"><td style="box-sizing: border-box; padding: 0.75rem; vertical-align: top; border-top: 1px solid rgb(233, 236, 239); border-bottom: 1px solid rgb(221, 221, 221);">Coinbase</td><td style="box-sizing: border-box; padding: 0.75rem; vertical-align: top; border-top: 1px solid rgb(233, 236, 239); border-bottom: 1px solid rgb(221, 221, 221);">08324cdbf7443b6253bb0cdf314fce39117dcafbddda36ed37f2c209fc651802d6</td><td style="box-sizing: border-box; padding: 0.75rem; vertical-align: top; border-top: 1px solid rgb(233, 236, 239); border-bottom: 1px solid rgb(221, 221, 221);">False</td></tr><tr style="box-sizing: border-box;"><td style="box-sizing: border-box; padding: 0.75rem; vertical-align: top; border-top: 1px solid rgb(233, 236, 239); border-bottom: 1px solid rgb(221, 221, 221);">Transaction</td><td style="box-sizing: border-box; padding: 0.75rem; vertical-align: top; border-top: 1px solid rgb(233, 236, 239); border-bottom: 1px solid rgb(221, 221, 221);">0873f0da4ce164e2597800bf678946aad1cd2d7e2371c4eed471fecf9571942b4f</td><td style="box-sizing: border-box; padding: 0.75rem; vertical-align: top; border-top: 1px solid rgb(233, 236, 239); border-bottom: 1px solid rgb(221, 221, 221);">False</td></tr><tr style="box-sizing: border-box;"><td style="box-sizing: border-box; padding: 0.75rem; vertical-align: top; border-top: 1px solid rgb(233, 236, 239); border-bottom: 1px solid rgb(221, 221, 221);">Transaction</td><td style="box-sizing: border-box; padding: 0.75rem; vertical-align: top; border-top: 1px solid rgb(233, 236, 239); border-bottom: 1px solid rgb(221, 221, 221);">09774ee77edaaa81b3c6ee31f471f014db86c4b3345f739472cb12ecc8f40401df</td><td style="box-sizing: border-box; padding: 0.75rem; vertical-align: top; border-top: 1px solid rgb(233, 236, 239); border-bottom: 1px solid rgb(221, 221, 221);">False</td></tr></tbody></table></details></p>
<p><details class="black" open="" style="box-sizing: border-box;"><summary style="box-sizing: border-box; touch-action: manipulation; display: list-item; background-color: rgb(153, 153, 153); color: rgb(255, 255, 255); font-weight: bold; line-height: 40px; padding-left: 8px;">Kernels (3)</summary><table class="table table-horizontal-bordered table-hover" style="box-sizing: border-box; border-collapse: collapse; width: 1110px; max-width: 100%; margin-bottom: 1rem; background-color: transparent;"><thead class="thead-light" style="box-sizing: border-box;"><tr style="box-sizing: border-box;"><th style="box-sizing: border-box; text-align: inherit; padding: 0.75rem; vertical-align: bottom; border-top: 1px solid rgb(233, 236, 239); border-bottom: 2px solid rgb(233, 236, 239); color: rgb(73, 80, 87); background-color: rgb(233, 236, 239); border-right-color: rgb(233, 236, 239); border-left-color: rgb(233, 236, 239);">Features</th><th style="box-sizing: border-box; text-align: inherit; padding: 0.75rem; vertical-align: bottom; border-top: 1px solid rgb(233, 236, 239); border-bottom: 2px solid rgb(233, 236, 239); color: rgb(73, 80, 87); background-color: rgb(233, 236, 239); border-right-color: rgb(233, 236, 239); border-left-color: rgb(233, 236, 239);">Fee</th><th style="box-sizing: border-box; text-align: inherit; padding: 0.75rem; vertical-align: bottom; border-top: 1px solid rgb(233, 236, 239); border-bottom: 2px solid rgb(233, 236, 239); color: rgb(73, 80, 87); background-color: rgb(233, 236, 239); border-right-color: rgb(233, 236, 239); border-left-color: rgb(233, 236, 239);">Lock Height</th></tr></thead><tbody style="box-sizing: border-box;"><tr style="box-sizing: border-box;"><td style="box-sizing: border-box; padding: 0.75rem; vertical-align: top; border-top: 1px solid rgb(233, 236, 239); border-bottom: 1px solid rgb(221, 221, 221);">DEFAULT_KERNEL</td><td style="box-sizing: border-box; padding: 0.75rem; vertical-align: top; border-top: 1px solid rgb(233, 236, 239); border-bottom: 1px solid rgb(221, 221, 221);">6 mg</td><td style="box-sizing: border-box; padding: 0.75rem; vertical-align: top; border-top: 1px solid rgb(233, 236, 239); border-bottom: 1px solid rgb(221, 221, 221);">7477</td></tr><tr style="box-sizing: border-box;"><td style="box-sizing: border-box; padding: 0.75rem; vertical-align: top; border-top: 1px solid rgb(233, 236, 239); border-bottom: 1px solid rgb(221, 221, 221);">DEFAULT_KERNEL</td><td style="box-sizing: border-box; padding: 0.75rem; vertical-align: top; border-top: 1px solid rgb(233, 236, 239); border-bottom: 1px solid rgb(221, 221, 221);">8 mg</td><td style="box-sizing: border-box; padding: 0.75rem; vertical-align: top; border-top: 1px solid rgb(233, 236, 239); border-bottom: 1px solid rgb(221, 221, 221);">7477</td></tr><tr style="box-sizing: border-box;"><td style="box-sizing: border-box; padding: 0.75rem; vertical-align: top; border-top: 1px solid rgb(233, 236, 239); border-bottom: 1px solid rgb(221, 221, 221);">COINBASE_KERNEL</td><td style="box-sizing: border-box; padding: 0.75rem; vertical-align: top; border-top: 1px solid rgb(233, 236, 239); border-bottom: 1px solid rgb(221, 221, 221);">0 grin</td><td style="box-sizing: border-box; padding: 0.75rem; vertical-align: top; border-top: 1px solid rgb(233, 236, 239); border-bottom: 1px solid rgb(221, 221, 221);">7482</td></tr></tbody></table></details></p>
<p>Apart from the header information we can only see that this block contains 2 transaction from the 2 kernels present. Between those two transaction we only know that there were 4 inputs and 4 outputs. Because of the way Mimblewimble obfuscates the transaction we don't know the values or which input and output belongs to which transaction. </p>
<a class="header" href="#grin-vs-beam-a-comparison" id="grin-vs-beam-a-comparison"><h1>Grin vs. BEAM, a Comparison</h1></a>
<a class="header" href="#introduction-6" id="introduction-6"><h2>Introduction</h2></a>
<p>Grin and BEAM are two open-source cryptocurrency projects based on the Mimblewimble protocol. The Mimblewimble protocol was first proposed by a anonymous user using the pseudonym Tom Elvis Jedusor (the french translation of Voldemort's name from the Harry Potter series of books). This user logged onto a bitcoin research IRC channel and posted a link to a text article hosted on a Tor hidden service [<a href="https://download.wpsoftware.net/bitcoin/wizardry/mimblewimble.txt" title="MIMBLEWIMBLE">1</a>]. This article provided the basis for a new way to construct block chain style transactions that provided inherent privacy and the ability to dramatically reduce the size of the block chain by compressing the transaction history of the chain. This initial article presented the main ideas of the protocol but it left out a number of critical elements required for a practical implementation and even contained a mistake in the cryptographic formulation. Andrew Poelstra published a follow-up paper that addresses many of these issues and refines the core concepts of Mimblewimble [<a href="https://download.wpsoftware.net/bitcoin/wizardry/mimblewimble.pdf" title="Mimblewimble">2</a>] which have been applied to the practical implementations of this protocol in both the Grin [<a href="https://github.com/mimblewimble/grin/blob/master/doc/intro.md" title="Introduction to Mimblewimble and Grin">3</a>] and BEAM [<a href="https://docs.wixstatic.com/ugd/87affd_3b032677d12b43ceb53fa38d5948cb08.pdf" title="BEAM: The Scalable Confidential Cryptocurrency">4</a>] projects.</p>
<p>The Mimblewimble protocol describes how transacting parties will interactively work to build a valid transaction using their public/private key pairs, used to prove ownership of transaction outputs, and interactively chosen blinding factors. These blinding factors are used to obfuscate the participant's public keys from everyone, including each other, and to hide the value of the transaction from everyone except the counterparty in that specific transaction. The protocol also performs a process called cut-through which condenses transactions by eliminating intermediary transactions. This improves privacy and compresses the amount of data that is maintained on the block chain [<a href="https://github.com/mimblewimble/grin/blob/master/doc/intro.md" title="Introduction to Mimblewimble and Grin">3</a>]. This cut-through process precludes general purpose scripting systems like those found in Bitcoin. However, Andrew Poelstra proposed the concept of Scriptless scripts, which make use of Schnorr signatures, to build adaptor signatures that allow for encoding of many of the behaviors that scripts are traditionally used to achieve. Scriptless scripts enable functionality like Atomic swaps and Lightning network like payment channels [<a href="https://joinmarket.me/blog/blog/flipping-the-scriptless-script-on-schnorr/" title="Flipping the scriptless script on Schnorr by A. Gibson">5</a>].</p>
<p>Grin and BEAM both implement the Mimblewimble protocol but each has been built from scratch. Grin is written in RUST and BEAM in C++. The remainder of this report will focus on describing some of the aspects of each project that sets them apart. Both projects are still early in their development cycle and many of these details are changing on a daily basis. Furthermore, the BEAM project documentation is still mostly available only in Russian so as of the writing of this report not all the technical details are available for English readers. As such the discussion in this report will most likely become out of date as the respective project evolve.</p>
<p>The remainder of this report will be structured as follows: Firstly, some implementation details and unique features of the project will be discussed. Secondly, we will examine the difference in the proof-of-work algorithms employed and finally we will discuss the different governance models the projects are using.</p>
<a class="header" href="#contents-2" id="contents-2"><h2>Contents</h2></a>
<ul>
<li><a href="#grin-vs-beam-a-comparison">Grin vs. BEAM, a Comparison</a>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#contents">Contents</a></li>
<li><a href="#comparison-of-features-and-implementation-in-grin-vs-beam">Comparison of Features and Implementation in Grin vs BEAM</a>
<ul>
<li><a href="#grin-unique-features">Grin unique features</a></li>
<li><a href="#beam-unique-features">BEAM unique features</a></li>
</ul>
</li>
<li><a href="#proof-of-work-mining-algorithm">Proof of Work Mining Algorithm</a></li>
<li><a href="#governance-models-and-monetary-policy">Governance Models and Monetary Policy</a></li>
<li><a href="#conclusions-observations-recommendations">Conclusions, Observations, Recommendations</a></li>
<li><a href="#references">References</a></li>
<li><a href="#contributors">Contributors</a></li>
<li><a href="#appendices">Appendices</a>
<ul>
<li><a href="#appendix-a-cuckoocuckatoo-cycle-pow-algorithm">Appendix A: Cuckoo/Cuckatoo Cycle PoW algorithm</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<a class="header" href="#comparison-of-features-and-implementation-in-grin-vs-beam" id="comparison-of-features-and-implementation-in-grin-vs-beam"><h2>Comparison of Features and Implementation in Grin vs BEAM</h2></a>
<p>The two projects are being independently built from scratch by different teams in different languages (Rust [<a href="https://github.com/mimblewimble/grin" title="Grin Github Repository">6</a>] and C++ [<a href="https://github.com/beam-mw/beam" title="BEAM Github Repository">7</a>]), so there will be many differences in the raw implementations. For example, Grin uses LMDB for its embedded SQL database and BEAM use SQLite which have performance differences but are functionally similar. Grin uses a Directed Acyclic Graph (DAG) to represent their mempool to avoid transaction reference loops [<a href="https://github.com/mimblewimble/grin/blob/master/doc/internal/pool.md" title="Grin - Transaction Pool">8</a>] while BEAM uses a multiset key-value data structure with logic to enable some of their extended features [<a href="https://github.com/beam-mw/beam" title="BEAM Github Repository">7</a>].</p>
<p>From the perspective of features the two projects exhibit all the features inherent to Mimblewimble. Grin's stated goal is to produce a simple and easy to maintain implementation of the Mimblewimble protocol [<a href="https://github.com/mimblewimble/grin/blob/master/doc/intro.md" title="Introduction to Mimblewimble and Grin">3</a>]. BEAM's implementation however contains a number of modifications to the Mimblewimble approach with the aim to provide some unique features for their implementation. Before we get into the features and design elements that set the two project apart let's discuss an interesting feature that both projects have implemented.</p>
<p>Both Grin and BEAM have incorporated a version of the Dandelion relay protocol that supports transaction aggregation. One of the major outstanding challenges for privacy that cryptocurrencies face is that it is possible to track transactions as they are added to the mempool and propagate across the network and to link those transactions to their originating IP addresses. This information can be used to deanonymize users even on networks with strong transaction privacy. To improve privacy during the propagation of transactions to the network the Dandelion network propagation scheme was proposed [<a href="https://arxiv.org/abs/1701.04439" title="Dandelion: Redesigning the Bitcoin Network for Anonymity.">9</a>]. In this scheme transactions are propagated in two phases, the Anonymity phase (or &quot;stem&quot; phase) and the Spreading phase (or &quot;fluff&quot; phase) as illustrated in the Figure 1. In the stem phase a transaction is propagated to only a single randomly selected peer from the current nodes peer list. After a random number of hops along the network, each hop propagating to only a single random peer, the propagation process enters the second phase. During the fluff phase the transaction is then propagated using a full flood/diffusion method as found in most networks. This approach means that the transaction has first propagated to a random point in the network before flooding the network so it becomes much more difficult to track its origin.</p>
<p align="center"><img src="sources/dandelion-stem-fluff.png" width="450" /></p>
<center><strong>Figure 1: Two Phases of Dandelion P2P Transaction Propagation. [<a href="https://arxiv.org/abs/1701.04439" title="Dandelion: Redesigning the Bitcoin Network for Anonymity.">9</a>]</strong></center>
<p>Both projects have adapted this approach to work with Mimblewimble transactions. Grin's implementation allows for transaction aggregation and cut-through in the stem phase of propagation which provides even greater anonymity to the transactions before they spread during the fluff phase [<a href="https://github.com/mimblewimble/grin/blob/master/doc/dandelion/dandelion.md" title="Dandelion in Grin: Privacy-Preserving Transaction Aggregation and Propogation">10</a>]. BEAM hasn't documented their approach in detail as yet but it is visible in their repository [<a href="https://github.com/beam-mw/beam" title="BEAM Github Repository">7</a>].</p>
<a class="header" href="#grin-unique-features" id="grin-unique-features"><h3>Grin unique features</h3></a>
<p>Grin is aiming to be a simple and minimal reference implementation of a Mimblewimble block chain so they are not aiming to include many features extending the core Mimblewimble functionality as discussed. However, the Grin implementation does include some interesting implementation choices which they have documented in depth on their growing Github repository's wiki.</p>
<p>Grin has implemented a method for a node to sync the block chain very quickly by only downloading a partial history [<a href="https://github.com/mimblewimble/grin/blob/master/doc/chain/chain_sync.md" title="Grin - Blockchain Syncing">11</a>]. A new node entering the network will query the current head block of the chain and then requests the block header at a horizon, in the example the horizon is initially set at 5000 blocks before the current head. The node then checks if there is enough data to confirm consensus and if there isn't it will increase its horizon until consensus is reached. At that point it will download the full UTXO set of the horizon block. This approach does introduce a few security risks but mitigations are provided and the result is that a node can sync to the network with an order of magnitude less data. BEAM requires a full sync for each new node [<a href="https://github.com/beam-mw/beam/wiki/Node-initial-synchronization" title="BEAM- Node initalization synchronization">12</a>].</p>
<a class="header" href="#beam-unique-features" id="beam-unique-features"><h3>BEAM unique features</h3></a>
<p>BEAM has set out to extend the feature set of Mimblewimble in a number of ways. BEAM will support both traditional confidential UTXOs which are signed with Bulletproofs but they will also support non-confidential UTXOs. This will be achieved by signing a transaction using their own non-confidential signature which reveals the amount transferred in the transaction but keeps the blinding factor secret [<a href="https://www.scribd.com/document/385080303/BEAM-Description-Comparison-With-Classical-MW" title="BEAM description. Comparison with classical MW">13</a>]. BEAM also supports setting an explicit incubation period on a UTXO which limits its ability to be spent to a specific number of blocks after its creation [<a href="https://www.scribd.com/document/385080303/BEAM-Description-Comparison-With-Classical-MW" title="BEAM description. Comparison with classical MW">13</a>]. This is different to a timelock which prevents a transaction from being added to a block before a certain time. BEAM also supports the traditional timelock feature but includes the ability to also specify an upper time limit after which the transaction can no longer be included in a block [<a href="https://www.scribd.com/document/385080303/BEAM-Description-Comparison-With-Classical-MW" title="BEAM description. Comparison with classical MW">13</a>]. This feature means that a party can be sure that if a transaction is not included in a block on the main block chain after a certain time that it will never appear.</p>
<p>Another unique feature of BEAM is an implementation of an auditable wallet. For a business to operate in a given regulatory environment it will need to demonstrate its compliance to the relevant authorities. BEAM has proposed a wallet designed for compliant businesses which generates additional public/private key pairs specifically for audit purposes. These signatures are used to tag transactions so that only the auditing authority who are given the public key can identify those transactions on the block chain but cannot create transactions with this tag themselves. This allows a business to provide visibility of their transactions to a given authority without compromising their privacy to the public [<a href="https://github.com/beam-mw/beam/wiki/Wallet-audit" title="BEAM - Wallet Audit">14</a>].</p>
<p>BEAM has also proposed another feature aimed at keeping the block chain as compact as possible. In Mimblewimble as transactions are added cut-through is performed which eliminates all intermediary transaction commitments [<a href="https://github.com/mimblewimble/grin/blob/master/doc/intro.md" title="Introduction to Mimblewimble and Grin">3</a>]. However, the transaction kernels for every transaction are never removed. BEAM has proposed a scheme to reuse these transaction kernels to validate subsequent transactions [<a href="https://www.scribd.com/document/385080303/BEAM-Description-Comparison-With-Classical-MW" title="BEAM description. Comparison with classical MW">13</a>]. In order to consume the existing kernels without compromising the transaction irreversibility principle BEAM proposes using a multiplier to be applied to an old kernel, by the same user who has visibility of the old kernel, to be used in a new transaction. In order to incentivize transactions to be built in this way BEAM includes a fee refund model for these types of transactions.</p>
<p>When constructing a valid Mimblewimble transaction the parties involved need to collaborate in order to choose blinding factors that balance. This interactive negotiation requires a number of steps and it implies that the parties need to be in communication to finalize the transaction. Grin facilitates this process by the two parties connecting directly to one another using a socket based channel for a &quot;real-time&quot; session. This means that both parties need to be online simultaneously. BEAM has implemented a secure Bulletin Board System (BBS) system that is run on BEAM full-nodes to allow for asynchronous negotiation of transactions [<a href="https://www.reddit.com/r/beamprivacy/comments/9fqbfg/beams_offline_transactions_using_secure_bbs_system/" title="Beam's offline transaction using Secure BBS system">15</a>]. Currently there is not a detailed description of exactly how this works but the idea is that the two parties can log into a node's BBS system at their leisure to perform the various steps involved in building a valid transaction.</p>
<p>Requiring the interactive participation of both parties in constructing a transaction can be a point of friction in using a Mimblewimble block chain. In addition to the secure BBS communication channel BEAM also supports one-sided transactions where the payee in a transaction who expects to be paid a certain amount can construct their half of the transaction and send this half constructed transaction to the payer. The payer can then finish constructing the transaction and publish it to the block chain. Under the normal Mimblewimble system this is not possible because it would involve revealing your blinding factor to the counterparty. BEAM solves this problem by using a process they call <em>kernel fusion</em> whereby a kernel can include a reference to another kernel so that it is only valid if both kernels are present in the transaction. In this way the payee can build their half of the transaction with a secret blinding factor and a kernel that compensates for their blinding factor that <strong>must</strong> be included when the payer completes the transaction [<a href="https://www.scribd.com/document/385080303/BEAM-Description-Comparison-With-Classical-MW" title="BEAM description. Comparison with classical MW">13</a>].</p>
<p>Both projects make use of a number of Merkle tree structures to keep tract of various aspects of the respective block chains. The exact trees and what they record is documented for both projects [<a href="https://github.com/mimblewimble/grin/blob/master/doc/merkle.md" title="GRIN - Merkle structures">16</a>], [<a href="https://github.com/beam-mw/beam/wiki/Merkle-trees" title="BEAM - Merkle trees">17</a>]. Beam however makes use of a Radix-Hash tree structure for some of their trees which is a modified Merkle tree that is also a binary search tree. This provides a number of features that the standard Merkle trees do not have which they exploit in their implementation [<a href="https://github.com/beam-mw/beam/wiki/Merkle-trees" title="BEAM - Merkle trees">17</a>].</p>
<p>The features discussed here can all be seen in the code at the time of writing, though that is not a guarantee that they are working. There are a couple of features that have been mentioned in the literature as planned for the future, which have not yet been implemented. These include embedding signed textual content into transactions that can be used to record contract text [<a href="https://www.scribd.com/document/385080303/BEAM-Description-Comparison-With-Classical-MW" title="BEAM description. Comparison with classical MW">13</a>] and also the issuing of confidential assets [<a href="https://github.com/beam-mw/beam/wiki/Confidential-assets" title="BEAM - Confidential assets">18</a>].</p>
<a class="header" href="#proof-of-work-mining-algorithm" id="proof-of-work-mining-algorithm"><h2>Proof of Work Mining Algorithm</h2></a>
<p>BEAM has opted to employ the Equihash Proof of Work (PoW) mining algorithm. Equihash was proposed in 2016 as a memory-hard PoW algorithm which relied heavily on memory-usage to achieve Application Specific Integrated Circuit (ASIC) resistance [<a href="https://www.cryptolux.org/images/b/b9/Equihash.pdf" title="Equihash: asymmetric proof-of-work based on the Generalized Birthday problem">19</a>]. The goal was to produce an algorithm that would be more efficient to run on consumer GPUs as opposed to the growing field of ASIC miners, mainly produced by Bitmain at the time. It was hoped this would aid in decentralising the mining power for cryptocurrencies that used this algorithm. The idea behind Equihash's ASIC resistance was that at the time implementing memory in an ASIC was expensive and so GPUs were more efficient at calculating the Equihash PoW. This ASIC resistance did last for a while but in early 2018 Bitmain released an ASIC for Equihash which were significantly more efficient than GPUs for the Equihash configurations used by Zcash, Bitcoin Gold and Zencash to name a few. It is possible to tweak the parameters of the Equihash algorithm to make it more memory intensive and thus make current ASICs and the older GPU mining farms obsolete but it remains to be seen if BEAM will do this. No block time has been published as of the writing of this report.</p>
<p>Grin initially opted to use the new Cuckoo Cycle PoW algorithm, also purported to be ASIC resistant due to being memory latency bound [<a href="https://github.com/tromp/cuckoo" title="Cuckoo Cycle">20</a>]. This means that the algorithm is bound by memory bandwidth rather than raw processor speed with the hope that it will make mining possible on commodity hardware.</p>
<p>In August 2018 the Grin team made an announcement that they have become aware that it was likely that an ASIC would be available for the Cuckoo cycle algorithm at launch of their mainnet [<a href="https://www.grin-forum.org/t/proof-of-work-update/713" title="Proof of work update">21</a>]. While they acknowledge that ASIC mining is inevitable they are concerned that the current ASIC market is very centralized (i.e. Bitmain) and that they want to foster a grassroots GPU mining community in the early days of Grin. Grin wants to aim to foster this community for 2 years by which time they hope that ASICs have become more of a commodity and thus decentralized.</p>
<p>To address this it was proposed to use two PoW algorithms initially. One that is ASIC Friendly (AF) and one that is ASIC Resistant (AR) and then select which PoW is used per block to balance the mining rewards over a 24h period between the two algorithms. The Governance committee resolved on 25 September to go ahead with this approach using a modified version of the Cuckoo cycle algorithm called Cuckatoo Cycle. The AF algorithm at launch will be Cuckatoo32+ which will gradually increase its memory requirements to make older single-chip ASICs obsolete over time. The AR algorithm is still not defined [<a href="https://www.grin-forum.org/t/meeting-notes-governance-sep-25-2018/874" title="Meeting Notes: Governance, Sep 25 2018">23</a>].</p>
<a class="header" href="#governance-models-and-monetary-policy" id="governance-models-and-monetary-policy"><h2>Governance Models and Monetary Policy</h2></a>
<p>Both the Grin and BEAM projects are open-source and available on Github [<a href="https://github.com/mimblewimble/grin" title="Grin Github Repository">6</a>], [<a href="https://github.com/beam-mw/beam" title="BEAM Github Repository">7</a>]. The Grin project has 75 contributors of which 8 have contributed the vast majority of the code. BEAM has 8 contributors of which 3 have contributed the vast majority of the code (at the time of writing). The two projects have opted for different models of governance. BEAM has opted to setup a foundation to manage the project and which the core developers are members of. This is the route taken by the majority of cryptocurrency projects in this space. The Grin community has decided against setting up a central foundation and has compiled an interesting discussion of the pro's and con's of a centralized foundation [<a href="https://github.com/mimblewimble/docs/wiki/Regarding-Foundations" title="Regarding Foundation">22</a>]. This document contains a very in depth discussion weighing up the various governance functions that a foundation might serve and evaluating each use-case in depth. The Grin community came to the conclusion that while foundations are useful that they do not represent the only solution to governance problems and have opted to remain a completely decentralized community driven project. Currently decisions are made by periodic governance meetings that are convened on Gitter with community members where an agenda is discussed and decisions are ratified. These meeting agendas and minutes can be found in the Grin Forums governance section and an example of the outcomes of such a meeting can be seen in [<a href="https://www.grin-forum.org/t/meeting-notes-governance-sep-25-2018/874" title="Meeting Notes: Governance, Sep 25 2018">23</a>].</p>
<p>Neither project will engage in an ICO or pre-mine but the two project also have different funding models. BEAM has attracted investors to its foundation for its initial round of funding and for sustainability will put 20% of each mining block rewards into a treasury to be used to fund further development and promotion of BEAM [<a href="https://www.beam-mw.com/features" title="BEAM Features">24</a>], in the industry this is called a <em>dev tax</em>. Grin will not levy a <em>dev tax</em> on the mining rewards and will rely on community participation and community funding. The Grin project does accept financial support but these funding campaigns are conducted according to their &quot;Community Funding Principles&quot; [<a href="https://grin-tech.org/funding.html" title="Grin's Community Funding Principles">25</a>] which will be conducted on a &quot;need-by-need&quot; basis. A campaign will specify a specific need it is aimed at fulfilling (e.g. &quot;Hosting fees for X for the next year&quot;) and the funding will be received by the community member who ran the campaign. This will provide 100% visibility on who is responsible for the received funds. An example of a funding campaign is the Developer Funding Campaign run by Yeastplume to fund his full-time involvement in the project from Oct 2018 to February 2019 can be seen in [<a href="https://grin-tech.org/yeastplume.html" title="Oct 2018 - Feb 2019 Developer Funding - Yeastplume">26</a>].</p>
<p>In terms of the monetary policy of the two projects BEAM has stated that they will be using a deflationary model with periodic halving of their mining reward and a maximum supply of BEAM of 210 million. They have not stated the details of the period of the halving. Grin has opted for an inflationary model where the block reward will remain constant, they make their arguments for this approach in [<a href="https://github.com/mimblewimble/docs/wiki/Monetary-Policy" title="Monetary Policy">27</a>]. This approach will asymptotically tend towards a zero percent dilution as the supply increases instead of enforcing a set supply [<a href="https://github.com/mimblewimble/grin/wiki/fees-mining" title="Economic Policy: Fees and Mining Reward">28</a>]. BEAM has not specified their mining reward or fees structure as yet but based on their current documentation Grin is planning on a 60 Grin per block reward. Neither project has made a final decision of how to structure fees but the Grin project has started to explore how to set a fee baseline by using a metric of &quot;fees per reward per minute&quot; [<a href="https://github.com/mimblewimble/grin/wiki/fees-mining" title="Economic Policy: Fees and Mining Reward">28</a>].</p>
<a class="header" href="#conclusions-observations-recommendations-1" id="conclusions-observations-recommendations-1"><h2>Conclusions, Observations, Recommendations</h2></a>
<p>In summary, Grin and BEAM are two open-source projects that are implementing the Mimblewimble block chain scheme. Both projects are building from scratch. Grin is using Rust while BEAM is using C++ and as such there are many technical differences in their design and implementations. However, from a functional perspective both projects will support all the core Mimblewimble functionality. Each project does contain some unique functionality but as Grin's goal is produce a minimalistic implementation of Mimblewimble the majority of the unique features that extend Mimblewimble lie in the BEAM project. The list below summarizes the functional similarities and differences between the two projects.</p>
<ul>
<li>Similarities:
<ul>
<li>Core Mimblewimble feature set</li>
<li>Dandelion relay protocol</li>
</ul>
</li>
<li>Grin unique features:
<ul>
<li>Partial history syncing</li>
<li>DAG representation of Mempool to prevent duplicate UTXO's and cyclic transaction references</li>
</ul>
</li>
<li>BEAM unique features:
<ul>
<li>Both confidential and non-confidential transactions</li>
<li>Explicit UTXO incubation period</li>
<li>Timelocks with a minimum and maximum threshold</li>
<li>Auditable transactions</li>
<li>Secure BBS system hosted on the nodes for non-interactive transaction negotiation</li>
<li>One-sided transaction construction</li>
<li>Incentives to consume old UTXO's in order to keep the block chain compact</li>
<li>Use of Radix-Hash trees</li>
</ul>
</li>
</ul>
<p>These projects are still very young, as of the writing of this report both are still in the testnet phase, and many of their core design choices have not been built or tested yet. Much of the BEAM wiki is still in Russian so it is likely there are details contained there that we are not privy to yet. It will be interesting to keep an eye on these projects to see how their various decisions play out both technically and in terms of their monetary policy and governance models.</p>
<a class="header" href="#references-10" id="references-10"><h2>References</h2></a>
<p>[<a href="https://download.wpsoftware.net/bitcoin/wizardry/mimblewimble.txt" title="MIMBLEWIMBLE">1</a>] T.E. Jedusor, &quot;MIMBLEWIMBLE&quot;, https://download.wpsoftware.net/bitcoin/wizardry/mimblewimble.txt, Date access: 2018-09-30</p>
<p>[<a href="https://download.wpsoftware.net/bitcoin/wizardry/mimblewimble.pdf" title="Mimblewimble">2</a>] A. Poelstra, &quot;Mimblewimble&quot;, https://download.wpsoftware.net/bitcoin/wizardry/mimblewimble.pdf, Date accessed: 2018-09-30</p>
<p>[<a href="https://github.com/mimblewimble/grin/blob/master/doc/intro.md" title="Introduction to Mimblewimble and Grin">3</a>] Introduction to Mimblewimble and Grin, https://github.com/mimblewimble/grin/blob/master/doc/intro.md, Date accessed: 2018-09-30.</p>
<p>[<a href="https://docs.wixstatic.com/ugd/87affd_3b032677d12b43ceb53fa38d5948cb08.pdf" title="BEAM: The Scalable Confidential Cryptocurrency">4</a>] BEAM: The Scalable Confidential Cryptocurrency, https://docs.wixstatic.com/ugd/87affd_3b032677d12b43ceb53fa38d5948cb08.pdf, Date accessed: 2018-09-28</p>
<p>[<a href="https://joinmarket.me/blog/blog/flipping-the-scriptless-script-on-schnorr/" title="Flipping the scriptless script on Schnorr by A. Gibson">5</a>] A. Gibson, &quot;Flipping the scriptless script on Schnorr&quot;, https://joinmarket.me/blog/blog/flipping-the-scriptless-script-on-schnorr/, Date accessed: 2018-09-30</p>
<p>[<a href="https://github.com/mimblewimble/grin" title="Grin Github Repository">6</a>] Grin Github Repository, https://github.com/mimblewimble/grin, Date accessed: 2018-09-30</p>
<p>[<a href="https://github.com/beam-mw/beam" title="BEAM Github Repository">7</a>] BEAM Github Repository, https://github.com/beam-mw/beam, Date accessed: 2018-09-30</p>
<p>[<a href="https://github.com/mimblewimble/grin/blob/master/doc/internal/pool.md" title="Grin - Transaction Pool">8</a>] Grin - Transaction Pool, https://github.com/mimblewimble/grin/blob/master/doc/internal/pool.md, Date accessed: 2018-10-22</p>
<p>[<a href="https://arxiv.org/abs/1701.04439" title="Dandelion: Redesigning the Bitcoin Network for Anonymity.">9</a>] Shaileshh Bojja Venkatakrishnan, Giulia Fanti, and Pramod Viswanath, &quot;Dandelion: Redesigning the Bitcoin Network for Anonymity.&quot;, Proc. ACM Meas. Anal. Comput. Syst. 1, 1, 2017</p>
<p>[<a href="https://github.com/mimblewimble/grin/blob/master/doc/dandelion/dandelion.md" title="Dandelion in Grin: Privacy-Preserving Transaction Aggregation and Propogation">10</a>] Dandelion in Grin: Privacy-Preserving Transaction Aggregation and Propogation, https://github.com/mimblewimble/grin/blob/master/doc/dandelion/dandelion.md, Date accessed: 2018-09-30</p>
<p>[<a href="https://github.com/mimblewimble/grin/blob/master/doc/chain/chain_sync.md" title="Grin - Blockchain Syncing">11</a>] Grin - Blockchain Syncing, https://github.com/mimblewimble/grin/blob/master/doc/chain/chain_sync.md, Date accessed: 2018-10-22</p>
<p>[<a href="https://github.com/beam-mw/beam/wiki/Node-initial-synchronization" title="BEAM- Node initalization synchronization">12</a>] BEAM- Node initalization synchronization, https://github.com/beam-mw/beam/wiki/Node-initial-synchronization, Date accessed: 2018-10-22</p>
<p>[<a href="https://www.scribd.com/document/385080303/BEAM-Description-Comparison-With-Classical-MW" title="BEAM description. Comparison with classical MW">13</a>] BEAM description. Comparison with classical MW, https://www.scribd.com/document/385080303/BEAM-Description-Comparison-With-Classical-MW, Date accessed: 2018-10-18</p>
<p>[<a href="https://github.com/beam-mw/beam/wiki/Wallet-audit" title="BEAM - Wallet Audit">14</a>] BEAM - Wallet Audit, https://github.com/beam-mw/beam/wiki/Wallet-audit, Date accessed: 2018-09-30</p>
<p>[<a href="https://www.reddit.com/r/beamprivacy/comments/9fqbfg/beams_offline_transactions_using_secure_bbs_system/" title="Beam's offline transaction using Secure BBS system">15</a>] Beam's offline transaction using Secure BBS system, https://www.reddit.com/r/beamprivacy/comments/9fqbfg/beams_offline_transactions_using_secure_bbs_system/, Date accessed: 2018-10-22</p>
<p>[<a href="https://github.com/mimblewimble/grin/blob/master/doc/merkle.md" title="GRIN - Merkle structures">16</a>] GRIN - Merkle structures, https://github.com/mimblewimble/grin/blob/master/doc/merkle.md, Date accessed: 2018-10-22</p>
<p>[<a href="https://github.com/beam-mw/beam/wiki/Merkle-trees" title="BEAM - Merkle trees">17</a>] BEAM - Merkle trees, https://github.com/beam-mw/beam/wiki/Merkle-trees, Date accessed: 2018-10-22</p>
<p>[<a href="https://github.com/beam-mw/beam/wiki/Confidential-assets" title="BEAM - Confidential assets">18</a>] BEAM - Confidential assets, https://github.com/beam-mw/beam/wiki/Confidential-assets, Date accessed: 2018-10-22</p>
<p>[<a href="https://www.cryptolux.org/images/b/b9/Equihash.pdf" title="Equihash: asymmetric proof-of-work based on the Generalized Birthday problem">19</a>] Alex Biryukov, Dmitry Khovratovich, &quot;Equihash: asymmetric proof-of-work based on the Generalized Birthday problem&quot;, Proceedings of NDSS, 2016</p>
<p>[<a href="https://github.com/tromp/cuckoo" title="Cuckoo Cycle">20</a>] Cuckoo Cycle, https://github.com/tromp/cuckoo, Date accessed: 2018-09-30</p>
<p>[<a href="https://www.grin-forum.org/t/proof-of-work-update/713" title="Proof of work update">21</a>] I. Peverell, &quot;Proof of work update&quot;, https://www.grin-forum.org/t/proof-of-work-update/713</p>
<p>[<a href="https://github.com/mimblewimble/docs/wiki/Regarding-Foundations" title="Regarding Foundation">22</a>] Regarding Foundation, https://github.com/mimblewimble/docs/wiki/Regarding-Foundations, Date accessed: 2018-09-30</p>
<p>[<a href="https://www.grin-forum.org/t/meeting-notes-governance-sep-25-2018/874" title="Meeting Notes: Governance, Sep 25 2018">23</a>] Meeting Notes: Governance, Sep 25 2018, https://www.grin-forum.org/t/meeting-notes-governance-sep-25-2018/874, Date accessed: 2018-09-30</p>
<p>[<a href="https://www.beam-mw.com/features" title="BEAM Features">24</a>] BEAM Features, https://www.beam-mw.com/features, Date accessed: 2018-09-30</p>
<p>[<a href="https://grin-tech.org/funding.html" title="Grin's Community Funding Principles">25</a>] Grin's Community Funding Principles, https://grin-tech.org/funding.html, Date accessed: 2018-09-28</p>
<p>[<a href="https://grin-tech.org/yeastplume.html" title="Oct 2018 - Feb 2019 Developer Funding - Yeastplume">26</a>] Oct 2018 - Feb 2019 Developer Funding - Yeastplume, https://grin-tech.org/yeastplume.html, Date accessed: 2018-09-30</p>
<p>[<a href="https://github.com/mimblewimble/docs/wiki/Monetary-Policy" title="Monetary Policy">27</a>] Monetary Policy, https://github.com/mimblewimble/docs/wiki/Monetary-Policy, Date accessed: 2018-09-30</p>
<p>[<a href="https://github.com/mimblewimble/grin/wiki/fees-mining" title="Economic Policy: Fees and Mining Reward">28</a>] Economic Policy: Fees and Mining Reward, https://github.com/mimblewimble/grin/wiki/fees-mining, Date accessed: 2018-09-30</p>
<p>[<a href="https://github.com/mimblewimble/grin/blob/master/doc/pow/pow.md" title="Grin's Proof-of-Work">29</a>] Grin's Proof-of-Work, https://github.com/mimblewimble/grin/blob/master/doc/pow/pow.md, Date accessed 2018-09-30</p>
<a class="header" href="#contributors-5" id="contributors-5"><h2>Contributors</h2></a>
<ul>
<li>https://github.com/philipr-za</li>
<li>https://github.com/hansieodendaal</li>
<li>https://github.com/SWvheerden</li>
</ul>
<a class="header" href="#appendices-1" id="appendices-1"><h2>Appendices</h2></a>
<p>This section contains some details on topics discussed above but whose details are not directly relevant to the Grin vs BEAM discussion.</p>
<a class="header" href="#appendix-a-cuckoocuckatoo-cycle-pow-algorithm" id="appendix-a-cuckoocuckatoo-cycle-pow-algorithm"><h3>Appendix A: Cuckoo/Cuckatoo Cycle PoW algorithm</h3></a>
<p>The Cuckoo Cycle algorithm is based on finding cycles of a certain length of edges in a bipartite graph of N nodes and M edges. The graph is bipartite because it consists of two separate groups of nodes with edges that connect nodes from one set to the other. As an example let's consider nodes with even indices to be in one group and nodes with odd indices in a second group. Figure 2 shows 8 nodes with 4 randomly placed edges, N = 8 and M = 4. So if we are looking for cycles of length 4 we can easily confirm that none exist in Figure 2. By adjusting the number of edges present in the graph vs the number of nodes we can control the probability that a cycle of a certain length exists in the graph. When looking for cycles of length 4 the difficulty illustrated in Figure 2 a 4/8 (M/N) graph would mean that the 4 edges would need to be randomly chosen in an exact cycle for one to exist [<a href="https://github.com/mimblewimble/grin/blob/master/doc/pow/pow.md" title="Grin's Proof-of-Work">29</a>].</p>
<p align="center"><img src="sources/cuckoo_base_numbered_few_edges.png" width="250"/></p>
<center><strong>Figure 2: 8 Nodes with 4 Edges, no Solution [<a href="https://github.com/mimblewimble/grin/blob/master/doc/pow/pow.md" title="Grin's Proof-of-Work">29</a>]</center></strong>
<p>If we increase the number of edges in the graph relative to the number of nodes we adjust the probability of a cycle occurring in the randomly chosen set of edges. Figure 3 shows an example of M = 7 and N = 8 case and it can be seen that a 4 edge cycle appeared. Thus, we can control the probability of a cycle of a certain length occurring by adjusting the ratio of M/N [<a href="https://github.com/mimblewimble/grin/blob/master/doc/pow/pow.md" title="Grin's Proof-of-Work">29</a>].</p>
<p align="center"><img src="sources/cuckoo_base_numbered_few_edges_cycle.png" width="250"/></p>
<center><strong>Figure 3: Cycle Found from 0-5-4-1-0 [<a href="https://github.com/mimblewimble/grin/blob/master/doc/pow/pow.md" title="Grin's Proof-of-Work">29</a>]</center></strong>
<p>Detecting that a cycle of a certain length has occurred in a graph with randomly selected edges becomes significantly more difficult as the number as the graphs get larger. Figure 4 shows a 22 node graph with 14 random edges in it. Can you determine if a cycle of 8 edges is present? [<a href="https://github.com/mimblewimble/grin/blob/master/doc/pow/pow.md" title="Grin's Proof-of-Work">29</a>]</p>
<p align="center"><img src="sources/cuckoo_base_numbered_many_edges.png" width="650"/></p>
<center><strong>Figure 4: 22 Nodes with 14 Edges, can you find a Cycle 8 Edges Long? [<a href="https://github.com/mimblewimble/grin/blob/master/doc/pow/pow.md" title="Grin's Proof-of-Work">29</a>]</center></strong>
<p>The Cuckoo cycle PoW algorithm is built to solve this problem. The bipartite graph that is analyzed is called a &quot;Cuckoo Hashtable&quot; where a key is inserted into two arrays, each with their own hash function, into a location based on the hash of the key. Each key inserted in this way produces an edge between the locations generated by the two hashing functions. Nonces are enumerated for the hashing functions until a cycle is detected of the desired length. This algorithm has two main parameters that control it's difficult which is the M/N ratio and the number of nodes in the graph. There are a number of variants of this algorithm that make speed/memory tradeoffs [<a href="https://github.com/tromp/cuckoo" title="Cuckoo Cycle">20</a>]. In Grin a third difficulty parameter was introduced to more finely tune the difficulty of the PoW algorithm to ensure a 1 minute block time in the face of changing network hash rates. This was to take a Blake2b hash of the set of nonces and ensure that the result is above a difficulty threshold [<a href="https://github.com/mimblewimble/grin/blob/master/doc/pow/pow.md" title="Grin's Proof-of-Work">29</a>].</p>
<a class="header" href="#grin-design-choice-criticisms---truth-or-fiction" id="grin-design-choice-criticisms---truth-or-fiction"><h1>Grin Design Choice Criticisms - Truth or Fiction</h1></a>
<a class="header" href="#introduction-7" id="introduction-7"><h2>Introduction</h2></a>
<p>Grin is a cryptocurrency implemented in Rust that makes use of Mimblewimble transactions and the Cuckatoo algorithm to perform Proof-of-Work (PoW) calculations. The main design goals of the Grin project are: privacy, transaction scaling and design simplicity to promote long term maintenance of the Grin source code [<a href="https://medium.com/novamining/grin-testnet-is-live-98b0f8cd135d" title="Grin: a lightweight implementation of
the MimbleWimble protocol, Mattia Franzoni">1</a>].</p>
<p>During the development of the Grin project, the developers have received criticisms from the community on a number of the design and implementation decisions that they have made. This report will have a look at some of these criticisms and determine if there are some truth to these concerns or if the concerns are unwarranted or invalid. Some suggestions will be made on how these problems could be improved or addressed.</p>
<p align="center"><img src="sources/intro.png" width="700" /></p>
<p>This report will also investigate their selected emission scheme, PoW algorithm, selection of key-store library and their choice of cryptographic curve used for signatures. Each of these topics will be discussed in detail, starting with their selected emission scheme.</p>
<a class="header" href="#contents-3" id="contents-3"><h2>Contents</h2></a>
<ul>
<li><a href="#grin-design-choice-criticisms---truth-or-fiction">Grin Design Choice Criticisms - Truth or Fiction</a>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#contents">Contents</a></li>
<li><a href="#monetary-policy-due-to-static-emission-scheme">Monetary Policy Due to Static Emission Scheme</a></li>
<li><a href="#from-asic-resistant-to-asic-friendly">From ASIC Resistant to ASIC Friendly</a></li>
<li><a href="#choice-of-cryptographic-elliptic-curve---secp256k1">Choice of Cryptographic Elliptic-curve - secp256k1</a></li>
<li><a href="#selection-of-key-store-library">Selection of Key-store Library</a></li>
<li><a href="#conclusions-observations-recommendations">Conclusions, Observations, Recommendations</a></li>
<li><a href="#references">References</a></li>
<li><a href="#contributors">Contributors</a></li>
</ul>
</li>
</ul>
<a class="header" href="#monetary-policy-due-to-static-emission-scheme" id="monetary-policy-due-to-static-emission-scheme"><h2>Monetary Policy Due to Static Emission Scheme</h2></a>
<p>Bitcoin has a limited and finite supply of coins. It makes use of 10-minute block times, where the initial reward for solving the first block was 50 BTC. This reward is reduced every 4 years, by halving it, until a maximum of 21 million coins are in circulation [<a href="https://bitcoin.org/bitcoin.pdf" title="Bitcoin: A Peer-to-Peer Electronic
Cash System, Satoshi Nakamoto,">2</a>]. During this process, the transaction fees and newly minted coins are paid to miners and is used as an incentive for miners to maintain the blockchain. Once all 21 million Bitcoins are released, only transaction fees will be paid to miners. Many fear that paying miners only transaction fees in the future will not be sufficient to maintain a large network of miners and it will result in the centralisation of the network, as only large mining farms will be able to perform the mining task in a profitable manner. Others believe that in time mining fees will increase and hardware costs for miners will decrease making the act of mining and maintaining the bitcoin blockchain remain lucrative and profitable [<a href="https://www.investopedia.com/tech/what-happens-bitcoin-after-21-million-mined/" title="What Happens to Bitcoin After
All 21 Million are Mined?, Nathan Reiff">3</a>].</p>
<p>Grin has decided on a different approach, where their number of coins will not be capped at a fixed supply. It will make use of a static emission rate, where a constant 60 Grin is released as a reward for solving every block. Their algorithm makes use of a block goal of 60 seconds. This will result in roughly 1 coin being created every second for as long as the blockchain is being maintained [<a href="https://www.grin-forum.org/t/emmission-rate-of-grin/171" title="Emission rate of Grin">4</a>].</p>
<p>Their primary motivations for selecting a static emission rate are:</p>
<ul>
<li>there will be no upper limit on the amount of coins that can be created,</li>
<li>the percentage of newly created coins compared to the total coins in circulation will tend toward zero,</li>
<li>it will mitigate the effect of orphaned and lost coins,</li>
<li>it will encourage spending rather than holding of coins.</li>
</ul>
<p>The selected emission rate will result in Grin becoming a high inflationary currency with more than 10% inflation for the first 10 years, that is higher than most competing cryptocurrencies or successful fiat systems. This is in comparison to other cryptocurrencies such as Monero, that will have less than 1% inflation after the first 8 years in circulation and have a decreasing 0.87% inflation with the start of their tail emissions [<a href="https://www.reddit.com/r/Monero/comments/512kwh/useful_for_learning_about_monero_coin_emission/d78tpgi" title="Coin Emission and Block Reward
Schedules: Bitcoin vs. Monero">5</a>]. Monero will have a better potential of being used as a Store of Value (SoV) in the long run.</p>
<p>The fixed emission rate of Grin on the other hand will limit its use as a SoV, as it will experience constant price pressure, which might make it difficult for Grin to maintain a high value initially, while the inflation rate remains high. This high inflation rate might encourage Grin to rather be used as a Medium of Exchange (MoE)  [<a href="https://www.reddit.com/r/grincoin/comments/91g1nx/on_grin_mimblewimble_and_monetary_policy/" title="On Grin, MimbleWimble, and Monetary Policy">6</a>], as it will take approximately 50 years for the inflation to drop below 2%. The Grin team believes that the inflation rate is not that high as many coins are lost and become unusable on a blockchain. These lost coins, which they believe can be as much as 2% per year of the total supply, should be excluded from the inflation rate calculation [<a href="https://github.com/mimblewimble/docs/wiki/Monetary-Policy" title="Grin - Monetary Policy">7</a>]. The total percent of lost transactional coins are difficult to estimate [<a href="http://fortune.com/2017/11/25/lost-bitcoins/" title="Exclusive: Nearly 4 Million Bitcoin Lost Forever,
New Study Says, Jeff J. Roberts and Nicolas Rapp">8</a>] and it seems as if this value is higher for low value coins compared to high value coins where users tend to be more careful. The Grin team believes that by selecting a high inflation rate it will improve the distribution of coins as holding of coins will be discouraged. They also hope that a high inflation rate will produce natural pricing and limit price manipulation by large coin holders [<a href="https://github.com/mimblewimble/docs/wiki/Monetary-Policy" title="Grin - Monetary Policy">7</a>].</p>
<p>Most economists for traditional fiat systems agree that deflation is bad as it increases debt and some inflation is good as it stimulates the economy of a country [<a href="https://cryptobriefing.com/how-inflationary-should-cryptocurrency-be/" title="How Inflationary should Cryptocurrency
really be?, Andrew Ancheta">9</a>]. With inflation the purchasing power of savings decrease over time, which encourages the purchasing of goods and services, resulting in the currency being used as a MoE rather than a SoV.  People with debt such as study, vehicle and home loans also benefit from inflation as it produces an eroding effect on the total debt for long periods of repayment. Currently, this benefit does not apply to cryptocurrencies as not much debt exists as it is difficult to maintain successful borrower-lender relationships due to the anonymous nature of cryptocurrencies [<a href="https://cryptoinsider.21mil.com/debtcoin-credit-debt-and-cryptocurrencies/" title="Debtcoin: Credit, debt, and
cryptocurrencies, Landon Mutch">10</a>].</p>
<p>On the other hand, deflation in traditional fiat systems, produce over time an increase of purchasing power that encourages saving and discourages debt, resulting in the currency being used as a SoV. Unfortunately, this comes with a negative side effect that people will stop purchasing goods and services. Bitcoin can be considered deflationary as people would rather buy and hold Bitcoins as the price per coin might increase over time, this is limiting its use as a MoE. Also, high deflation can cause a deflationary spiral, as people with debt will have more debt and people with money will start hoarding their money as it might be worth more at a later stage [<a href="https://blockonomi.com/bitcoin-deflation/" title="Inflation vs Deflation: A Guide to Bitcoin &amp;
Cryptocurrencies Deflationary Nature, Brian Curran">11</a>]. Deflation in traditional fiat systems typically tend to only happen in times of economic crisis and recession and is managed by introducing inflation using monetary policies [<a href="https://www.investopedia.com/articles/personal-finance/030915/why-deflation-bad-economy.asp" title="Why Is Deflation Bad for the
Economy?, Adam Hayes">12</a>].</p>
<p>As most inflationary fiat systems are government backed, they are able to control the amount of inflation to help alleviate government debt and finance budget deficits [<a href="https://www.nationalaffairs.com/publications/detail/inflation-and-debt" title="Inflation and Debt, John H. Cochrane">13</a>].  This could result in hyperinflation where the devaluation of currency occur at an extreme pace resulting in many people losing their savings and pensions [<a href="https://medium.com/@Digix/think-piece-fighting-hyperinflation-with-cryptocurrencies-a08fe86bb66a" title="Think Piece: Fighting Hyperinflation
with Cryptocurrencies, Lucia Ziyuan">14</a>]. Cryptocurrencies on the other hand provide a transparent algorithmic monetary inflation that is not controlled by a central authority or government, limiting its misuse.</p>
<p>Finding a good balance between being a SoV and MoV is an important issue for developing a successful currency. A balance between deflation and inflation need to be selected to motivate saving and at the same time spending of a currency. A low inflationary model where inflation is algorithmically maintained and not controlled by a single authority seem like the safest choice, but only time will tell if the high inflation model proposed by Grin will have the desired effect.</p>
<a class="header" href="#from-asic-resistant-to-asic-friendly" id="from-asic-resistant-to-asic-friendly"><h2>From ASIC Resistant to ASIC Friendly</h2></a>
<p>Initially, the Grin team proposed using two Application-Specific Integrated Circuit (ASIC) resistant algorithms: Cuckoo cycles and a high memory requirement Equihash algorithm called Equigrin. These algorithms were selected to encourage mining decentralisation. ASIC resistance was obtained by having high memory requirements for the PoW algorithms, limiting its calculation to Central Processing Units (CPUs) and High-range Graphics Processing Units (GPUs) [<a href="https://www.grin-forum.org/t/proof-of-work-update/713" title="Grin - Proof of Work update">15</a>]. The plan was to adjust the parameters of these PoW algorithms every 6 months to deter stealth ASIC mining and move over to using only Cuckoo cycles as the primary PoW algorithm.</p>
<p>Recently, the Grin team proposed to switch to a new dual PoW system, where one PoW algorithm is ASIC friendly and the other PoW algorithm is not. Grin will now make use of the new Cuckatoo Cycle algorithm, but details of their second PoW algorithm remain vague. The Cuckatoo PoW algorithm is a variation of Cuckoo that aims to be more ASIC friendly [<a href="https://www.grin-forum.org/t/meeting-notes-governance-sep-25-2018/874" title="Grin - Meeting Notes: Governance, Sep 25 2018">16</a>].  This is achieved by using plain bits for ternary counters and requiring large amounts of Static Random-Access Memory (SRAM) to speed up the memory latency bound access of random node bits. SRAM tends to be limited on GPU and CPU processors, but increasing SRAM on ASIC processors is much easier to implement [<a href="https://github.com/tromp/cuckoo" title="Cuck(at)oo Cycle">17</a>].</p>
<p align="center"><img src="sources/attack51.jpg" width="550" /></p>
<p>ASIC miners tend to be specialised hardware that are very efficient at calculating and solving specific PoW algorithms. Encouraging ASIC miners on a network might not seem like a bad idea as the mining network will have a higher hash rate. This will make it more difficult to hack and it will use less electrical power compared to using primarily CPU and GPU based miners.</p>
<p>Unfortunately, a negative side effect of running a PoW algorithm that is ASIC friendly is that the network of miners will become more centralised. General consumers do not have access or a need for this type of hardware; this limits the use of ASIC miners to be primarily reserved for enthusiasts and large corporations establishing mining farms. Having the majority of the networks hash rate localised in large mining farms will result in the blockchain becoming more vulnerable to potential 51% attacks [<a href="https://www.investopedia.com/terms/1/51-attack.asp" title="51% Attack">18</a>], especially when specific ASIC manufacturers recommend or enforce their hardware to make use of specific mining pools that are controlled by single bodies.</p>
<p align="center"><img src="sources/gpu_mining.jpg" width="450" /></p>
<p>Using general purpose and multi-use hardware such as CPUs and GPUs that are primarily used for gaming and large workstations, ensures that the network of miners is more widely distributed and that it is not controlled by a single potential bad player. This will make it more difficult for a single entity to control more than 50% of the networks hash rate or total computational power, limiting the potential of double spends.</p>
<p>Selecting to be ASIC resistant or ASIC friendly is an important decision that can affect the security of the blockchain. The Grin team's choice to support the ASIC community and trying to balancing an ASIC friendly and an ASIC resistant PoW algorithm will be interesting with many potential pitfalls.</p>
<a class="header" href="#choice-of-cryptographic-elliptic-curve---secp256k1" id="choice-of-cryptographic-elliptic-curve---secp256k1"><h2>Choice of Cryptographic Elliptic-curve - secp256k1</h2></a>
<p>Elliptic curve cryptography is used for generating Private and Public key pairs that can be used for digital signatures as well as authorisation for individuals and transactions. It is much more secure and requires smaller keys for similar security compared to other Public-key cryptography techniques such as RSA [<a href="https://hackernoon.com/what-is-the-math-behind-elliptic-curve-cryptography-f61b25253da3" title="What is the math behind elliptic
curve cryptography?, Hans Knutson">19</a>]</p>
<p align="center"><img src="sources/publickey.png" width="700" /></p>
<p>Secp256k1 is an elliptic curve defined in the Standards for Efficient Cryptography [<a href="http://www.secg.org/" title="Standards for Efficient Cryptography Group">20</a>] and is used for digital signatures in a number of cryptocurrencies such as Bitcoin, Ethereum, EOS, Litecoin, etc. [<a href="https://en.bitcoin.it/wiki/Secp256k1" title="Secp256k1">21</a>]. Grin also makes use of this same elliptic curve [<a href="https://www.grin-forum.org/t/schnorr-signatures-in-grin-information/730" title="Grin - Schnorr signatures in Grin &amp; information">22</a>]. Some security experts recommend not using the secp256k1 curve as some issues have been uncovered, but not necessarily exploited. One of these problems are that the complex-multiplication field discriminant is not high enough to be secure. This could result in potential future exploits as curves with low complex-multiplication field discriminant tend to be easier to break [<a href="http://safecurves.cr.yp.to/disc.html" title="SafeCurves - CM field discriminants">23</a>].</p>
<p>Starting a project with a potentially compromised curve does not seem like a good idea, especially when other curves with better security properties and characteristics do exist. A number of alternative curves exist that could be used to improve security such as Curve25519 that can be used with the improved Ed25519 public-key signature system. The Ed25519 signature scheme makes use of the Edwards-curve Digital Signature Algorithm (EdDSA) and uses SHA-512 and Curve25519 [<a href="https://cr.yp.to/ecdh/curve25519-20060209.pdf" title="Curve25519: New Diffie-Hellman
Speed Records, Daniel J. Bernstein">24</a>] to build a fast signature scheme without sacrificing security.</p>
<p>Many additional alternatives exist and platforms such as SafeCurves, maintained by Daniel J. Bernstein and Tanje Lange can help the investigation and selection of an alternate security curve. The SafeCurves platform will make it easier to evaluate the security properties and potential vulnerabilities of many cryptographic curves [<a href="http://safecurves.cr.yp.to/" title="SafeCurves - choosing safe curves
for elliptic-curve cryptography">25</a>].</p>
<a class="header" href="#selection-of-key-store-library" id="selection-of-key-store-library"><h2>Selection of Key-store Library</h2></a>
<p>Grin originally made use of RocksDB [<a href="https://rocksdb.org/" title="RocksDB">26</a>] as an internal key-value store, but received some criticism for this decision. A number of alternatives with other performance and security characteristics exist such as LevelDB [<a href="http://leveldb.org/" title="LevelDB">27</a>], HyperLevelDB [<a href="http://hyperdex.org/" title="HyperLevelDB">28</a>] and the Lightning Memory-Mapped Database (LMDB) [<a href="https://github.com/LMDB" title="LMDB">29</a>]. Selecting between these to find the &quot;best&quot; key-value store library for blockchain applications remains a difficult problem as many online sources with conflicting information exist.</p>
<p>Based on the controversial results from a number of online benchmarks it seems as if some of these alternatives have better performance such as producing small database sizes and performing faster queries [<a href="https://www.influxdata.com/blog/benchmarking-leveldb-vs-rocksdb-vs-hyperleveldb-vs-lmdb-performance-for-influxdb/" title="Benchmarking LevelDB vs. RocksDB vs.
HyperLevelDB vs. LMDB Performance
for InfluxDB, Paul Dix">30</a>]. As an example, RocksDB or LevelDB seem incorrectly to be better alternatives to LMDB as they produced the fastest reads and deletes and produce some of the smallest databases compared to the other database libraries [<a href="https://github.com/lmdbjava/benchmarks/blob/master/results/20160630/README.md" title="Lmdbjava - benchmarks, Ben Alex">31</a>]. This is not entirely true as some mistakes were made during the testing process. Howard Chu wrote an article entitled &quot;Lies, Damn Lies, Statistics, and Benchmarks&quot; that exposes some of these issues and show that LMDB is the best key-value store library [<a href="https://www.linkedin.com/pulse/lies-damn-statistics-benchmarks-howard-chu" title="Lies, Damn Lies, Statistics, and Benchmarks, Howard Chu">32</a>]. Other benchmarks performed by Symas Corp support this claim, where LMDB outperformed all the tested key store libraries [<a href="http://www.lmdb.tech/bench/hyperdex/" title="HyperDex Benchmark, Symas Corp">33</a>].</p>
<p>Grin later replaced RocksDB with LMDB to maintain the state of Grin Wallets [<a href="https://github.com/mimblewimble/grin/blob/master/doc/wallet/usage.md" title="Grin - Basic Wallet">34</a>], [<a href="https://www.grin-forum.org/t/yeastplume-progress-update-thread-may-sept-2018/361/12" title="Progress update May - Sep 2018, Yeastplume">35</a>]. This switch looks to be a good idea as LMDB seem to be the best key-value store library for blockchain related applications.</p>
<a class="header" href="#conclusions-observations-recommendations-2" id="conclusions-observations-recommendations-2"><h2>Conclusions, Observations, Recommendations</h2></a>
<ul>
<li>Selecting the correct emission rate to create a sustainable monetary policy is an important decision and care should be taken to ensure that the right balance is found between being a SoV and/or a MoE.</li>
<li>Weighing the benefits and potential issues of being ASIC friendly compared to ASIC resistant need to be carefully evaluated.</li>
<li>Tools such as SafeCurves can be used to select a secure elliptic curve for an application. Cryptographic curves with even potential security vulnerabilities should rather be ignored.</li>
<li>Care should be taken when using online benchmarks to help select libraries for a project as the results might be misleading.</li>
</ul>
<a class="header" href="#references-11" id="references-11"><h2>References</h2></a>
<p>[<a href="https://medium.com/novamining/grin-testnet-is-live-98b0f8cd135d" title="Grin: a lightweight implementation of
the MimbleWimble protocol, Mattia Franzoni">1</a>]  Grin: a lightweight implementation of the MimbleWimble protocol, Mattia Franzoni, https://medium.com/novamining/grin-testnet-is-live-98b0f8cd135d, Date accessed: 2018-10-05.</p>
<p>[<a href="https://bitcoin.org/bitcoin.pdf" title="Bitcoin: A Peer-to-Peer Electronic
Cash System, Satoshi Nakamoto,">2</a>] Bitcoin: A Peer-to-Peer Electronic Cash System, Satoshi Nakamoto, https://bitcoin.org/bitcoin.pdf, Date accessed: 2018-10-05.</p>
<p>[<a href="https://www.investopedia.com/tech/what-happens-bitcoin-after-21-million-mined/" title="What Happens to Bitcoin After
All 21 Million are Mined?, Nathan Reiff">3</a>] What Happens to Bitcoin After All 21 Million are Mined?, Nathan Reiff, https://www.investopedia.com/tech/what-happens-bitcoin-after-21-million-mined/, Date accessed: 2018-10-07.</p>
<p>[<a href="https://www.grin-forum.org/t/emmission-rate-of-grin/171" title="Emission rate of Grin">4</a>] Emission rate of Grin, https://www.grin-forum.org/t/emmission-rate-of-grin/171, Date accessed: 2018-10-15.</p>
<p>[<a href="https://www.reddit.com/r/Monero/comments/512kwh/useful_for_learning_about_monero_coin_emission/d78tpgi" title="Coin Emission and Block Reward
Schedules: Bitcoin vs. Monero">5</a>] Coin Emission and Block Reward Schedules: Bitcoin vs. Monero, https://www.reddit.com/r/Monero/comments/512kwh/useful_for_learning_about_monero_coin_emission/d78tpgi, Date accessed: 2018-10-15.</p>
<p>[<a href="https://www.reddit.com/r/grincoin/comments/91g1nx/on_grin_mimblewimble_and_monetary_policy/" title="On Grin, MimbleWimble, and Monetary Policy">6</a>] On Grin, MimbleWimble, and Monetary Policy,  https://www.reddit.com/r/grincoin/comments/91g1nx/on_grin_mimblewimble_and_monetary_policy/, Date accessed: 2018-10-07.</p>
<p>[<a href="https://github.com/mimblewimble/docs/wiki/Monetary-Policy" title="Grin - Monetary Policy">7</a>] Grin - Monetary Policy, https://github.com/mimblewimble/docs/wiki/Monetary-Policy, Date accessed: 2018-10-08.</p>
<p>[<a href="http://fortune.com/2017/11/25/lost-bitcoins/" title="Exclusive: Nearly 4 Million Bitcoin Lost Forever,
New Study Says, Jeff J. Roberts and Nicolas Rapp">8</a>] Exclusive: Nearly 4 Million Bitcoin Lost Forever, New Study Says, Jeff J. Roberts and Nicolas Rapp, http://fortune.com/2017/11/25/lost-bitcoins/, Date accessed: 2018-10-08.</p>
<p>[<a href="https://cryptobriefing.com/how-inflationary-should-cryptocurrency-be/" title="How Inflationary should Cryptocurrency
really be?, Andrew Ancheta">9</a>] How Inflationary should Cryptocurrency really be?, Andrew Ancheta, https://cryptobriefing.com/how-inflationary-should-cryptocurrency-be/, Date accessed: 2018-11-06.</p>
<p>[<a href="https://cryptoinsider.21mil.com/debtcoin-credit-debt-and-cryptocurrencies/" title="Debtcoin: Credit, debt, and
cryptocurrencies, Landon Mutch">10</a>] Debtcoin: Credit, debt, and cryptocurrencies, Landon Mutch, https://cryptoinsider.21mil.com/debtcoin-credit-debt-and-cryptocurrencies/, Date accessed: 2018-11-06.</p>
<p>[<a href="https://blockonomi.com/bitcoin-deflation/" title="Inflation vs Deflation: A Guide to Bitcoin &amp;
Cryptocurrencies Deflationary Nature, Brian Curran">11</a>] Inflation vs Deflation: A Guide to Bitcoin &amp; Cryptocurrencies Deflationary Nature, Brian Curran, https://blockonomi.com/bitcoin-deflation/, Date accessed: 2018-11-06.</p>
<p>[<a href="https://www.investopedia.com/articles/personal-finance/030915/why-deflation-bad-economy.asp" title="Why Is Deflation Bad for the
Economy?, Adam Hayes">12</a>] Why Is Deflation Bad for the Economy?, Adam Hayes, https://www.investopedia.com/articles/personal-finance/030915/why-deflation-bad-economy.asp, Date accessed: 2018-11-06.</p>
<p>[<a href="https://www.nationalaffairs.com/publications/detail/inflation-and-debt" title="Inflation and Debt, John H. Cochrane">13</a>] Inflation and Debt, John H. Cochrane, https://www.nationalaffairs.com/publications/detail/inflation-and-debt, Date accessed: 2018-11-07.</p>
<p>[<a href="https://medium.com/@Digix/think-piece-fighting-hyperinflation-with-cryptocurrencies-a08fe86bb66a" title="Think Piece: Fighting Hyperinflation
with Cryptocurrencies, Lucia Ziyuan">14</a>] Think Piece: Fighting Hyperinflation with Cryptocurrencies, Lucia Ziyuan, https://medium.com/@Digix/think-piece-fighting-hyperinflation-with-cryptocurrencies-a08fe86bb66a, Date accessed: 2018-11-07.</p>
<p>[<a href="https://www.grin-forum.org/t/proof-of-work-update/713" title="Grin - Proof of Work update">15</a>] Grin - Proof of Work update, https://www.grin-forum.org/t/proof-of-work-update/713, Date accessed: 2018-10-15.</p>
<p>[<a href="https://www.grin-forum.org/t/meeting-notes-governance-sep-25-2018/874" title="Grin - Meeting Notes: Governance, Sep 25 2018">16</a>] Grin - Meeting Notes: Governance, Sep 25 2018, https://www.grin-forum.org/t/meeting-notes-governance-sep-25-2018/874, Date accessed: 2018-10-15.</p>
<p>[<a href="https://github.com/tromp/cuckoo" title="Cuck(at)oo Cycle">17</a>] Cuck(at)oo Cycle, https://github.com/tromp/cuckoo, Date accessed: 2018-10-15.</p>
<p>[<a href="https://www.investopedia.com/terms/1/51-attack.asp" title="51% Attack">18</a>] 51% Attack, https://www.investopedia.com/terms/1/51-attack.asp, Date accessed: 2018-10-11.</p>
<p>[<a href="https://hackernoon.com/what-is-the-math-behind-elliptic-curve-cryptography-f61b25253da3" title="What is the math behind elliptic
curve cryptography?, Hans Knutson">19</a>] What is the math behind elliptic curve cryptography?, Hans Knutson, https://hackernoon.com/what-is-the-math-behind-elliptic-curve-cryptography-f61b25253da3, Date accessed: 2018-10-14.</p>
<p>[<a href="http://www.secg.org/" title="Standards for Efficient Cryptography Group">20</a>] Standards for Efficient Cryptography Group, http://www.secg.org/, Date accessed: 2018-10-11.</p>
<p>[<a href="https://en.bitcoin.it/wiki/Secp256k1" title="Secp256k1">21</a>] Secp256k1, https://en.bitcoin.it/wiki/Secp256k1, Date accessed: 2018-10-15.</p>
<p>[<a href="https://www.grin-forum.org/t/schnorr-signatures-in-grin-information/730" title="Grin - Schnorr signatures in Grin &amp; information">22</a>] Grin - Schnorr signatures in Grin &amp; information, https://www.grin-forum.org/t/schnorr-signatures-in-grin-information/730, Date accessed: 2018-10-08.</p>
<p>[<a href="http://safecurves.cr.yp.to/disc.html" title="SafeCurves - CM field discriminants">23</a>] SafeCurves - CM field discriminants, http://safecurves.cr.yp.to/disc.html, Date accessed: 2018-10-15.</p>
<p>[<a href="https://cr.yp.to/ecdh/curve25519-20060209.pdf" title="Curve25519: New Diffie-Hellman
Speed Records, Daniel J. Bernstein">24</a>] Curve25519: New Diffie-Hellman Speed Records, Daniel J. Bernstein, https://cr.yp.to/ecdh/curve25519-20060209.pdf, Date accessed: 2018-10-15.</p>
<p>[<a href="http://safecurves.cr.yp.to/" title="SafeCurves - choosing safe curves
for elliptic-curve cryptography">25</a>] SafeCurves - choosing safe curves for elliptic-curve cryptography, http://safecurves.cr.yp.to/, Date accessed: 2018-10-10.</p>
<p>[<a href="https://rocksdb.org/" title="RocksDB">26</a>] RocksDB, https://rocksdb.org/, Date accessed: 2018-10-10.</p>
<p>[<a href="http://leveldb.org/" title="LevelDB">27</a>] LevelDB, http://leveldb.org/, Date accessed: 2018-10-15.</p>
<p>[<a href="http://hyperdex.org/" title="HyperLevelDB">28</a>] HyperLevelDB, http://hyperdex.org/, Date accessed: 2018-10-15.</p>
<p>[<a href="https://github.com/LMDB" title="LMDB">29</a>] LMDB, https://github.com/LMDB, Date accessed: 2018-10-29.</p>
<p>[<a href="https://www.influxdata.com/blog/benchmarking-leveldb-vs-rocksdb-vs-hyperleveldb-vs-lmdb-performance-for-influxdb/" title="Benchmarking LevelDB vs. RocksDB vs.
HyperLevelDB vs. LMDB Performance
for InfluxDB, Paul Dix">30</a>] Benchmarking LevelDB vs. RocksDB vs. HyperLevelDB vs. LMDB Performance for InfluxDB, Paul Dix, https://www.influxdata.com/blog/benchmarking-leveldb-vs-rocksdb-vs-hyperleveldb-vs-lmdb-performance-for-influxdb/, Date accessed: 2018-10-15.</p>
<p>[<a href="https://github.com/lmdbjava/benchmarks/blob/master/results/20160630/README.md" title="Lmdbjava - benchmarks, Ben Alex">31</a>] Lmdbjava - benchmarks, Ben Alex, https://github.com/lmdbjava/benchmarks/blob/master/results/20160630/README.md, Date accessed: 2018-10-14.</p>
<p>[<a href="https://www.linkedin.com/pulse/lies-damn-statistics-benchmarks-howard-chu" title="Lies, Damn Lies, Statistics, and Benchmarks, Howard Chu">32</a>] Lies, Damn Lies, Statistics, and Benchmarks, Howard Chu, https://www.linkedin.com/pulse/lies-damn-statistics-benchmarks-howard-chu, Date accessed: 2018-10-29.</p>
<p>[<a href="http://www.lmdb.tech/bench/hyperdex/" title="HyperDex Benchmark, Symas Corp">33</a>] HyperDex Benchmark, Symas Corp, http://www.lmdb.tech/bench/hyperdex/, Date accessed: 2018-10-29.</p>
<p>[<a href="https://github.com/mimblewimble/grin/blob/master/doc/wallet/usage.md" title="Grin - Basic Wallet">34</a>] Grin - Basic Wallet, https://github.com/mimblewimble/grin/blob/master/doc/wallet/usage.md, Date accessed: 2018-10-15.</p>
<p>[<a href="https://www.grin-forum.org/t/yeastplume-progress-update-thread-may-sept-2018/361/12" title="Progress update May - Sep 2018, Yeastplume">35</a>] Progress update May - Sep 2018, Yeastplume, https://www.grin-forum.org/t/yeastplume-progress-update-thread-may-sept-2018/361/12, Date accessed: 2018-10-28.</p>
<a class="header" href="#contributors-6" id="contributors-6"><h2>Contributors</h2></a>
<ul>
<li>https://github.com/neonknight64</li>
<li>https://github.com/hansieodendaal</li>
<li>https://github.com/SWvheerden</li>
<li>https://github.com/philipr-za</li>
</ul>
<a class="header" href="#atomic-swaps-1" id="atomic-swaps-1"><h1>Atomic swaps</h1></a>
<a class="header" href="#what-are-atomic-swaps" id="what-are-atomic-swaps"><h2>What are Atomic swaps</h2></a>
<p>Atomic swaps or cross-chain atomic swaps <a href="https://coinsutra.com/atomic-swap/">[1]</a> in a nutshell are decentralized exchanges, but only for cryptocurrencies. This allows multiple parties to exchange two different crypto currencies in a trustless environment. If one party defaults or fails the transaction, neither party can &quot;run off&quot; with the anyone's money.  For this to work, we will require two technologies: a payment channel and hashed timelock contracts. An implementation of a payment channel is the lightning network.</p>
<a class="header" href="#hashed-timelock-contracts" id="hashed-timelock-contracts"><h2>Hashed Timelock Contracts</h2></a>
<p>Hashed Timelock Contracts (HTLC) <a href="https://hackernoon.com/what-are-hashed-timelock-contracts-htlcs-application-in-lightning-network-payment-channels-14437eeb9345">[2]</a> is one of the most important technologies required for atomic swaps. This is a payment class that uses hashlocks and timelocks to require certain public knowledge before doing a payment, otherwise the payment is reversed. HTLCs are also crucial in the lighting network <a href="https://lightning.network/lightning-network-paper.pdf">[3]</a>.</p>
<p>Here is a quick example of how a HTLC works:</p>
<p><img src="sources/Characters.png" alt="alt" /></p>
<p>In this example Alex's wants to pay Carla, but he does not have an open payment channel to Carla. But he does have an open channel to Bart who does have an open channel to Carla.</p>
<ol>
<li>Carla generates a random number and gives the hash of the number to Alex.</li>
<li>Alex pays Bart but adds the condition that if Bart wants to claim the payment he has to provide the random number that generated the hash Carlo gave to Alex.</li>
<li>Bart pays Carlo, but he adds the same condition to the payment.</li>
<li>Carla claims the payment by providing the random number, and thus exposing the random number to Bart.</li>
<li>Bart uses the random number to claim the payment from Alex.</li>
</ol>
<p>If the payment to Carla does not go through the timelock in the contract will reverse all transactions.</p>
<a class="header" href="#atomic-vs-etomic" id="atomic-vs-etomic"><h2>Atomic vs Etomic</h2></a>
<p>For an atomic swap transaction to happen, both cryptocurrencies must use the same hashing function as this is crucial for HTLC to function. Etomic swaps was created in an attempt to make atomic swaps happen between Bitcoin tokens and Ethereum based tokens.</p>
<a class="header" href="#examples-of-current-atomic-swaps-and-implementations" id="examples-of-current-atomic-swaps-and-implementations"><h2>Examples of current atomic swaps and implementations</h2></a>
<a class="header" href="#a1-manual-method" id="a1-manual-method"><h3>#1 Manual method</h3></a>
<p>An article was posted on Hackernoon <a href="https://hackernoon.com/so-how-do-i-really-do-an-atomic-swap-f797852c7639">[3]</a> showing the exact steps that is required for doing an atomic swap using cli.</p>
<p>The requirements for this method can be listed as follows:</p>
<ul>
<li>Full nodes on both parties.</li>
<li>Atomic swap package [[4].</li>
<li>Use of supported coins (UXTO based protocol coins, eg Bitcoin, Litecoin, Viacoin).</li>
<li>Power user.</li>
</ul>
<a class="header" href="#a2-atomic-wallet" id="a2-atomic-wallet"><h3>#2 Atomic Wallet</h3></a>
<p>Atomic wallet <a href="https://atomicwallet.io/">[5]</a> is an atomic swap exchange. They allow two parties to trade with them as a third party.  The process looks as follows:</p>
<ol>
<li>Party A select an order from the BitTorrent order book.</li>
<li>Party A enter an amount of coin to swap or coin to receive.</li>
<li>Party A confirm the swap.</li>
<li>Party B receives notification.</li>
<li>Party B confirms the swap.</li>
<li>First party and Second party’s Atomic Wallet checks the contracts.</li>
<li>Both receive their coins.</li>
</ol>
<a class="header" href="#a3-barterdex" id="a3-barterdex"><h3>#3 BarterDEX</h3></a>
<p>BarterDEX is a decentralized exchange created by Komodo <a href="https://komodoplatform.com/decentralized-exchange/">[6]</a> but it works with electron servers or native. BarterDEX at its core is more like an auction system then a true decentralized exchange. It also uses a security deposit in the form of Zcredits to do swaps without waiting for confirmation.</p>
<p>BarterDEX also supports Etomic swaps. These work by keeping the payments locked in a etomic blockchain which will act as a third party. Although swaps have been done, it is stated as not yet production ready <a href="https://github.com/artemii235/etomic-swap">[7]</a>. Currently (July 2018) its only possible to use Barterdex out of the  cli <a href="%22https://github.com/KomodoPlatform/KomodoPlatform/wiki/Installing-and-Using-Komodo-Platform-(barterDEX)%22">[8]</a>.  Barterdex charges a 0.1287% fee for a swap <a href="https://github.com/KomodoPlatform/KomodoPlatform/wiki/barterDEX-Whitepaper-v2">[9]</a>.</p>
<a class="header" href="#references-12" id="references-12"><h2>References</h2></a>
<p>[1] Sudhir Khatwani (2018) <em>What Is Atomic Swap and Why It Matters?</em>, <em>Coinsutra</em>. Available at: https://coinsutra.com/atomic-swap/ (Accessed: 12 July 2018).</p>
<p>[2] Vohra, A. (2016) <em>What Are Hashed Timelock Contracts (HTLCs)? Application In Lightning Network &amp; Payment Channels</em>, <em>Hackernoon</em>. Available at: https://hackernoon.com/what-are-hashed-timelock-contracts-htlcs-application-in-lightning-network-payment-channels-14437eeb9345 (Accessed: 12 July 2018).</p>
<p>[3] Poon, J. and Dryja, T. (2016) <em>The Bitcoin Lightning Network: Scalable Off-Chain Instant Payments v0.5.9.2</em>. Available at: https://lightning.network/lightning-network-paper.pdf.</p>
<p>[3] Hotshot (2018) <em>So how do I really do an atomic swap</em>, <em>Hackernoon</em>. Available at: https://hackernoon.com/so-how-do-i-really-do-an-atomic-swap-f797852c7639 (Accessed: 13 July 2018).</p>
<p>[4] open source (ISC) (2018) ‘viacoin/atomicswap’. github. Available at: https://github.com/viacoin/atomicswap.</p>
<p>[5] Atomic (2018) <em>Atomic wallet</em>. Available at: https://atomicwallet.io/ (Accessed: 13 July 2018).</p>
<p>[6] Komodo (2018) <em>BarterDEX</em>. Available at: https://komodoplatform.com/decentralized-exchange/ (Accessed: 13 July 2018).</p>
<p>[7] Artemii235 (2018) ‘etomic-swap’. github. Available at: https://github.com/artemii235/etomic-swap.</p>
<p>[8] Komodo (2018) ‘Barterdex’. github. Available at: https://github.com/KomodoPlatform/KomodoPlatform/wiki/Installing-and-Using-Komodo-Platform-(barterDEX).</p>
<p>[9] Komodo and Hossain, S. (2017) <em>barterDEX Whitepaper v2</em>. Available at: https://github.com/KomodoPlatform/KomodoPlatform/wiki/barterDEX-Whitepaper-v2.</p>
<a class="header" href="#contributors-7" id="contributors-7"><h2>Contributors</h2></a>
<ul>
<li>https://github.com/SWvheerden</li>
</ul>
<a class="header" href="#lightning-network-for-dummies" id="lightning-network-for-dummies"><h1>Lightning Network for Dummies</h1></a>
<iframe width=750 height=600 src="https://gitpitch.com/tari-labs/tari-university/master?p=/src/protocols/lightning-network-for-dummies#/"></iframe>
<a class="header" href="#having-trouble-viewing-this-presentation-5" id="having-trouble-viewing-this-presentation-5"><h3>Having trouble viewing this presentation?</h3></a>
<p>View it in a <a href="https://gitpitch.com/tari-labs/tari-university/master?p=/src/protocols/lightning-network-for-dummies#/">separate window</a>.</p>
<a class="header" href="#introduction-to-spv-merkle-trees-and-bloom-filters" id="introduction-to-spv-merkle-trees-and-bloom-filters"><h1>Introduction to SPV, Merkle Trees and Bloom Filters</h1></a>
<iframe width=750 height=600 src="https://gitpitch.com/tari-labs/tari-university/master?p=/src/protocols/merkle-trees-and-spv-1#/"></iframe>
<a class="header" href="#having-trouble-viewing-this-presentation-6" id="having-trouble-viewing-this-presentation-6"><h3>Having trouble viewing this presentation?</h3></a>
<p>View it in a <a href="https://gitpitch.com/tari-labs/tari-university/master?p=/src/protocols/merkle-trees-and-spv-1#/">separate window</a>.</p>
<a class="header" href="#the-rgb-protocol---an-introduction" id="the-rgb-protocol---an-introduction"><h1>The RGB Protocol - An Introduction</h1></a>
<iframe width=750 height=600 src="https://gitpitch.com/tari-labs/tari-university/master?p=/src/protocols/rgb-introduction#/"></iframe>
<a class="header" href="#having-trouble-viewing-this-presentation-7" id="having-trouble-viewing-this-presentation-7"><h3>Having trouble viewing this presentation?</h3></a>
<p>View it in a <a href="https://gitpitch.com/tari-labs/tari-university/master?p=/src/protocols/rgb-introduction#/">separate window</a>.</p>
<a class="header" href="#tlu-labs" id="tlu-labs"><h1>TLU Labs</h1></a>
<p>This chapter contains various new features and demos that we're thinking of adding to make the TLU experience better
. Since this is experimental, things might not work 100% here.</p>
<a class="header" href="#mermaid-demo" id="mermaid-demo"><h1>Mermaid Demo</h1></a>
<p>TLU can now support mermaid diagrams! Flowcharts, sequence diagrams and more!</p>
<a class="header" href="#how-to-write-mermaid-diagrams" id="how-to-write-mermaid-diagrams"><h3>How to write mermaid diagrams.</h3></a>
<ol>
<li><a href="https://mermaidjs.github.io">RTFM</a>.</li>
<li>Wrap your mermaid code in <code>&lt;div&gt;</code> tags. Add the <code>class=mermaid</code> attribute to the tag. So your code will look like</li>
</ol>
<pre><code class="language-html">&lt;div class=&quot;mermaid&quot;&gt;
graph LR
...
&lt;/div&gt;
</code></pre>
<ol start="3">
<li><strong>Note:</strong> You can't have blank lines in your diagrams, unfortunately, because the markdown renderer will interpret
this as a new paragraph and break your diagram. However, you can <em>sort of</em> workaround this by putting a <code>#</code> as a
spacer (see first example).</li>
</ol>
<a class="header" href="#sequence-diagram-example" id="sequence-diagram-example"><h2>Sequence diagram example</h2></a>
<pre><code class="language-html">&lt;div  class=mermaid&gt;
sequenceDiagram
    Alice -&gt;&gt; Bob: Hello Bob, how are you?
    Bob--&gt;&gt;John: How about you John?
    Bob--x Alice: I am good thanks!
    Bob-x John: I am good thanks!
 #
    Note right of John: Bob thinks a long&lt;br/&gt;long time, so long&lt;br/&gt;that the text does&lt;br/&gt;not fit on a row.
    Bob--&gt;Alice: Checking with John...
    Alice-&gt;John: Yes... John, how are you?
&lt;/div&gt;
</code></pre>
<div class=mermaid>
sequenceDiagram
    Alice ->> Bob: Hello Bob, how are you?
    Bob-->>John: How about you John?
    Bob--x Alice: I am good thanks!
    Bob-x John: I am good thanks!
#
    Note right of John: Bob thinks a long<br/>long time, so long<br/>that the text does<br/>not fit on a row.
    Bob-->Alice: Checking with John...
    Alice->John: Yes... John, how are you?
</div>
<a class="header" href="#flowchart-example" id="flowchart-example"><h2>Flowchart example</h2></a>
<pre><code class="language-html">&lt;div  class=mermaid&gt;
graph LR
    A[Hard edge] --&gt;|Link text| B(Round edge)
    B --&gt; C{Decision}
    C --&gt;|One| D[Result one]
    C --&gt;|Two| E[Result two]
&lt;/div&gt;
</code></pre>
<div  class=mermaid>    
graph LR
    A[Hard edge] -->|Link text| B(Round edge)
    B --> C{Decision}
    C -->|One| D[Result one]
    C -->|Two| E[Result two]    
</div>
<a class="header" href="#gantt-chart-example" id="gantt-chart-example"><h2>Gantt Chart example</h2></a>
<pre><code class="language-html">&lt;div class=&quot;mermaid&quot;&gt;
gantt
       dateFormat  YYYY-MM-DD
       title Adding GANTT diagram functionality to mermaid
       section A section
       Completed task            :done,    des1, 2014-01-06,2014-01-08
       Active task               :active,  des2, 2014-01-09, 3d
       Future task               :         des3, after des2, 5d
       Future task2              :         des4, after des3, 5d
       section Critical tasks
       Completed task in the critical line :crit, done, 2014-01-06,24h
       Implement parser and jison          :crit, done, after des1, 2d
       Create tests for parser             :crit, active, 3d
       Future task in critical line        :crit, 5d
       Create tests for renderer           :2d
       Add to mermaid                      :1d
       section Documentation
       Describe gantt syntax               :active, a1, after des1, 3d
       Add gantt diagram to demo page      :after a1  , 20h
       Add another diagram to demo page    :doc1, after a1  , 48h
       section Last section
       Describe gantt syntax               :after doc1, 3d
       Add gantt diagram to demo page      :20h
       Add another diagram to demo page    :48h
&lt;/div&gt;
</code></pre>
<div class="mermaid">
gantt
       dateFormat  YYYY-MM-DD
       title Adding GANTT diagram functionality to mermaid
       section A section
       Completed task            :done,    des1, 2014-01-06,2014-01-08
       Active task               :active,  des2, 2014-01-09, 3d
       Future task               :         des3, after des2, 5d
       Future task2              :         des4, after des3, 5d
       section Critical tasks
       Completed task in the critical line :crit, done, 2014-01-06,24h
       Implement parser and jison          :crit, done, after des1, 2d
       Create tests for parser             :crit, active, 3d
       Future task in critical line        :crit, 5d
       Create tests for renderer           :2d
       Add to mermaid                      :1d
       section Documentation
       Describe gantt syntax               :active, a1, after des1, 3d
       Add gantt diagram to demo page      :after a1  , 20h
       Add another diagram to demo page    :doc1, after a1  , 48h
       section Last section
       Describe gantt syntax               :after doc1, 3d
       Add gantt diagram to demo page      :20h
       Add another diagram to demo page    :48h
</div>       
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Initialize mermaid -->
        <script src="theme/js/mermaid.min.js" type="text/javascript" charset="utf-8"></script>
        <script>mermaid.initialize({startOnLoad:true});</script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
